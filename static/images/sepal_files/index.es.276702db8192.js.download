var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var _a2;
var base = "";
var templatesBase = "";
var tailwind = "";
const getHostName = () => {
  return window.dpLocal || window.dpServed ? null : window.location.origin.concat("/");
};
const env = {};
env.url = getHostName();
function normalize$1(strArray) {
  var resultArray = [];
  if (strArray.length === 0) {
    return "";
  }
  if (typeof strArray[0] !== "string") {
    throw new TypeError("Url must be a string. Received " + strArray[0]);
  }
  if (strArray[0].match(/^[^/:]+:\/*$/) && strArray.length > 1) {
    var first = strArray.shift();
    strArray[0] = first + strArray[0];
  }
  if (strArray[0].match(/^file:\/\/\//)) {
    strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1:///");
  } else {
    strArray[0] = strArray[0].replace(/^([^/:]+):\/*/, "$1://");
  }
  for (var i2 = 0; i2 < strArray.length; i2++) {
    var component = strArray[i2];
    if (typeof component !== "string") {
      throw new TypeError("Url must be a string. Received " + component);
    }
    if (component === "") {
      continue;
    }
    if (i2 > 0) {
      component = component.replace(/^[\/]+/, "");
    }
    if (i2 < strArray.length - 1) {
      component = component.replace(/[\/]+$/, "");
    } else {
      component = component.replace(/[\/]+$/, "/");
    }
    resultArray.push(component);
  }
  var str2 = resultArray.join("/");
  str2 = str2.replace(/\/(\?|&|#[^!])/g, "$1");
  var parts = str2.split("?");
  str2 = parts.shift() + (parts.length > 0 ? "?" : "") + parts.join("&");
  return str2;
}
function urlJoin() {
  var input;
  if (typeof arguments[0] === "object") {
    input = arguments[0];
  } else {
    input = [].slice.call(arguments);
  }
  return normalize$1(input);
}
function _typeof(obj) {
  "@babel/helpers - typeof";
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function(obj2) {
      return typeof obj2;
    };
  } else {
    _typeof = function(obj2) {
      return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
    };
  }
  return _typeof(obj);
}
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
function _defineProperties(target, props) {
  for (var i2 = 0; i2 < props.length; i2++) {
    var descriptor = props[i2];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor)
      descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}
function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps)
    _defineProperties(Constructor.prototype, protoProps);
  if (staticProps)
    _defineProperties(Constructor, staticProps);
  return Constructor;
}
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }
  return obj;
}
function ownKeys$2(object, enumerableOnly) {
  var keys3 = Object.keys(object);
  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    if (enumerableOnly)
      symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    keys3.push.apply(keys3, symbols);
  }
  return keys3;
}
function _objectSpread2(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2] != null ? arguments[i2] : {};
    if (i2 % 2) {
      ownKeys$2(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      ownKeys$2(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }
  return target;
}
function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }
  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  if (superClass)
    _setPrototypeOf(subClass, superClass);
}
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
    return o2.__proto__ || Object.getPrototypeOf(o2);
  };
  return _getPrototypeOf(o);
}
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
    o2.__proto__ = p2;
    return o2;
  };
  return _setPrototypeOf(o, p);
}
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct)
    return false;
  if (Reflect.construct.sham)
    return false;
  if (typeof Proxy === "function")
    return true;
  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function() {
    }));
    return true;
  } catch (e) {
    return false;
  }
}
function _assertThisInitialized(self2) {
  if (self2 === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }
  return self2;
}
function _possibleConstructorReturn(self2, call2) {
  if (call2 && (typeof call2 === "object" || typeof call2 === "function")) {
    return call2;
  }
  return _assertThisInitialized(self2);
}
function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived), result;
    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }
    return _possibleConstructorReturn(this, result);
  };
}
function _slicedToArray(arr, i2) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i2) || _unsupportedIterableToArray(arr, i2) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i2) {
  if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr)))
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i2 && _arr.length === i2)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _unsupportedIterableToArray(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _arrayLikeToArray(o, minLen);
}
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i2 = 0, arr2 = new Array(len); i2 < len; i2++)
    arr2[i2] = arr[i2];
  return arr2;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _createForOfIteratorHelper(o, allowArrayLike) {
  var it;
  if (typeof Symbol === "undefined" || o[Symbol.iterator] == null) {
    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
      if (it)
        o = it;
      var i2 = 0;
      var F = function() {
      };
      return {
        s: F,
        n: function() {
          if (i2 >= o.length)
            return {
              done: true
            };
          return {
            done: false,
            value: o[i2++]
          };
        },
        e: function(e) {
          throw e;
        },
        f: F
      };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  var normalCompletion = true, didErr = false, err;
  return {
    s: function() {
      it = o[Symbol.iterator]();
    },
    n: function() {
      var step = it.next();
      normalCompletion = step.done;
      return step;
    },
    e: function(e) {
      didErr = true;
      err = e;
    },
    f: function() {
      try {
        if (!normalCompletion && it.return != null)
          it.return();
      } finally {
        if (didErr)
          throw err;
      }
    }
  };
}
var f = String.fromCharCode;
var keyStrBase64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var keyStrUriSafe = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+-$";
var baseReverseDic = {};
function getBaseValue(alphabet, character) {
  if (!baseReverseDic[alphabet]) {
    baseReverseDic[alphabet] = {};
    for (var i2 = 0; i2 < alphabet.length; i2++) {
      baseReverseDic[alphabet][alphabet.charAt(i2)] = i2;
    }
  }
  return baseReverseDic[alphabet][character];
}
var LZString = {
  compressToBase64: function compressToBase64(input) {
    if (input == null)
      return "";
    var res = LZString._compress(input, 6, function(a) {
      return keyStrBase64.charAt(a);
    });
    switch (res.length % 4) {
      default:
      case 0:
        return res;
      case 1:
        return res + "===";
      case 2:
        return res + "==";
      case 3:
        return res + "=";
    }
  },
  decompressFromBase64: function decompressFromBase64(input) {
    if (input == null)
      return "";
    if (input == "")
      return null;
    return LZString._decompress(input.length, 32, function(index) {
      return getBaseValue(keyStrBase64, input.charAt(index));
    });
  },
  compressToUTF16: function compressToUTF16(input) {
    if (input == null)
      return "";
    return LZString._compress(input, 15, function(a) {
      return f(a + 32);
    }) + " ";
  },
  decompressFromUTF16: function decompressFromUTF16(compressed) {
    if (compressed == null)
      return "";
    if (compressed == "")
      return null;
    return LZString._decompress(compressed.length, 16384, function(index) {
      return compressed.charCodeAt(index) - 32;
    });
  },
  compressToUint8Array: function compressToUint8Array(uncompressed) {
    var compressed = LZString.compress(uncompressed);
    var buf = new Uint8Array(compressed.length * 2);
    for (var i2 = 0, TotalLen = compressed.length; i2 < TotalLen; i2++) {
      var current_value = compressed.charCodeAt(i2);
      buf[i2 * 2] = current_value >>> 8;
      buf[i2 * 2 + 1] = current_value % 256;
    }
    return buf;
  },
  decompressFromUint8Array: function decompressFromUint8Array(compressed) {
    if (compressed === null || compressed === void 0) {
      return LZString.decompress(compressed);
    } else {
      var buf = new Array(compressed.length / 2);
      for (var i2 = 0, TotalLen = buf.length; i2 < TotalLen; i2++) {
        buf[i2] = compressed[i2 * 2] * 256 + compressed[i2 * 2 + 1];
      }
      var result = [];
      buf.forEach(function(c) {
        result.push(f(c));
      });
      return LZString.decompress(result.join(""));
    }
  },
  compressToEncodedURIComponent: function compressToEncodedURIComponent(input) {
    if (input == null)
      return "";
    return LZString._compress(input, 6, function(a) {
      return keyStrUriSafe.charAt(a);
    });
  },
  decompressFromEncodedURIComponent: function decompressFromEncodedURIComponent(input) {
    if (input == null)
      return "";
    if (input == "")
      return null;
    input = input.replace(/ /g, "+");
    return LZString._decompress(input.length, 32, function(index) {
      return getBaseValue(keyStrUriSafe, input.charAt(index));
    });
  },
  compress: function compress(uncompressed) {
    return LZString._compress(uncompressed, 16, function(a) {
      return f(a);
    });
  },
  _compress: function _compress(uncompressed, bitsPerChar, getCharFromInt) {
    if (uncompressed == null)
      return "";
    var i2, value, context_dictionary = {}, context_dictionaryToCreate = {}, context_c = "", context_wc = "", context_w = "", context_enlargeIn = 2, context_dictSize = 3, context_numBits = 2, context_data = [], context_data_val = 0, context_data_position = 0, ii;
    for (ii = 0; ii < uncompressed.length; ii += 1) {
      context_c = uncompressed.charAt(ii);
      if (!Object.prototype.hasOwnProperty.call(context_dictionary, context_c)) {
        context_dictionary[context_c] = context_dictSize++;
        context_dictionaryToCreate[context_c] = true;
      }
      context_wc = context_w + context_c;
      if (Object.prototype.hasOwnProperty.call(context_dictionary, context_wc)) {
        context_w = context_wc;
      } else {
        if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
          if (context_w.charCodeAt(0) < 256) {
            for (i2 = 0; i2 < context_numBits; i2++) {
              context_data_val = context_data_val << 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
            }
            value = context_w.charCodeAt(0);
            for (i2 = 0; i2 < 8; i2++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          } else {
            value = 1;
            for (i2 = 0; i2 < context_numBits; i2++) {
              context_data_val = context_data_val << 1 | value;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = 0;
            }
            value = context_w.charCodeAt(0);
            for (i2 = 0; i2 < 16; i2++) {
              context_data_val = context_data_val << 1 | value & 1;
              if (context_data_position == bitsPerChar - 1) {
                context_data_position = 0;
                context_data.push(getCharFromInt(context_data_val));
                context_data_val = 0;
              } else {
                context_data_position++;
              }
              value = value >> 1;
            }
          }
          context_enlargeIn--;
          if (context_enlargeIn == 0) {
            context_enlargeIn = Math.pow(2, context_numBits);
            context_numBits++;
          }
          delete context_dictionaryToCreate[context_w];
        } else {
          value = context_dictionary[context_w];
          for (i2 = 0; i2 < context_numBits; i2++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        context_dictionary[context_wc] = context_dictSize++;
        context_w = String(context_c);
      }
    }
    if (context_w !== "") {
      if (Object.prototype.hasOwnProperty.call(context_dictionaryToCreate, context_w)) {
        if (context_w.charCodeAt(0) < 256) {
          for (i2 = 0; i2 < context_numBits; i2++) {
            context_data_val = context_data_val << 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
          }
          value = context_w.charCodeAt(0);
          for (i2 = 0; i2 < 8; i2++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        } else {
          value = 1;
          for (i2 = 0; i2 < context_numBits; i2++) {
            context_data_val = context_data_val << 1 | value;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = 0;
          }
          value = context_w.charCodeAt(0);
          for (i2 = 0; i2 < 16; i2++) {
            context_data_val = context_data_val << 1 | value & 1;
            if (context_data_position == bitsPerChar - 1) {
              context_data_position = 0;
              context_data.push(getCharFromInt(context_data_val));
              context_data_val = 0;
            } else {
              context_data_position++;
            }
            value = value >> 1;
          }
        }
        context_enlargeIn--;
        if (context_enlargeIn == 0) {
          context_enlargeIn = Math.pow(2, context_numBits);
          context_numBits++;
        }
        delete context_dictionaryToCreate[context_w];
      } else {
        value = context_dictionary[context_w];
        for (i2 = 0; i2 < context_numBits; i2++) {
          context_data_val = context_data_val << 1 | value & 1;
          if (context_data_position == bitsPerChar - 1) {
            context_data_position = 0;
            context_data.push(getCharFromInt(context_data_val));
            context_data_val = 0;
          } else {
            context_data_position++;
          }
          value = value >> 1;
        }
      }
      context_enlargeIn--;
      if (context_enlargeIn == 0) {
        context_enlargeIn = Math.pow(2, context_numBits);
        context_numBits++;
      }
    }
    value = 2;
    for (i2 = 0; i2 < context_numBits; i2++) {
      context_data_val = context_data_val << 1 | value & 1;
      if (context_data_position == bitsPerChar - 1) {
        context_data_position = 0;
        context_data.push(getCharFromInt(context_data_val));
        context_data_val = 0;
      } else {
        context_data_position++;
      }
      value = value >> 1;
    }
    while (true) {
      context_data_val = context_data_val << 1;
      if (context_data_position == bitsPerChar - 1) {
        context_data.push(getCharFromInt(context_data_val));
        break;
      } else
        context_data_position++;
    }
    return context_data.join("");
  },
  decompress: function decompress(compressed) {
    if (compressed == null)
      return "";
    if (compressed == "")
      return null;
    return LZString._decompress(compressed.length, 32768, function(index) {
      return compressed.charCodeAt(index);
    });
  },
  _decompress: function _decompress(length, resetValue, getNextValue) {
    var dictionary = [], enlargeIn = 4, dictSize = 4, numBits = 3, entry = "", result = [], i2, w, bits, resb, maxpower, power, c, data2 = {
      val: getNextValue(0),
      position: resetValue,
      index: 1
    };
    for (i2 = 0; i2 < 3; i2 += 1) {
      dictionary[i2] = i2;
    }
    bits = 0;
    maxpower = Math.pow(2, 2);
    power = 1;
    while (power != maxpower) {
      resb = data2.val & data2.position;
      data2.position >>= 1;
      if (data2.position == 0) {
        data2.position = resetValue;
        data2.val = getNextValue(data2.index++);
      }
      bits |= (resb > 0 ? 1 : 0) * power;
      power <<= 1;
    }
    switch (bits) {
      case 0:
        bits = 0;
        maxpower = Math.pow(2, 8);
        power = 1;
        while (power != maxpower) {
          resb = data2.val & data2.position;
          data2.position >>= 1;
          if (data2.position == 0) {
            data2.position = resetValue;
            data2.val = getNextValue(data2.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = f(bits);
        break;
      case 1:
        bits = 0;
        maxpower = Math.pow(2, 16);
        power = 1;
        while (power != maxpower) {
          resb = data2.val & data2.position;
          data2.position >>= 1;
          if (data2.position == 0) {
            data2.position = resetValue;
            data2.val = getNextValue(data2.index++);
          }
          bits |= (resb > 0 ? 1 : 0) * power;
          power <<= 1;
        }
        c = f(bits);
        break;
      case 2:
        return "";
    }
    dictionary[3] = c;
    w = c;
    result.push(c);
    while (true) {
      if (data2.index > length) {
        return "";
      }
      bits = 0;
      maxpower = Math.pow(2, numBits);
      power = 1;
      while (power != maxpower) {
        resb = data2.val & data2.position;
        data2.position >>= 1;
        if (data2.position == 0) {
          data2.position = resetValue;
          data2.val = getNextValue(data2.index++);
        }
        bits |= (resb > 0 ? 1 : 0) * power;
        power <<= 1;
      }
      switch (c = bits) {
        case 0:
          bits = 0;
          maxpower = Math.pow(2, 8);
          power = 1;
          while (power != maxpower) {
            resb = data2.val & data2.position;
            data2.position >>= 1;
            if (data2.position == 0) {
              data2.position = resetValue;
              data2.val = getNextValue(data2.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize - 1;
          enlargeIn--;
          break;
        case 1:
          bits = 0;
          maxpower = Math.pow(2, 16);
          power = 1;
          while (power != maxpower) {
            resb = data2.val & data2.position;
            data2.position >>= 1;
            if (data2.position == 0) {
              data2.position = resetValue;
              data2.val = getNextValue(data2.index++);
            }
            bits |= (resb > 0 ? 1 : 0) * power;
            power <<= 1;
          }
          dictionary[dictSize++] = f(bits);
          c = dictSize - 1;
          enlargeIn--;
          break;
        case 2:
          return result.join("");
      }
      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
      if (dictionary[c]) {
        entry = dictionary[c];
      } else {
        if (c === dictSize) {
          entry = w + w.charAt(0);
        } else {
          return null;
        }
      }
      result.push(entry);
      dictionary[dictSize++] = w + entry.charAt(0);
      enlargeIn--;
      w = entry;
      if (enlargeIn == 0) {
        enlargeIn = Math.pow(2, numBits);
        numBits++;
      }
    }
  }
};
var version$1 = "1.25.1";
var Config$1 = {
  DEBUG: false,
  LIB_VERSION: version$1
};
var ArrayProto = Array.prototype, FuncProto = Function.prototype, ObjProto = Object.prototype, slice = ArrayProto.slice, toString$2 = ObjProto.toString, hasOwnProperty$1 = ObjProto.hasOwnProperty, win = typeof window !== "undefined" ? window : {}, navigator$1 = win.navigator || {
  userAgent: ""
}, document$1$1 = win.document || {}, userAgent$1 = navigator$1.userAgent;
var nativeBind = FuncProto.bind, nativeForEach = ArrayProto.forEach, nativeIndexOf = ArrayProto.indexOf, nativeIsArray = Array.isArray, breaker = {};
var _ = {
  trim: function trim(str2) {
    return str2.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
  }
};
var logger = {
  log: function log() {
    if (Config$1.DEBUG && !_.isUndefined(window.console) && window.console) {
      var log2 = window.console.log["__rrweb_original__"] ? window.console.log["__rrweb_original__"] : window.console.log;
      try {
        log2.apply(window.console, arguments);
      } catch (err) {
        _.each(arguments, function(arg) {
          log2(arg);
        });
      }
    }
  },
  error: function error2() {
    if (Config$1.DEBUG && !_.isUndefined(window.console) && window.console) {
      var args = ["PostHog error:"].concat(Array.prototype.slice.call(arguments));
      var error6 = window.console.error["__rrweb_original__"] ? window.console.error["__rrweb_original__"] : window.console.error;
      try {
        error6.apply(window.console, args);
      } catch (err) {
        _.each(args, function(arg) {
          error6(arg);
        });
      }
    }
  },
  critical: function critical() {
    if (!_.isUndefined(window.console) && window.console) {
      var args = ["PostHog error:"].concat(Array.prototype.slice.call(arguments));
      var error6 = window.console.error["__rrweb_original__"] ? window.console.error["__rrweb_original__"] : window.console.error;
      try {
        error6.apply(window.console, args);
      } catch (err) {
        _.each(args, function(arg) {
          error6(arg);
        });
      }
    }
  }
};
_.bind = function(func, context) {
  var args, _bound;
  if (nativeBind && func.bind === nativeBind) {
    return nativeBind.apply(func, slice.call(arguments, 1));
  }
  if (!_.isFunction(func)) {
    throw new TypeError();
  }
  args = slice.call(arguments, 2);
  _bound = function bound() {
    if (!(this instanceof _bound)) {
      return func.apply(context, args.concat(slice.call(arguments)));
    }
    var ctor = {};
    ctor.prototype = func.prototype;
    var self2 = new ctor();
    ctor.prototype = null;
    var result = func.apply(self2, args.concat(slice.call(arguments)));
    if (Object(result) === result) {
      return result;
    }
    return self2;
  };
  return _bound;
};
_.bind_instance_methods = function(obj) {
  for (var func in obj) {
    if (typeof obj[func] === "function") {
      obj[func] = _.bind(obj[func], obj);
    }
  }
};
_.each = function(obj, iterator, context) {
  if (obj === null || obj === void 0) {
    return;
  }
  if (nativeForEach && obj.forEach === nativeForEach) {
    obj.forEach(iterator, context);
  } else if (obj.length === +obj.length) {
    for (var i2 = 0, l = obj.length; i2 < l; i2++) {
      if (i2 in obj && iterator.call(context, obj[i2], i2, obj) === breaker) {
        return;
      }
    }
  } else {
    for (var key in obj) {
      if (hasOwnProperty$1.call(obj, key)) {
        if (iterator.call(context, obj[key], key, obj) === breaker) {
          return;
        }
      }
    }
  }
};
_.extend = function(obj) {
  _.each(slice.call(arguments, 1), function(source) {
    for (var prop in source) {
      if (source[prop] !== void 0) {
        obj[prop] = source[prop];
      }
    }
  });
  return obj;
};
_.isArray = nativeIsArray || function(obj) {
  return toString$2.call(obj) === "[object Array]";
};
_.isFunction = function(f2) {
  try {
    return /^\s*\bfunction\b/.test(f2);
  } catch (x2) {
    return false;
  }
};
_.include = function(obj, target) {
  var found = false;
  if (obj === null) {
    return found;
  }
  if (nativeIndexOf && obj.indexOf === nativeIndexOf) {
    return obj.indexOf(target) != -1;
  }
  _.each(obj, function(value) {
    if (found || (found = value === target)) {
      return breaker;
    }
  });
  return found;
};
_.includes = function(str2, needle) {
  return str2.indexOf(needle) !== -1;
};
_.isObject = function(obj) {
  return obj === Object(obj) && !_.isArray(obj);
};
_.isEmptyObject = function(obj) {
  if (_.isObject(obj)) {
    for (var key in obj) {
      if (hasOwnProperty$1.call(obj, key)) {
        return false;
      }
    }
    return true;
  }
  return false;
};
_.isUndefined = function(obj) {
  return obj === void 0;
};
_.isString = function(obj) {
  return toString$2.call(obj) == "[object String]";
};
_.isDate = function(obj) {
  return toString$2.call(obj) == "[object Date]";
};
_.isNumber = function(obj) {
  return toString$2.call(obj) == "[object Number]";
};
_.encodeDates = function(obj) {
  _.each(obj, function(v, k) {
    if (_.isDate(v)) {
      obj[k] = _.formatDate(v);
    } else if (_.isObject(v)) {
      obj[k] = _.encodeDates(v);
    }
  });
  return obj;
};
_.timestamp = function() {
  Date.now = Date.now || function() {
    return +new Date();
  };
  return Date.now();
};
_.formatDate = function(d2) {
  function pad(n) {
    return n < 10 ? "0" + n : n;
  }
  return d2.getUTCFullYear() + "-" + pad(d2.getUTCMonth() + 1) + "-" + pad(d2.getUTCDate()) + "T" + pad(d2.getUTCHours()) + ":" + pad(d2.getUTCMinutes()) + ":" + pad(d2.getUTCSeconds());
};
_.safewrap = function(f2) {
  return function() {
    try {
      return f2.apply(this, arguments);
    } catch (e) {
      logger.critical("Implementation error. Please turn on debug and contact support@posthog.com.");
      if (Config$1.DEBUG) {
        logger.critical(e);
      }
    }
  };
};
_.safewrap_class = function(klass, functions) {
  for (var i2 = 0; i2 < functions.length; i2++) {
    klass.prototype[functions[i2]] = _.safewrap(klass.prototype[functions[i2]]);
  }
};
_.safewrap_instance_methods = function(obj) {
  for (var func in obj) {
    if (typeof obj[func] === "function") {
      obj[func] = _.safewrap(obj[func]);
    }
  }
};
_.strip_empty_properties = function(p) {
  var ret = {};
  _.each(p, function(v, k) {
    if (_.isString(v) && v.length > 0) {
      ret[k] = v;
    }
  });
  return ret;
};
var COPY_IN_PROGRESS_ATTRIBUTE = typeof Symbol !== "undefined" ? Symbol("__deepCircularCopyInProgress__") : "__deepCircularCopyInProgress__";
function deepCircularCopy(value, customizer, key) {
  if (value !== Object(value))
    return customizer ? customizer(value, key) : value;
  if (value[COPY_IN_PROGRESS_ATTRIBUTE])
    return void 0;
  value[COPY_IN_PROGRESS_ATTRIBUTE] = true;
  var result;
  if (_.isArray(value)) {
    result = [];
    _.each(value, function(it) {
      result.push(deepCircularCopy(it, customizer));
    });
  } else {
    result = {};
    _.each(value, function(val, key2) {
      if (key2 !== COPY_IN_PROGRESS_ATTRIBUTE) {
        result[key2] = deepCircularCopy(val, customizer, key2);
      }
    });
  }
  delete value[COPY_IN_PROGRESS_ATTRIBUTE];
  return result;
}
var LONG_STRINGS_ALLOW_LIST = ["$performance_raw"];
_.copyAndTruncateStrings = function(object, maxStringLength) {
  return deepCircularCopy(object, function(value, key) {
    if (key && LONG_STRINGS_ALLOW_LIST.indexOf(key) > -1) {
      return value;
    }
    if (typeof value === "string" && maxStringLength !== null) {
      value = value.slice(0, maxStringLength);
    }
    return value;
  });
};
_.base64Encode = function(data2) {
  var b64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var o1, o2, o3, h1, h2, h3, h4, bits, i2 = 0, ac = 0, enc = "", tmp_arr = [];
  if (!data2) {
    return data2;
  }
  data2 = _.utf8Encode(data2);
  do {
    o1 = data2.charCodeAt(i2++);
    o2 = data2.charCodeAt(i2++);
    o3 = data2.charCodeAt(i2++);
    bits = o1 << 16 | o2 << 8 | o3;
    h1 = bits >> 18 & 63;
    h2 = bits >> 12 & 63;
    h3 = bits >> 6 & 63;
    h4 = bits & 63;
    tmp_arr[ac++] = b64.charAt(h1) + b64.charAt(h2) + b64.charAt(h3) + b64.charAt(h4);
  } while (i2 < data2.length);
  enc = tmp_arr.join("");
  switch (data2.length % 3) {
    case 1:
      enc = enc.slice(0, -2) + "==";
      break;
    case 2:
      enc = enc.slice(0, -1) + "=";
      break;
  }
  return enc;
};
_.utf8Encode = function(string) {
  string = (string + "").replace(/\r\n/g, "\n").replace(/\r/g, "\n");
  var utftext = "", start, end;
  var stringl = 0, n;
  start = end = 0;
  stringl = string.length;
  for (n = 0; n < stringl; n++) {
    var c1 = string.charCodeAt(n);
    var enc = null;
    if (c1 < 128) {
      end++;
    } else if (c1 > 127 && c1 < 2048) {
      enc = String.fromCharCode(c1 >> 6 | 192, c1 & 63 | 128);
    } else {
      enc = String.fromCharCode(c1 >> 12 | 224, c1 >> 6 & 63 | 128, c1 & 63 | 128);
    }
    if (enc !== null) {
      if (end > start) {
        utftext += string.substring(start, end);
      }
      utftext += enc;
      start = end = n + 1;
    }
  }
  if (end > start) {
    utftext += string.substring(start, string.length);
  }
  return utftext;
};
_.UUID = function() {
  var T = function T2() {
    var d2 = 1 * new Date(), i2 = 0;
    while (d2 == 1 * new Date()) {
      i2++;
    }
    return d2.toString(16) + i2.toString(16);
  };
  var R = function R2() {
    return Math.random().toString(16).replace(".", "");
  };
  var UA = function UA2() {
    var ua = userAgent$1, i2, ch, buffer = [], ret = 0;
    function xor(result, byte_array) {
      var j, tmp = 0;
      for (j = 0; j < byte_array.length; j++) {
        tmp |= buffer[j] << j * 8;
      }
      return result ^ tmp;
    }
    for (i2 = 0; i2 < ua.length; i2++) {
      ch = ua.charCodeAt(i2);
      buffer.unshift(ch & 255);
      if (buffer.length >= 4) {
        ret = xor(ret, buffer);
        buffer = [];
      }
    }
    if (buffer.length > 0) {
      ret = xor(ret, buffer);
    }
    return ret.toString(16);
  };
  return function() {
    var se = (window.screen.height * window.screen.width).toString(16);
    return T() + "-" + R() + "-" + UA() + "-" + se + "-" + T();
  };
}();
_.isBlockedUA = function(ua) {
  if (/(google web preview|baiduspider|yandexbot|bingbot|googlebot|yahoo! slurp|ahrefsbot|facebookexternalhit|facebookcatalog)/i.test(ua)) {
    return true;
  }
  return false;
};
_.HTTPBuildQuery = function(formdata, arg_separator) {
  var use_val, use_key, tph_arr = [];
  if (_.isUndefined(arg_separator)) {
    arg_separator = "&";
  }
  _.each(formdata, function(val, key) {
    use_val = encodeURIComponent(val.toString());
    use_key = encodeURIComponent(key);
    tph_arr[tph_arr.length] = use_key + "=" + use_val;
  });
  return tph_arr.join(arg_separator);
};
_.getQueryParam = function(url, param) {
  param = param.replace(/[[]/, "\\[").replace(/[\]]/, "\\]");
  var regexS = "[\\?&]" + param + "=([^&#]*)", regex = new RegExp(regexS), results = regex.exec(url);
  if (results === null || results && typeof results[1] !== "string" && results[1].length) {
    return "";
  } else {
    var result = results[1];
    try {
      result = decodeURIComponent(result);
    } catch (err) {
      logger.error("Skipping decoding for malformed query param: " + result);
    }
    return result.replace(/\+/g, " ");
  }
};
_.getHashParam = function(hash, param) {
  var matches2 = hash.match(new RegExp(param + "=([^&]*)"));
  return matches2 ? matches2[1] : null;
};
_.register_event = function() {
  var register_event = function register_event2(element, type, handler, oldSchool, useCapture) {
    if (!element) {
      logger.error("No valid element provided to register_event");
      return;
    }
    if (element.addEventListener && !oldSchool) {
      element.addEventListener(type, handler, !!useCapture);
    } else {
      var ontype = "on" + type;
      var old_handler = element[ontype];
      element[ontype] = makeHandler(element, handler, old_handler);
    }
  };
  function makeHandler(element, new_handler, old_handlers) {
    var handler = function handler2(event) {
      event = event || fixEvent(window.event);
      if (!event) {
        return void 0;
      }
      var ret = true;
      var old_result, new_result;
      if (_.isFunction(old_handlers)) {
        old_result = old_handlers(event);
      }
      new_result = new_handler.call(element, event);
      if (false === old_result || false === new_result) {
        ret = false;
      }
      return ret;
    };
    return handler;
  }
  function fixEvent(event) {
    if (event) {
      event.preventDefault = fixEvent.preventDefault;
      event.stopPropagation = fixEvent.stopPropagation;
    }
    return event;
  }
  fixEvent.preventDefault = function() {
    this.returnValue = false;
  };
  fixEvent.stopPropagation = function() {
    this.cancelBubble = true;
  };
  return register_event;
}();
_.info = {
  campaignParams: function campaignParams() {
    var campaign_keywords = "utm_source utm_medium utm_campaign utm_content utm_term gclid fbclid".split(" ");
    var params = {};
    _.each(campaign_keywords, function(kwkey) {
      var kw = _.getQueryParam(document$1$1.URL, kwkey);
      if (kw.length) {
        params[kwkey] = kw;
      }
    });
    return params;
  },
  searchEngine: function searchEngine(referrer) {
    if (referrer.search("https?://(.*)google.([^/?]*)") === 0) {
      return "google";
    } else if (referrer.search("https?://(.*)bing.com") === 0) {
      return "bing";
    } else if (referrer.search("https?://(.*)yahoo.com") === 0) {
      return "yahoo";
    } else if (referrer.search("https?://(.*)duckduckgo.com") === 0) {
      return "duckduckgo";
    } else {
      return null;
    }
  },
  searchInfo: function searchInfo(referrer) {
    var search = _.info.searchEngine(referrer), param = search != "yahoo" ? "q" : "p", ret = {};
    if (search !== null) {
      ret["$search_engine"] = search;
      var keyword = _.getQueryParam(referrer, param);
      if (keyword.length) {
        ret["ph_keyword"] = keyword;
      }
    }
    return ret;
  },
  browser: function browser2(user_agent, vendor, opera) {
    vendor = vendor || "";
    if (opera || _.includes(user_agent, " OPR/")) {
      if (_.includes(user_agent, "Mini")) {
        return "Opera Mini";
      }
      return "Opera";
    } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {
      return "BlackBerry";
    } else if (_.includes(user_agent, "IEMobile") || _.includes(user_agent, "WPDesktop")) {
      return "Internet Explorer Mobile";
    } else if (_.includes(user_agent, "SamsungBrowser/")) {
      return "Samsung Internet";
    } else if (_.includes(user_agent, "Edge") || _.includes(user_agent, "Edg/")) {
      return "Microsoft Edge";
    } else if (_.includes(user_agent, "FBIOS")) {
      return "Facebook Mobile";
    } else if (_.includes(user_agent, "Chrome")) {
      return "Chrome";
    } else if (_.includes(user_agent, "CriOS")) {
      return "Chrome iOS";
    } else if (_.includes(user_agent, "UCWEB") || _.includes(user_agent, "UCBrowser")) {
      return "UC Browser";
    } else if (_.includes(user_agent, "FxiOS")) {
      return "Firefox iOS";
    } else if (_.includes(vendor, "Apple")) {
      if (_.includes(user_agent, "Mobile")) {
        return "Mobile Safari";
      }
      return "Safari";
    } else if (_.includes(user_agent, "Android")) {
      return "Android Mobile";
    } else if (_.includes(user_agent, "Konqueror")) {
      return "Konqueror";
    } else if (_.includes(user_agent, "Firefox")) {
      return "Firefox";
    } else if (_.includes(user_agent, "MSIE") || _.includes(user_agent, "Trident/")) {
      return "Internet Explorer";
    } else if (_.includes(user_agent, "Gecko")) {
      return "Mozilla";
    } else {
      return "";
    }
  },
  browserVersion: function browserVersion(userAgent2, vendor, opera) {
    var browser3 = _.info.browser(userAgent2, vendor, opera);
    var versionRegexs = {
      "Internet Explorer Mobile": /rv:(\d+(\.\d+)?)/,
      "Microsoft Edge": /Edge?\/(\d+(\.\d+)?)/,
      Chrome: /Chrome\/(\d+(\.\d+)?)/,
      "Chrome iOS": /CriOS\/(\d+(\.\d+)?)/,
      "UC Browser": /(UCBrowser|UCWEB)\/(\d+(\.\d+)?)/,
      Safari: /Version\/(\d+(\.\d+)?)/,
      "Mobile Safari": /Version\/(\d+(\.\d+)?)/,
      Opera: /(Opera|OPR)\/(\d+(\.\d+)?)/,
      Firefox: /Firefox\/(\d+(\.\d+)?)/,
      "Firefox iOS": /FxiOS\/(\d+(\.\d+)?)/,
      Konqueror: /Konqueror:(\d+(\.\d+)?)/,
      BlackBerry: /BlackBerry (\d+(\.\d+)?)/,
      "Android Mobile": /android\s(\d+(\.\d+)?)/,
      "Samsung Internet": /SamsungBrowser\/(\d+(\.\d+)?)/,
      "Internet Explorer": /(rv:|MSIE )(\d+(\.\d+)?)/,
      Mozilla: /rv:(\d+(\.\d+)?)/
    };
    var regex = versionRegexs[browser3];
    if (regex === void 0) {
      return null;
    }
    var matches2 = userAgent2.match(regex);
    if (!matches2) {
      return null;
    }
    return parseFloat(matches2[matches2.length - 2]);
  },
  os: function os() {
    var a = userAgent$1;
    if (/Windows/i.test(a)) {
      if (/Phone/.test(a) || /WPDesktop/.test(a)) {
        return "Windows Phone";
      }
      return "Windows";
    } else if (/(iPhone|iPad|iPod)/.test(a)) {
      return "iOS";
    } else if (/Android/.test(a)) {
      return "Android";
    } else if (/(BlackBerry|PlayBook|BB10)/i.test(a)) {
      return "BlackBerry";
    } else if (/Mac/i.test(a)) {
      return "Mac OS X";
    } else if (/Linux/.test(a)) {
      return "Linux";
    } else if (/CrOS/.test(a)) {
      return "Chrome OS";
    } else {
      return "";
    }
  },
  device: function device(user_agent) {
    if (/Windows Phone/i.test(user_agent) || /WPDesktop/.test(user_agent)) {
      return "Windows Phone";
    } else if (/iPad/.test(user_agent)) {
      return "iPad";
    } else if (/iPod/.test(user_agent)) {
      return "iPod Touch";
    } else if (/iPhone/.test(user_agent)) {
      return "iPhone";
    } else if (/(BlackBerry|PlayBook|BB10)/i.test(user_agent)) {
      return "BlackBerry";
    } else if (/Android/.test(user_agent) && !/Mobile/.test(user_agent)) {
      return "Android Tablet";
    } else if (/Android/.test(user_agent)) {
      return "Android";
    } else {
      return "";
    }
  },
  deviceType: function deviceType(user_agent) {
    var device2 = this.device(user_agent);
    if (device2 === "iPad" || device2 === "Android Tablet") {
      return "Tablet";
    } else if (device2) {
      return "Mobile";
    } else {
      return "Desktop";
    }
  },
  referringDomain: function referringDomain(referrer) {
    var split2 = referrer.split("/");
    if (split2.length >= 3) {
      return split2[2];
    }
    return "";
  },
  properties: function properties() {
    return _.extend(_.strip_empty_properties({
      $os: _.info.os(),
      $browser: _.info.browser(userAgent$1, navigator$1.vendor, window.opera),
      $device: _.info.device(userAgent$1),
      $device_type: _.info.deviceType(userAgent$1)
    }), {
      $current_url: window.location.href,
      $host: window.location.host,
      $pathname: window.location.pathname,
      $browser_version: _.info.browserVersion(userAgent$1, navigator$1.vendor, window.opera),
      $screen_height: window.screen.height,
      $screen_width: window.screen.width,
      $viewport_height: window.innerHeight,
      $viewport_width: window.innerWidth,
      $lib: "web",
      $lib_version: Config$1.LIB_VERSION,
      $insert_id: Math.random().toString(36).substring(2, 10) + Math.random().toString(36).substring(2, 10),
      $time: _.timestamp() / 1e3
    });
  },
  people_properties: function people_properties() {
    return _.extend(_.strip_empty_properties({
      $os: _.info.os(),
      $browser: _.info.browser(userAgent$1, navigator$1.vendor, window.opera)
    }), {
      $browser_version: _.info.browserVersion(userAgent$1, navigator$1.vendor, window.opera)
    });
  }
};
_["isObject"] = _.isObject;
_["isBlockedUA"] = _.isBlockedUA;
_["isEmptyObject"] = _.isEmptyObject;
_["info"] = _.info;
_["info"]["device"] = _.info.device;
_["info"]["browser"] = _.info.browser;
_["info"]["browserVersion"] = _.info.browserVersion;
_["info"]["properties"] = _.info.properties;
function getClassName(el) {
  switch (_typeof(el.className)) {
    case "string":
      return el.className;
    case "object":
      return el.className.baseVal || el.getAttribute("class") || "";
    default:
      return "";
  }
}
function getSafeText(el) {
  var elText = "";
  if (shouldCaptureElement(el) && !isSensitiveElement(el) && el.childNodes && el.childNodes.length) {
    _.each(el.childNodes, function(child) {
      if (isTextNode(child) && child.textContent) {
        elText += _.trim(child.textContent).split(/(\s+)/).filter(shouldCaptureValue).join("").replace(/[\r\n]/g, " ").replace(/[ ]+/g, " ").substring(0, 255);
      }
    });
  }
  return _.trim(elText);
}
function isElementNode(el) {
  return el && el.nodeType === 1;
}
function isTag(el, tag) {
  return el && el.tagName && el.tagName.toLowerCase() === tag.toLowerCase();
}
function isTextNode(el) {
  return el && el.nodeType === 3;
}
var usefulElements = ["a", "button", "form", "input", "select", "textarea", "label"];
function shouldCaptureDomEvent(el, event) {
  if (!el || isTag(el, "html") || !isElementNode(el)) {
    return false;
  }
  var parentIsUsefulElement = false;
  var targetElementList = [el];
  var parentNode = true;
  var curEl = el;
  while (curEl.parentNode && !isTag(curEl, "body")) {
    if (curEl.parentNode.nodeType === 11) {
      targetElementList.push(curEl.parentNode.host);
      curEl = curEl.parentNode.host;
      continue;
    }
    parentNode = curEl.parentNode;
    if (!parentNode)
      break;
    if (usefulElements.indexOf(parentNode.tagName.toLowerCase()) > -1) {
      parentIsUsefulElement = true;
    } else {
      var _compStyles = window.getComputedStyle(parentNode);
      if (_compStyles && _compStyles.getPropertyValue("cursor") === "pointer") {
        parentIsUsefulElement = true;
      }
    }
    targetElementList.push(parentNode);
    curEl = parentNode;
  }
  var compStyles = window.getComputedStyle(el);
  if (compStyles && compStyles.getPropertyValue("cursor") === "pointer" && event.type === "click") {
    return true;
  }
  var tag = el.tagName.toLowerCase();
  switch (tag) {
    case "html":
      return false;
    case "form":
      return event.type === "submit";
    case "input":
      return event.type === "change" || event.type === "click";
    case "select":
    case "textarea":
      return event.type === "change" || event.type === "click";
    default:
      if (parentIsUsefulElement)
        return event.type === "click";
      return event.type === "click" && (usefulElements.indexOf(tag) > -1 || el.getAttribute("contenteditable") === "true");
  }
}
function shouldCaptureElement(el) {
  for (var curEl = el; curEl.parentNode && !isTag(curEl, "body"); curEl = curEl.parentNode) {
    var classes = getClassName(curEl).split(" ");
    if (_.includes(classes, "ph-sensitive") || _.includes(classes, "ph-no-capture")) {
      return false;
    }
  }
  if (_.includes(getClassName(el).split(" "), "ph-include")) {
    return true;
  }
  var type = el.type || "";
  if (typeof type === "string") {
    switch (type.toLowerCase()) {
      case "hidden":
        return false;
      case "password":
        return false;
    }
  }
  var name = el.name || el.id || "";
  if (typeof name === "string") {
    var sensitiveNameRegex = /^cc|cardnum|ccnum|creditcard|csc|cvc|cvv|exp|pass|pwd|routing|seccode|securitycode|securitynum|socialsec|socsec|ssn/i;
    if (sensitiveNameRegex.test(name.replace(/[^a-zA-Z0-9]/g, ""))) {
      return false;
    }
  }
  return true;
}
function isSensitiveElement(el) {
  var allowedInputTypes = ["button", "checkbox", "submit", "reset"];
  if (isTag(el, "input") && !allowedInputTypes.includes(el.type) || isTag(el, "select") || isTag(el, "textarea") || el.getAttribute("contenteditable") === "true") {
    return true;
  }
  return false;
}
function shouldCaptureValue(value) {
  if (value === null || _.isUndefined(value)) {
    return false;
  }
  if (typeof value === "string") {
    value = _.trim(value);
    var ccRegex = /^(?:(4[0-9]{12}(?:[0-9]{3})?)|(5[1-5][0-9]{14})|(6(?:011|5[0-9]{2})[0-9]{12})|(3[47][0-9]{13})|(3(?:0[0-5]|[68][0-9])[0-9]{11})|((?:2131|1800|35[0-9]{3})[0-9]{11}))$/;
    if (ccRegex.test((value || "").replace(/[- ]/g, ""))) {
      return false;
    }
    var ssnRegex = /(^\d{3}-?\d{2}-?\d{4}$)/;
    if (ssnRegex.test(value)) {
      return false;
    }
  }
  return true;
}
function isAngularStyleAttr(attributeName) {
  if (typeof attributeName === "string") {
    return attributeName.substring(0, 10) === "_ngcontent" || attributeName.substring(0, 7) === "_nghost";
  }
  return false;
}
function loadScript(scriptUrlToLoad, callback) {
  var scriptTag2 = document.createElement("script");
  scriptTag2.type = "text/javascript";
  scriptTag2.src = scriptUrlToLoad;
  scriptTag2.onload = callback;
  var scripts = document.getElementsByTagName("script");
  if (scripts.length > 0) {
    scripts[0].parentNode.insertBefore(scriptTag2, scripts[0]);
  } else {
    document.body.appendChild(scriptTag2);
  }
}
var RAGE_CLICK_THRESHOLD_PX = 30;
var RAGE_CLICK_TIMEOUT_MS = 1e3;
var RAGE_CLICK_CLICK_COUNT = 3;
var RageClick = /* @__PURE__ */ function() {
  function RageClick2(instance) {
    var enabled = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : instance.get_config("rageclick");
    _classCallCheck(this, RageClick2);
    this.clicks = [];
    this.instance = instance;
    this.enabled = enabled;
  }
  _createClass(RageClick2, [{
    key: "click",
    value: function click(x2, y2, timestamp) {
      if (!this.enabled) {
        return;
      }
      var lastClick = this.clicks[this.clicks.length - 1];
      if (lastClick && Math.abs(x2 - lastClick.x) + Math.abs(y2 - lastClick.y) < RAGE_CLICK_THRESHOLD_PX && timestamp - lastClick.timestamp < RAGE_CLICK_TIMEOUT_MS) {
        this.clicks.push({
          x: x2,
          y: y2,
          timestamp
        });
        if (this.clicks.length === RAGE_CLICK_CLICK_COUNT) {
          this.instance.capture("$rageclick");
        }
      } else {
        this.clicks = [{
          x: x2,
          y: y2,
          timestamp
        }];
      }
    }
  }]);
  return RageClick2;
}();
var autocapture = {
  _initializedTokens: [],
  _previousElementSibling: function _previousElementSibling(el) {
    if (el.previousElementSibling) {
      return el.previousElementSibling;
    } else {
      do {
        el = el.previousSibling;
      } while (el && !isElementNode(el));
      return el;
    }
  },
  _getPropertiesFromElement: function _getPropertiesFromElement(elem, maskInputs, maskText) {
    var tag_name = elem.tagName.toLowerCase();
    var props = {
      tag_name
    };
    if (usefulElements.indexOf(tag_name) > -1 && !maskText) {
      props["$el_text"] = getSafeText(elem);
    }
    var classes = getClassName(elem);
    if (classes.length > 0)
      props["classes"] = classes.split(" ").filter(function(c) {
        return c !== "";
      });
    _.each(elem.attributes, function(attr) {
      if (isSensitiveElement(elem) && ["name", "id", "class"].indexOf(attr.name) === -1)
        return;
      if (!maskInputs && shouldCaptureValue(attr.value) && !isAngularStyleAttr(attr.name)) {
        props["attr__" + attr.name] = attr.value;
      }
    });
    var nthChild = 1;
    var nthOfType = 1;
    var currentElem = elem;
    while (currentElem = this._previousElementSibling(currentElem)) {
      nthChild++;
      if (currentElem.tagName === elem.tagName) {
        nthOfType++;
      }
    }
    props["nth_child"] = nthChild;
    props["nth_of_type"] = nthOfType;
    return props;
  },
  _getDefaultProperties: function _getDefaultProperties(eventType) {
    return {
      $event_type: eventType,
      $ce_version: 1
    };
  },
  _extractCustomPropertyValue: function _extractCustomPropertyValue(customProperty) {
    var propValues = [];
    _.each(document.querySelectorAll(customProperty["css_selector"]), function(matchedElem) {
      var value;
      if (["input", "select"].indexOf(matchedElem.tagName.toLowerCase()) > -1) {
        value = matchedElem["value"];
      } else if (matchedElem["textContent"]) {
        value = matchedElem["textContent"];
      }
      if (shouldCaptureValue(value)) {
        propValues.push(value);
      }
    });
    return propValues.join(", ");
  },
  _getCustomProperties: function _getCustomProperties(targetElementList) {
    var props = {};
    _.each(this._customProperties, function(customProperty) {
      _.each(customProperty["event_selectors"], function(eventSelector) {
        var eventElements = document.querySelectorAll(eventSelector);
        _.each(eventElements, function(eventElement) {
          if (_.includes(targetElementList, eventElement) && shouldCaptureElement(eventElement)) {
            props[customProperty["name"]] = this._extractCustomPropertyValue(customProperty);
          }
        }, this);
      }, this);
    }, this);
    return props;
  },
  _getEventTarget: function _getEventTarget(e) {
    if (typeof e.target === "undefined") {
      return e.srcElement;
    } else {
      if (e.target.shadowRoot) {
        return e.composedPath()[0];
      }
      return e.target;
    }
  },
  _captureEvent: function _captureEvent(e, instance) {
    var target = this._getEventTarget(e);
    if (isTextNode(target)) {
      target = target.parentNode;
    }
    if (e.type === "click") {
      this.rageclicks.click(e.clientX, e.clientY, new Date().getTime());
    }
    if (shouldCaptureDomEvent(target, e)) {
      var targetElementList = [target];
      var curEl = target;
      while (curEl.parentNode && !isTag(curEl, "body")) {
        if (curEl.parentNode.nodeType === 11) {
          targetElementList.push(curEl.parentNode.host);
          curEl = curEl.parentNode.host;
          continue;
        }
        targetElementList.push(curEl.parentNode);
        curEl = curEl.parentNode;
      }
      var elementsJson = [];
      var href, explicitNoCapture = false;
      _.each(targetElementList, function(el) {
        var shouldCaptureEl = shouldCaptureElement(el);
        if (el.tagName.toLowerCase() === "a") {
          href = el.getAttribute("href");
          href = shouldCaptureEl && shouldCaptureValue(href) && href;
        }
        var classes = getClassName(el).split(" ");
        if (_.includes(classes, "ph-no-capture")) {
          explicitNoCapture = true;
        }
        elementsJson.push(this._getPropertiesFromElement(el, instance.get_config("mask_all_element_attributes"), instance.get_config("mask_all_text")));
      }, this);
      if (!instance.get_config("mask_all_text")) {
        elementsJson[0]["$el_text"] = getSafeText(target);
      }
      if (href) {
        elementsJson[0]["attr__href"] = href;
      }
      if (explicitNoCapture) {
        return false;
      }
      var props = _.extend(this._getDefaultProperties(e.type), {
        $elements: elementsJson
      }, this._getCustomProperties(targetElementList));
      instance.capture("$autocapture", props);
      return true;
    }
  },
  _navigate: function _navigate(href) {
    window.location.href = href;
  },
  _addDomEventHandlers: function _addDomEventHandlers(instance) {
    var handler = _.bind(function(e) {
      e = e || window.event;
      this._captureEvent(e, instance);
    }, this);
    _.register_event(document, "submit", handler, false, true);
    _.register_event(document, "change", handler, false, true);
    _.register_event(document, "click", handler, false, true);
  },
  _customProperties: {},
  init: function init(instance) {
    this.rageclicks = new RageClick(instance);
  },
  afterDecideResponse: function afterDecideResponse(response, instance) {
    var token = instance.get_config("token");
    if (this._initializedTokens.indexOf(token) > -1) {
      logger.log('autocapture already initialized for token "' + token + '"');
      return;
    }
    this._initializedTokens.push(token);
    if (response && response["config"] && response["config"]["enable_collect_everything"] === true && instance.get_config("autocapture")) {
      if (response["custom_properties"]) {
        this._customProperties = response["custom_properties"];
      }
      this._addDomEventHandlers(instance);
    } else {
      instance["__autocapture_enabled"] = false;
    }
  },
  enabledForProject: function enabledForProject(token, numBuckets, numEnabledBuckets) {
    numBuckets = !_.isUndefined(numBuckets) ? numBuckets : 10;
    numEnabledBuckets = !_.isUndefined(numEnabledBuckets) ? numEnabledBuckets : 10;
    var charCodeSum = 0;
    for (var i2 = 0; i2 < token.length; i2++) {
      charCodeSum += token.charCodeAt(i2);
    }
    return charCodeSum % numBuckets < numEnabledBuckets;
  },
  isBrowserSupported: function isBrowserSupported() {
    return _.isFunction(document.querySelectorAll);
  }
};
_.bind_instance_methods(autocapture);
_.safewrap_instance_methods(autocapture);
var DOMAIN_MATCH_REGEX = /[a-z0-9][a-z0-9-]+\.[a-z.]{2,6}$/i;
var cookieStore = {
  get: function get2(name) {
    try {
      var nameEQ = name + "=";
      var ca = document.cookie.split(";");
      for (var i2 = 0; i2 < ca.length; i2++) {
        var c = ca[i2];
        while (c.charAt(0) == " ") {
          c = c.substring(1, c.length);
        }
        if (c.indexOf(nameEQ) === 0) {
          return decodeURIComponent(c.substring(nameEQ.length, c.length));
        }
      }
    } catch (err) {
    }
    return null;
  },
  parse: function parse2(name) {
    var cookie;
    try {
      cookie = JSON.parse(cookieStore.get(name)) || {};
    } catch (err) {
    }
    return cookie;
  },
  set: function set2(name, value, days, cross_subdomain, is_secure) {
    try {
      var cdomain = "", expires = "", secure = "";
      if (cross_subdomain) {
        var matches2 = document.location.hostname.match(DOMAIN_MATCH_REGEX), domain = matches2 ? matches2[0] : "";
        cdomain = domain ? "; domain=." + domain : "";
      }
      if (days) {
        var date = new Date();
        date.setTime(date.getTime() + days * 24 * 60 * 60 * 1e3);
        expires = "; expires=" + date.toGMTString();
      }
      if (is_secure) {
        secure = "; secure";
      }
      var new_cookie_val = name + "=" + encodeURIComponent(JSON.stringify(value)) + expires + "; path=/" + cdomain + secure;
      document.cookie = new_cookie_val;
      return new_cookie_val;
    } catch (err) {
      return;
    }
  },
  remove: function remove(name, cross_subdomain) {
    try {
      cookieStore.set(name, "", -1, cross_subdomain);
    } catch (err) {
      return;
    }
  }
};
var _localStorage_supported = null;
var localStore = {
  is_supported: function is_supported() {
    if (_localStorage_supported !== null) {
      return _localStorage_supported;
    }
    var supported = true;
    if (window) {
      try {
        var key = "__mplssupport__", val = "xyz";
        localStore.set(key, val);
        if (localStore.get(key) !== '"xyz"') {
          supported = false;
        }
        localStore.remove(key);
      } catch (err) {
        supported = false;
      }
    } else {
      supported = false;
    }
    if (!supported) {
      logger.error("localStorage unsupported; falling back to cookie store");
    }
    _localStorage_supported = supported;
    return supported;
  },
  error: function error3(msg) {
    logger.error("localStorage error: " + msg);
  },
  get: function get3(name) {
    try {
      return window.localStorage.getItem(name);
    } catch (err) {
      localStore.error(err);
    }
    return null;
  },
  parse: function parse3(name) {
    try {
      return JSON.parse(localStore.get(name)) || {};
    } catch (err) {
    }
    return null;
  },
  set: function set3(name, value) {
    try {
      window.localStorage.setItem(name, JSON.stringify(value));
    } catch (err) {
      localStore.error(err);
    }
  },
  remove: function remove2(name) {
    try {
      window.localStorage.removeItem(name);
    } catch (err) {
      localStore.error(err);
    }
  }
};
var localPlusCookieStore = _objectSpread2(_objectSpread2({}, localStore), {}, {
  parse: function parse4(name) {
    try {
      var extend = {};
      try {
        extend = cookieStore.parse(name) || {};
        if (extend["distinct_id"]) {
          cookieStore.set(name, {
            distinct_id: extend["distinct_id"]
          });
        }
      } catch (err) {
      }
      var value = _.extend(extend, JSON.parse(localStore.get(name) || "{}"));
      localStore.set(name, value);
      return value;
    } catch (err) {
    }
    return null;
  },
  set: function set4(name, value) {
    try {
      localStore.set(name, value);
      if (value.distinct_id) {
        cookieStore.set(name, {
          distinct_id: value.distinct_id
        });
      }
    } catch (err) {
      localStore.error(err);
    }
  },
  remove: function remove3(name) {
    try {
      window.localStorage.removeItem(name);
      cookieStore.remove(name);
    } catch (err) {
      localStore.error(err);
    }
  }
});
var memoryStorage = {};
var memoryStore = {
  is_supported: function is_supported2() {
    return true;
  },
  error: function error4(msg) {
    logger.error("memoryStorage error: " + msg);
  },
  parse: function parse5(name) {
    return memoryStorage[name] || null;
  },
  set: function set5(name, value) {
    memoryStorage[name] = value;
  },
  remove: function remove4(name) {
    delete memoryStorage[name];
  }
};
var sessionStore = {
  sessionStorageSupported: null,
  is_supported: function is_supported3() {
    if (sessionStore.sessionStorageSupported !== null) {
      return sessionStore.sessionStorageSupported;
    }
    sessionStore.sessionStorageSupported = true;
    if (window) {
      try {
        var key = "__support__", val = "xyz";
        sessionStore.set(key, val);
        if (sessionStore.get(key) !== '"xyz"') {
          sessionStore.sessionStorageSupported = false;
        }
        sessionStore.remove(key);
      } catch (err) {
        sessionStore.sessionStorageSupported = false;
      }
    } else {
      sessionStore.sessionStorageSupported = false;
    }
    return sessionStore.sessionStorageSupported;
  },
  error: function error5(msg) {
    if (Config.DEBUG) {
      logger.error("sessionStorage error: ", msg);
    }
  },
  get: function get4(name) {
    try {
      return window.sessionStorage.getItem(name);
    } catch (err) {
      sessionStore.error(err);
    }
    return null;
  },
  parse: function parse6(name) {
    try {
      return JSON.parse(sessionStore.get(name)) || null;
    } catch (err) {
    }
    return null;
  },
  set: function set6(name, value) {
    try {
      window.sessionStorage.setItem(name, JSON.stringify(value));
    } catch (err) {
      sessionStore.error(err);
    }
  },
  remove: function remove5(name) {
    try {
      window.sessionStorage.removeItem(name);
    } catch (err) {
      sessionStore.error(err);
    }
  }
};
var GDPR_DEFAULT_PERSISTENCE_PREFIX = "__ph_opt_in_out_";
function optIn(token, options) {
  _optInOut(true, token, options);
}
function optOut(token, options) {
  _optInOut(false, token, options);
}
function hasOptedIn(token, options) {
  return _getStorageValue(token, options) === "1";
}
function hasOptedOut(token, options) {
  if (_hasDoNotTrackFlagOn(options)) {
    return true;
  }
  return _getStorageValue(token, options) === "0";
}
function addOptOutCheckPostHogLib(method, silenceErrors) {
  return _addOptOutCheck(method, function(name) {
    return this.get_config(name);
  }, silenceErrors);
}
function addOptOutCheckPostHogPeople(method, silenceErrors) {
  return _addOptOutCheck(method, function(name) {
    return this._get_config(name);
  }, silenceErrors);
}
function clearOptInOut(token, options) {
  options = options || {};
  _getStorage(options).remove(_getStorageKey(token, options), !!options.crossSubdomainCookie, options.cookieDomain);
}
function _getStorage(options) {
  options = options || {};
  if (options.persistenceType === "localStorage") {
    return localStore;
  }
  if (options.persistenceType === "localStorage+cookie") {
    return localPlusCookieStore;
  }
  return cookieStore;
}
function _getStorageKey(token, options) {
  options = options || {};
  return (options.persistencePrefix || GDPR_DEFAULT_PERSISTENCE_PREFIX) + token;
}
function _getStorageValue(token, options) {
  return _getStorage(options).get(_getStorageKey(token, options));
}
function _hasDoNotTrackFlagOn(options) {
  if (options && options.respectDnt) {
    var win$1 = options && options.window || win;
    var nav = win$1["navigator"] || {};
    var hasDntOn = false;
    _.each([
      nav["doNotTrack"],
      nav["msDoNotTrack"],
      win$1["doNotTrack"]
    ], function(dntValue) {
      if (_.includes([true, 1, "1", "yes"], dntValue)) {
        hasDntOn = true;
      }
    });
    return hasDntOn;
  }
  return false;
}
function _optInOut(optValue, token, options) {
  if (!_.isString(token) || !token.length) {
    console.error("gdpr." + (optValue ? "optIn" : "optOut") + " called with an invalid token");
    return;
  }
  options = options || {};
  _getStorage(options).set(_getStorageKey(token, options), optValue ? 1 : 0, _.isNumber(options.cookieExpiration) ? options.cookieExpiration : null, !!options.crossSubdomainCookie, !!options.secureCookie, !!options.crossSiteCookie, options.cookieDomain);
  if (options.capture && optValue) {
    options.capture(options.captureEventName || "$opt_in", options.captureProperties, {
      send_immediately: true
    });
  }
}
function _addOptOutCheck(method, getConfigValue, silenceErrors) {
  return function() {
    var optedOut = false;
    try {
      var token = getConfigValue.call(this, "token");
      var respectDnt = getConfigValue.call(this, "respect_dnt");
      var persistenceType = getConfigValue.call(this, "opt_out_capturing_persistence_type");
      var persistencePrefix = getConfigValue.call(this, "opt_out_capturing_cookie_prefix");
      var win2 = getConfigValue.call(this, "window");
      if (token) {
        optedOut = hasOptedOut(token, {
          respectDnt,
          persistenceType,
          persistencePrefix,
          window: win2
        });
      }
    } catch (err) {
      if (!silenceErrors) {
        console.error("Unexpected error when checking capturing opt-out status: " + err);
      }
    }
    if (!optedOut) {
      return method.apply(this, arguments);
    }
    var callback = arguments[arguments.length - 1];
    if (typeof callback === "function") {
      callback(0);
    }
    return;
  };
}
var SET_ACTION = "$set";
var SET_ONCE_ACTION = "$set_once";
var apiActions = {
  set_action: function set_action(prop, to) {
    return this.apiActionParser(SET_ACTION, prop, to);
  },
  set_once_action: function set_once_action(prop, to) {
    return this.apiActionParser(SET_ONCE_ACTION, prop, to);
  },
  apiActionParser: function apiActionParser(actionType, prop, to) {
    var data2 = {};
    var props = {};
    if (_.isObject(prop)) {
      _.each(prop, function(v, k) {
        if (!this._is_reserved_property(k)) {
          props[k] = v;
        }
      }, this);
    } else {
      props[prop] = to;
    }
    data2[actionType] = props;
    return data2;
  }
};
var PostHogPeople = function PostHogPeople2() {
};
_.extend(PostHogPeople.prototype, apiActions);
PostHogPeople.prototype._init = function(posthog_instance) {
  this._posthog = posthog_instance;
};
PostHogPeople.prototype.set = addOptOutCheckPostHogPeople(function(prop, to, callback) {
  var data2 = this.set_action(prop, to);
  if (_.isObject(prop)) {
    callback = to;
  }
  if (this._get_config("save_referrer")) {
    this._posthog["persistence"].update_referrer_info(document.referrer);
  }
  data2[SET_ACTION] = _.extend({}, _.info.people_properties(), this._posthog["persistence"].get_referrer_info(), data2[SET_ACTION]);
  return this._send_request(data2, callback);
});
PostHogPeople.prototype.set_once = addOptOutCheckPostHogPeople(function(prop, to, callback) {
  var data2 = this.set_once_action(prop, to);
  if (_.isObject(prop)) {
    callback = to;
  }
  return this._send_request(data2, callback);
});
PostHogPeople.prototype.toString = function() {
  return this._posthog.toString() + ".people";
};
PostHogPeople.prototype._send_request = function(data2, callback) {
  data2["$token"] = this._get_config("token");
  data2["$distinct_id"] = this._posthog.get_distinct_id();
  var device_id = this._posthog.get_property("$device_id");
  var user_id = this._posthog.get_property("$user_id");
  var had_persisted_distinct_id = this._posthog.get_property("$had_persisted_distinct_id");
  if (device_id) {
    data2["$device_id"] = device_id;
  }
  if (user_id) {
    data2["$user_id"] = user_id;
  }
  if (had_persisted_distinct_id) {
    data2["$had_persisted_distinct_id"] = had_persisted_distinct_id;
  }
  var date_encoded_data = _.encodeDates(data2);
  var truncated_data = _.copyAndTruncateStrings(date_encoded_data, this._get_config("properties_string_max_length"));
  var json_data = JSON.stringify(date_encoded_data);
  var encoded_data = _.base64Encode(json_data);
  this._posthog._send_request(this._get_config("api_host") + "/engage/", {
    data: encoded_data
  }, {}, this._posthog._prepare_callback(callback, truncated_data));
  return truncated_data;
};
PostHogPeople.prototype._get_config = function(conf_var) {
  return this._posthog.get_config(conf_var);
};
PostHogPeople.prototype._is_reserved_property = function(prop) {
  return prop === "$distinct_id" || prop === "$token" || prop === "$device_id" || prop === "$user_id" || prop === "$had_persisted_distinct_id";
};
PostHogPeople.prototype["set"] = PostHogPeople.prototype.set;
PostHogPeople.prototype["set_once"] = PostHogPeople.prototype.set_once;
PostHogPeople.prototype["toString"] = PostHogPeople.prototype.toString;
var parseFeatureFlagDecideResponse = function parseFeatureFlagDecideResponse2(response, persistence) {
  var flags = response["featureFlags"];
  if (flags) {
    if (Array.isArray(flags)) {
      var $enabled_feature_flags = {};
      if (flags) {
        for (var i2 = 0; i2 < flags.length; i2++) {
          $enabled_feature_flags[flags[i2]] = true;
        }
      }
      persistence && persistence.register({
        $active_feature_flags: flags,
        $enabled_feature_flags
      });
    } else {
      persistence && persistence.register({
        $active_feature_flags: Object.keys(flags || {}),
        $enabled_feature_flags: flags || {}
      });
    }
  } else {
    if (persistence) {
      persistence.unregister("$active_feature_flags");
      persistence.unregister("$enabled_feature_flags");
    }
  }
};
var PostHogFeatureFlags = /* @__PURE__ */ function() {
  function PostHogFeatureFlags2(instance) {
    _classCallCheck(this, PostHogFeatureFlags2);
    this.instance = instance;
    this._override_warning = false;
    this.flagCallReported = {};
    this.featureFlagEventHandlers = [];
    this.reloadFeatureFlagsQueued = false;
    this.reloadFeatureFlagsInAction = false;
  }
  _createClass(PostHogFeatureFlags2, [{
    key: "getFlags",
    value: function getFlags() {
      return Object.keys(this.getFlagVariants());
    }
  }, {
    key: "getFlagVariants",
    value: function getFlagVariants() {
      var enabledFlags = this.instance.get_property("$enabled_feature_flags");
      var overriddenFlags = this.instance.get_property("$override_feature_flags");
      if (!overriddenFlags) {
        return enabledFlags || {};
      }
      var finalFlags = _.extend({}, enabledFlags);
      var overriddenKeys = Object.keys(overriddenFlags);
      for (var i2 = 0; i2 < overriddenKeys.length; i2++) {
        if (overriddenFlags[overriddenKeys[i2]] === false) {
          delete finalFlags[overriddenKeys[i2]];
        } else {
          finalFlags[overriddenKeys[i2]] = overriddenFlags[overriddenKeys[i2]];
        }
      }
      if (!this._override_warning) {
        console.warn("[PostHog] Overriding feature flags!", {
          enabledFlags,
          overriddenFlags,
          finalFlags
        });
        this._override_warning = true;
      }
      return finalFlags;
    }
  }, {
    key: "reloadFeatureFlags",
    value: function reloadFeatureFlags() {
      if (!this.reloadFeatureFlagsQueued) {
        this.reloadFeatureFlagsQueued = true;
        this._startReloadTimer();
      }
    }
  }, {
    key: "setAnonymousDistinctId",
    value: function setAnonymousDistinctId(anon_distinct_id) {
      this.$anon_distinct_id = anon_distinct_id;
    }
  }, {
    key: "setReloadingPaused",
    value: function setReloadingPaused(isPaused) {
      this.reloadFeatureFlagsInAction = isPaused;
    }
  }, {
    key: "resetRequestQueue",
    value: function resetRequestQueue() {
      this.reloadFeatureFlagsQueued = false;
    }
  }, {
    key: "_startReloadTimer",
    value: function _startReloadTimer() {
      var _this = this;
      if (this.reloadFeatureFlagsQueued && !this.reloadFeatureFlagsInAction) {
        setTimeout(function() {
          if (!_this.reloadFeatureFlagsInAction && _this.reloadFeatureFlagsQueued) {
            _this.reloadFeatureFlagsQueued = false;
            _this._reloadFeatureFlagsRequest();
          }
        }, 5);
      }
    }
  }, {
    key: "_reloadFeatureFlagsRequest",
    value: function _reloadFeatureFlagsRequest() {
      var _this2 = this;
      this.setReloadingPaused(true);
      var token = this.instance.get_config("token");
      var json_data = JSON.stringify({
        token,
        distinct_id: this.instance.get_distinct_id(),
        groups: this.instance.getGroups(),
        $anon_distinct_id: this.$anon_distinct_id
      });
      var encoded_data = _.base64Encode(json_data);
      this.instance._send_request(this.instance.get_config("api_host") + "/decide/?v=2", {
        data: encoded_data
      }, {
        method: "POST"
      }, this.instance._prepare_callback(function(response) {
        _this2.$anon_distinct_id = void 0;
        _this2.receivedFeatureFlags(response);
        _this2.setReloadingPaused(false);
        _this2._startReloadTimer();
      }));
    }
  }, {
    key: "getFeatureFlag",
    value: function getFeatureFlag(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.getFlags()) {
        console.warn('getFeatureFlag for key "' + key + `" failed. Feature flags didn't load in time.`);
        return false;
      }
      var flagValue = this.getFlagVariants()[key];
      if ((options.send_event || !("send_event" in options)) && !this.flagCallReported[key]) {
        this.flagCallReported[key] = true;
        this.instance.capture("$feature_flag_called", {
          $feature_flag: key,
          $feature_flag_response: flagValue
        });
      }
      return flagValue;
    }
  }, {
    key: "isFeatureEnabled",
    value: function isFeatureEnabled(key) {
      var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      if (!this.getFlags()) {
        console.warn('isFeatureEnabled for key "' + key + `" failed. Feature flags didn't load in time.`);
        return false;
      }
      return !!this.getFeatureFlag(key, options);
    }
  }, {
    key: "addFeatureFlagsHandler",
    value: function addFeatureFlagsHandler(handler) {
      this.featureFlagEventHandlers.push(handler);
    }
  }, {
    key: "receivedFeatureFlags",
    value: function receivedFeatureFlags(response) {
      parseFeatureFlagDecideResponse(response, this.instance.persistence);
      var flags = this.getFlags();
      var variants = this.getFlagVariants();
      this.featureFlagEventHandlers.forEach(function(handler) {
        return handler(flags, variants);
      });
    }
  }, {
    key: "override",
    value: function override(flags) {
      this._override_warning = false;
      if (flags === false) {
        this.instance.persistence.unregister("$override_feature_flags");
      } else if (Array.isArray(flags)) {
        var flagsObj = {};
        for (var i2 = 0; i2 < flags.length; i2++) {
          flagsObj[flags[i2]] = true;
        }
        this.instance.persistence.register({
          $override_feature_flags: flagsObj
        });
      } else {
        this.instance.persistence.register({
          $override_feature_flags: flags
        });
      }
    }
  }, {
    key: "onFeatureFlags",
    value: function onFeatureFlags(callback) {
      this.addFeatureFlagsHandler(callback);
      if (this.instance.decideEndpointWasHit) {
        var flags = this.getFlags();
        var flagVariants = this.getFlagVariants();
        callback(flags, flagVariants);
      }
    }
  }]);
  return PostHogFeatureFlags2;
}();
var SET_QUEUE_KEY = "__mps";
var SET_ONCE_QUEUE_KEY = "__mpso";
var UNSET_QUEUE_KEY = "__mpus";
var ADD_QUEUE_KEY = "__mpa";
var APPEND_QUEUE_KEY = "__mpap";
var REMOVE_QUEUE_KEY = "__mpr";
var UNION_QUEUE_KEY = "__mpu";
var PEOPLE_DISTINCT_ID_KEY = "$people_distinct_id";
var ALIAS_ID_KEY = "__alias";
var CAMPAIGN_IDS_KEY = "__cmpns";
var EVENT_TIMERS_KEY = "__timers";
var SESSION_RECORDING_ENABLED_SERVER_SIDE = "$session_recording_enabled_server_side";
var SESSION_ID = "$sesid";
var ENABLED_FEATURE_FLAGS = "$enabled_feature_flags";
var RESERVED_PROPERTIES = [SET_QUEUE_KEY, SET_ONCE_QUEUE_KEY, UNSET_QUEUE_KEY, ADD_QUEUE_KEY, APPEND_QUEUE_KEY, REMOVE_QUEUE_KEY, UNION_QUEUE_KEY, PEOPLE_DISTINCT_ID_KEY, ALIAS_ID_KEY, CAMPAIGN_IDS_KEY, EVENT_TIMERS_KEY, SESSION_RECORDING_ENABLED_SERVER_SIDE, SESSION_ID, ENABLED_FEATURE_FLAGS];
var PostHogPersistence = function PostHogPersistence2(config) {
  var token = "";
  if (config["token"]) {
    token = config["token"].replace(/\+/g, "PL").replace(/\//g, "SL").replace(/=/g, "EQ");
  }
  this["props"] = {};
  this.campaign_params_saved = false;
  if (config["persistence_name"]) {
    this.name = "ph_" + config["persistence_name"];
  } else {
    this.name = "ph_" + token + "_posthog";
  }
  var storage_type = config["persistence"].toLowerCase();
  if (storage_type !== "cookie" && storage_type.indexOf("localstorage") === -1 && storage_type !== "memory") {
    logger.critical("Unknown persistence type " + storage_type + "; falling back to cookie");
    storage_type = config["persistence"] = "cookie";
  }
  if (storage_type === "localstorage" && localStore.is_supported()) {
    this.storage = localStore;
  } else if (storage_type === "localstorage+cookie" && localPlusCookieStore.is_supported()) {
    this.storage = localPlusCookieStore;
  } else if (storage_type === "memory") {
    this.storage = memoryStore;
  } else {
    this.storage = cookieStore;
  }
  this.load();
  this.update_config(config);
  this.save();
};
PostHogPersistence.prototype.properties = function() {
  var p = {};
  _.each(this["props"], function(v, k) {
    if (k === ENABLED_FEATURE_FLAGS && _typeof(v) === "object") {
      var keys3 = Object.keys(v);
      for (var i2 = 0; i2 < keys3.length; i2++) {
        p["$feature/".concat(keys3[i2])] = v[keys3[i2]];
      }
    } else if (!_.include(RESERVED_PROPERTIES, k)) {
      p[k] = v;
    }
  });
  return p;
};
PostHogPersistence.prototype.load = function() {
  if (this.disabled) {
    return;
  }
  var entry = this.storage.parse(this.name);
  if (entry) {
    this["props"] = _.extend({}, entry);
  }
};
PostHogPersistence.prototype.save = function() {
  if (this.disabled) {
    return;
  }
  this.storage.set(this.name, this["props"], this.expire_days, this.cross_subdomain, this.secure);
};
PostHogPersistence.prototype.remove = function() {
  this.storage.remove(this.name, false);
  this.storage.remove(this.name, true);
};
PostHogPersistence.prototype.clear = function() {
  this.remove();
  this["props"] = {};
};
PostHogPersistence.prototype.register_once = function(props, default_value, days) {
  if (_.isObject(props)) {
    if (typeof default_value === "undefined") {
      default_value = "None";
    }
    this.expire_days = typeof days === "undefined" ? this.default_expiry : days;
    _.each(props, function(val, prop) {
      if (!this["props"].hasOwnProperty(prop) || this["props"][prop] === default_value) {
        this["props"][prop] = val;
      }
    }, this);
    this.save();
    return true;
  }
  return false;
};
PostHogPersistence.prototype.register = function(props, days) {
  if (_.isObject(props)) {
    this.expire_days = typeof days === "undefined" ? this.default_expiry : days;
    _.extend(this["props"], props);
    this.save();
    return true;
  }
  return false;
};
PostHogPersistence.prototype.unregister = function(prop) {
  if (prop in this["props"]) {
    delete this["props"][prop];
    this.save();
  }
};
PostHogPersistence.prototype.update_campaign_params = function() {
  if (!this.campaign_params_saved) {
    this.register(_.info.campaignParams());
    this.campaign_params_saved = true;
  }
};
PostHogPersistence.prototype.update_search_keyword = function(referrer) {
  this.register(_.info.searchInfo(referrer));
};
PostHogPersistence.prototype.update_referrer_info = function(referrer) {
  this.register_once({
    $initial_referrer: referrer || "$direct",
    $initial_referring_domain: _.info.referringDomain(referrer) || "$direct"
  }, "");
  this.register({
    $referrer: referrer || this["props"]["$referrer"] || "$direct",
    $referring_domain: _.info.referringDomain(referrer) || this["props"]["$referring_domain"] || "$direct"
  });
};
PostHogPersistence.prototype.get_referrer_info = function() {
  return _.strip_empty_properties({
    $initial_referrer: this["props"]["$initial_referrer"],
    $initial_referring_domain: this["props"]["$initial_referring_domain"]
  });
};
PostHogPersistence.prototype.safe_merge = function(props) {
  _.each(this["props"], function(val, prop) {
    if (!(prop in props)) {
      props[prop] = val;
    }
  });
  return props;
};
PostHogPersistence.prototype.update_config = function(config) {
  this.default_expiry = this.expire_days = config["cookie_expiration"];
  this.set_disabled(config["disable_persistence"]);
  this.set_cross_subdomain(config["cross_subdomain_cookie"]);
  this.set_secure(config["secure_cookie"]);
};
PostHogPersistence.prototype.set_disabled = function(disabled) {
  this.disabled = disabled;
  if (this.disabled) {
    this.remove();
  } else {
    this.save();
  }
};
PostHogPersistence.prototype.set_cross_subdomain = function(cross_subdomain) {
  if (cross_subdomain !== this.cross_subdomain) {
    this.cross_subdomain = cross_subdomain;
    this.remove();
    this.save();
  }
};
PostHogPersistence.prototype.get_cross_subdomain = function() {
  return this.cross_subdomain;
};
PostHogPersistence.prototype.set_secure = function(secure) {
  if (secure !== this.secure) {
    this.secure = secure ? true : false;
    this.remove();
    this.save();
  }
};
PostHogPersistence.prototype.set_event_timer = function(event_name, timestamp) {
  var timers = this["props"][EVENT_TIMERS_KEY] || {};
  timers[event_name] = timestamp;
  this["props"][EVENT_TIMERS_KEY] = timers;
  this.save();
};
PostHogPersistence.prototype.remove_event_timer = function(event_name) {
  var timers = this["props"][EVENT_TIMERS_KEY] || {};
  var timestamp = timers[event_name];
  if (!_.isUndefined(timestamp)) {
    delete this["props"][EVENT_TIMERS_KEY][event_name];
    this.save();
  }
  return timestamp;
};
var replacementImageURI = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTYiIGhlaWdodD0iMTYiIHZpZXdCb3g9IjAgMCAxNiAxNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHJlY3Qgd2lkdGg9IjE2IiBoZWlnaHQ9IjE2IiBmaWxsPSJibGFjayIvPgo8cGF0aCBkPSJNOCAwSDE2TDAgMTZWOEw4IDBaIiBmaWxsPSIjMkQyRDJEIi8+CjxwYXRoIGQ9Ik0xNiA4VjE2SDhMMTYgOFoiIGZpbGw9IiMyRDJEMkQiLz4KPC9zdmc+Cg==";
function filterDataURLsFromLargeDataObjects(data2) {
  if (data2 && _typeof(data2) === "object") {
    var stringifiedData = JSON.stringify(data2);
    if (stringifiedData.length > 5e6) {
      var dataURIRegex = /data:([\w\/\-\.]+);(\w+),([^)"]*)/gim;
      var matches2 = stringifiedData.matchAll(dataURIRegex);
      var _iterator = _createForOfIteratorHelper(matches2), _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done; ) {
          var match2 = _step.value;
          if (match2[1].toLocaleLowerCase().slice(0, 6) === "image/") {
            stringifiedData = stringifiedData.replace(match2[0], replacementImageURI);
          } else {
            stringifiedData = stringifiedData.replace(match2[0], "");
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }
    return JSON.parse(stringifiedData);
  }
  return data2;
}
var CONSOLE_LOG_PLUGIN_NAME = "rrweb/console@1";
function truncateLargeConsoleLogs(event) {
  var MAX_STRING_SIZE = 2e3;
  var MAX_STRINGS_PER_LOG = 10;
  if (event && _typeof(event) === "object" && event.type === PLUGIN_EVENT_TYPE && _typeof(event.data) === "object" && event.data.plugin === CONSOLE_LOG_PLUGIN_NAME) {
    if (event.data.payload.payload.length > MAX_STRINGS_PER_LOG) {
      event.data.payload.payload = event.data.payload.payload.slice(0, MAX_STRINGS_PER_LOG);
      event.data.payload.payload.push("...[truncated]");
    }
    var updatedPayload = [];
    for (var i2 = 0; i2 < event.data.payload.payload.length; i2++) {
      if (event.data.payload.payload[i2] && event.data.payload.payload[i2].length > MAX_STRING_SIZE) {
        updatedPayload.push(event.data.payload.payload[i2].slice(0, MAX_STRING_SIZE) + "...[truncated]");
      } else {
        updatedPayload.push(event.data.payload.payload[i2]);
      }
    }
    event.data.payload.payload = updatedPayload;
    return event;
  }
  return event;
}
var BASE_ENDPOINT = "/e/";
var FULL_SNAPSHOT_EVENT_TYPE = 2;
var META_EVENT_TYPE = 4;
var INCREMENTAL_SNAPSHOT_EVENT_TYPE = 3;
var PLUGIN_EVENT_TYPE = 6;
var MUTATION_SOURCE_TYPE = 0;
var SessionRecording = /* @__PURE__ */ function() {
  function SessionRecording2(instance) {
    _classCallCheck(this, SessionRecording2);
    this.instance = instance;
    this.captureStarted = false;
    this.snapshots = [];
    this.emit = false;
    this.endpoint = BASE_ENDPOINT;
    this.stopRrweb = null;
    this.windowId = null;
    this.sessionId = null;
    this.receivedDecide = false;
  }
  _createClass(SessionRecording2, [{
    key: "startRecordingIfEnabled",
    value: function startRecordingIfEnabled() {
      if (this.isRecordingEnabled()) {
        this.startCaptureAndTrySendingQueuedSnapshots();
      } else {
        this.stopRecording();
      }
    }
  }, {
    key: "started",
    value: function started() {
      return this.captureStarted;
    }
  }, {
    key: "stopRecording",
    value: function stopRecording() {
      if (this.captureStarted && this.stopRrweb) {
        this.stopRrweb();
        this.stopRrweb = null;
        this.captureStarted = false;
      }
    }
  }, {
    key: "isRecordingEnabled",
    value: function isRecordingEnabled() {
      var enabled_server_side = !!this.instance.get_property(SESSION_RECORDING_ENABLED_SERVER_SIDE);
      var enabled_client_side = !this.instance.get_config("disable_session_recording");
      return enabled_server_side && enabled_client_side;
    }
  }, {
    key: "afterDecideResponse",
    value: function afterDecideResponse2(response) {
      var _response$sessionReco;
      this.receivedDecide = true;
      if (this.instance.persistence) {
        this.instance.persistence.register(_defineProperty({}, SESSION_RECORDING_ENABLED_SERVER_SIDE, !!response["sessionRecording"]));
      }
      if ((_response$sessionReco = response.sessionRecording) !== null && _response$sessionReco !== void 0 && _response$sessionReco.endpoint) {
        var _response$sessionReco2;
        this.endpoint = (_response$sessionReco2 = response.sessionRecording) === null || _response$sessionReco2 === void 0 ? void 0 : _response$sessionReco2.endpoint;
      }
      this.startRecordingIfEnabled();
    }
  }, {
    key: "startCaptureAndTrySendingQueuedSnapshots",
    value: function startCaptureAndTrySendingQueuedSnapshots() {
      var _this = this;
      if (this.receivedDecide) {
        this.emit = true;
        this.snapshots.forEach(function(properties2) {
          return _this._captureSnapshot(properties2);
        });
      }
      this._startCapture();
    }
  }, {
    key: "_startCapture",
    value: function _startCapture() {
      if (typeof Object.assign === "undefined") {
        return;
      }
      if (!this.captureStarted && !this.instance.get_config("disable_session_recording")) {
        this.captureStarted = true;
        loadScript(this.instance.get_config("api_host") + "/static/recorder.js?v=" + Config$1.LIB_VERSION, _.bind(this._onScriptLoaded, this));
      }
    }
  }, {
    key: "_updateWindowAndSessionIds",
    value: function _updateWindowAndSessionIds(event) {
      var _event$data;
      var isNotUserInteraction = event.type === INCREMENTAL_SNAPSHOT_EVENT_TYPE && ((_event$data = event.data) === null || _event$data === void 0 ? void 0 : _event$data.source) === MUTATION_SOURCE_TYPE;
      var _this$instance$sessio = this.instance.sessionManager.checkAndGetSessionAndWindowId(isNotUserInteraction, event.timestamp), windowId = _this$instance$sessio.windowId, sessionId = _this$instance$sessio.sessionId;
      if ((this.windowId !== windowId || this.sessionId !== sessionId) && [FULL_SNAPSHOT_EVENT_TYPE, META_EVENT_TYPE].indexOf(event.type) === -1) {
        this.rrwebRecord.takeFullSnapshot();
      }
      this.windowId = windowId;
      this.sessionId = sessionId;
    }
  }, {
    key: "_onScriptLoaded",
    value: function _onScriptLoaded() {
      var _this2 = this;
      var sessionRecordingOptions = {
        blockClass: "ph-no-capture",
        blockSelector: null,
        ignoreClass: "ph-ignore-input",
        maskAllInputs: true,
        maskInputOptions: {},
        maskInputFn: null,
        slimDOMOptions: {},
        collectFonts: false,
        inlineStylesheet: true
      };
      this.rrwebRecord = window.rrweb ? window.rrweb.record : window.rrwebRecord;
      var userSessionRecordingOptions = this.instance.get_config("session_recording");
      for (var _i = 0, _Object$entries = Object.entries(userSessionRecordingOptions || {}); _i < _Object$entries.length; _i++) {
        var _Object$entries$_i = _slicedToArray(_Object$entries[_i], 2), key = _Object$entries$_i[0], value = _Object$entries$_i[1];
        if (key in sessionRecordingOptions) {
          sessionRecordingOptions[key] = value;
        }
      }
      this.stopRrweb = this.rrwebRecord(_objectSpread2({
        emit: function emit(event) {
          event = truncateLargeConsoleLogs(filterDataURLsFromLargeDataObjects(event));
          _this2._updateWindowAndSessionIds(event);
          var properties2 = {
            $snapshot_data: event,
            $session_id: _this2.sessionId,
            $window_id: _this2.windowId
          };
          _this2.instance._captureMetrics.incr("rrweb-record");
          _this2.instance._captureMetrics.incr("rrweb-record-".concat(event.type));
          if (_this2.emit) {
            _this2._captureSnapshot(properties2);
          } else {
            _this2.snapshots.push(properties2);
          }
        },
        plugins: window.rrwebConsoleRecord && this.instance.get_config("enable_recording_console_log") ? [window.rrwebConsoleRecord.getRecordConsolePlugin()] : []
      }, sessionRecordingOptions));
      this.instance._addCaptureHook(function(eventName) {
        if (eventName === "$pageview") {
          _this2.rrwebRecord.addCustomEvent("$pageview", {
            href: window.location.href
          });
        }
      });
    }
  }, {
    key: "_captureSnapshot",
    value: function _captureSnapshot(properties2) {
      this.instance.capture("$snapshot", properties2, {
        transport: "XHR",
        method: "POST",
        endpoint: this.endpoint,
        _forceCompression: true,
        _noTruncate: true,
        _batchKey: "sessionRecording",
        _metrics: {
          rrweb_full_snapshot: properties2.$snapshot_data.type === FULL_SNAPSHOT_EVENT_TYPE
        }
      });
    }
  }]);
  return SessionRecording2;
}();
var Decide = /* @__PURE__ */ function() {
  function Decide2(instance) {
    _classCallCheck(this, Decide2);
    this.instance = instance;
    this.instance.decideEndpointWasHit = false;
  }
  _createClass(Decide2, [{
    key: "call",
    value: function call2() {
      var _this = this;
      var json_data = JSON.stringify({
        token: this.instance.get_config("token"),
        distinct_id: this.instance.get_distinct_id(),
        groups: this.instance.getGroups()
      });
      var encoded_data = _.base64Encode(json_data);
      this.instance._send_request("".concat(this.instance.get_config("api_host"), "/decide/?v=2"), {
        data: encoded_data,
        verbose: true
      }, {
        method: "POST"
      }, function(response) {
        return _this.parseDecideResponse(response);
      });
    }
  }, {
    key: "parseDecideResponse",
    value: function parseDecideResponse(response) {
      var _this2 = this;
      if ((response === null || response === void 0 ? void 0 : response.status) === 0) {
        console.error("Failed to fetch feature flags from PostHog.");
        return;
      }
      this.instance.decideEndpointWasHit = true;
      if (!(document && document.body)) {
        console.log("document not ready yet, trying again in 500 milliseconds...");
        setTimeout(function() {
          _this2.parseDecideResponse(response);
        }, 500);
        return;
      }
      this.instance.toolbar.afterDecideResponse(response);
      this.instance.sessionRecording.afterDecideResponse(response);
      autocapture.afterDecideResponse(response, this.instance);
      this.instance.featureFlags.receivedFeatureFlags(response);
      if (response["supportedCompression"]) {
        var compression = {};
        var _iterator = _createForOfIteratorHelper(response["supportedCompression"]), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var method = _step.value;
            compression[method] = true;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        this.instance["compression"] = compression;
      } else {
        this.instance["compression"] = {};
      }
    }
  }]);
  return Decide2;
}();
var Toolbar = /* @__PURE__ */ function() {
  function Toolbar2(instance) {
    _classCallCheck(this, Toolbar2);
    this.instance = instance;
  }
  _createClass(Toolbar2, [{
    key: "afterDecideResponse",
    value: function afterDecideResponse2(response) {
      var editorParams = response["editorParams"] || (response["toolbarVersion"] ? {
        toolbarVersion: response["toolbarVersion"]
      } : {});
      if (response["isAuthenticated"] && editorParams["toolbarVersion"] && editorParams["toolbarVersion"].indexOf("toolbar") === 0) {
        this._loadEditor(_objectSpread2(_objectSpread2({}, editorParams), {}, {
          apiURL: this.instance.get_config("api_host")
        }));
      }
    }
  }, {
    key: "maybeLoadEditor",
    value: function maybeLoadEditor() {
      var location2 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : window.location;
      var localStorage2 = arguments.length > 1 ? arguments[1] : void 0;
      var history2 = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : window.history;
      try {
        if (!localStorage2) {
          try {
            window.localStorage.setItem("test", "test");
            window.localStorage.removeItem("test");
          } catch (error6) {
            return false;
          }
          localStorage2 = window.localStorage;
        }
        var stateHash = _.getHashParam(location2.hash, "__posthog") || _.getHashParam(location2.hash, "state");
        var state = stateHash ? JSON.parse(decodeURIComponent(stateHash)) : null;
        var parseFromUrl = state && (state["action"] === "mpeditor" || state["action"] === "ph_authorize");
        var editorParams;
        if (parseFromUrl) {
          editorParams = state;
          if (editorParams && Object.keys(editorParams).length > 0) {
            localStorage2.setItem("_postHogEditorParams", JSON.stringify(editorParams));
            if (state["desiredHash"]) {
              location2.hash = state["desiredHash"];
            } else if (history2) {
              history2.replaceState("", document.title, location2.pathname + location2.search);
            } else {
              location2.hash = "";
            }
          }
        } else {
          editorParams = JSON.parse(localStorage2.getItem("_postHogEditorParams") || "{}");
          delete editorParams.userIntent;
        }
        editorParams["apiURL"] = this.instance.get_config("api_host");
        if (editorParams["token"] && this.instance.get_config("token") === editorParams["token"]) {
          this._loadEditor(editorParams);
          return true;
        } else {
          return false;
        }
      } catch (e) {
        return false;
      }
    }
  }, {
    key: "_loadEditor",
    value: function _loadEditor(editorParams) {
      var _this = this;
      if (!window["_postHogToolbarLoaded"]) {
        window["_postHogToolbarLoaded"] = true;
        var host = editorParams["jsURL"] || editorParams["apiURL"] || this.instance.get_config("api_host");
        var toolbarScript = "toolbar.js";
        var editorUrl = host + (host.endsWith("/") ? "" : "/") + "static/" + toolbarScript + "?_ts=" + new Date().getTime();
        var disableToolbarMetrics = this.instance.get_config("api_host") !== "https://app.posthog.com" && this.instance.get_config("advanced_disable_toolbar_metrics");
        editorParams = _objectSpread2(_objectSpread2({}, editorParams), disableToolbarMetrics ? {
          instrument: false
        } : {});
        loadScript(editorUrl, function() {
          window["ph_load_editor"](editorParams, _this.instance);
        });
        _.register_event(window, "turbolinks:load", function() {
          window["_postHogToolbarLoaded"] = false;
          _this._loadEditor(editorParams);
        });
        return true;
      }
      return false;
    }
  }]);
  return Toolbar2;
}();
var RequestQueueScaffold = /* @__PURE__ */ function() {
  function RequestQueueScaffold2() {
    var pollInterval = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 3e3;
    _classCallCheck(this, RequestQueueScaffold2);
    this.isPolling = true;
    this._event_queue = [];
    this._empty_queue_count = 0;
    this._poller = function() {
    };
    this._pollInterval = pollInterval;
  }
  _createClass(RequestQueueScaffold2, [{
    key: "setPollInterval",
    value: function setPollInterval(interval) {
      this._pollInterval = interval;
      if (this.isPolling) {
        this.poll();
      }
    }
  }, {
    key: "enqueue",
    value: function enqueue() {
      return;
    }
  }, {
    key: "poll",
    value: function poll() {
      return;
    }
  }, {
    key: "unload",
    value: function unload() {
      return;
    }
  }, {
    key: "getTime",
    value: function getTime() {
      return new Date().getTime();
    }
  }]);
  return RequestQueueScaffold2;
}();
var RequestQueue = /* @__PURE__ */ function(_RequestQueueScaffold) {
  _inherits(RequestQueue2, _RequestQueueScaffold);
  var _super = _createSuper(RequestQueue2);
  function RequestQueue2(captureMetrics, handlePollRequest) {
    var _this;
    var pollInterval = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 3e3;
    _classCallCheck(this, RequestQueue2);
    _this = _super.call(this, pollInterval);
    _this.handlePollRequest = handlePollRequest;
    _this.captureMetrics = captureMetrics;
    return _this;
  }
  _createClass(RequestQueue2, [{
    key: "enqueue",
    value: function enqueue(url, data2, options) {
      this.captureMetrics.incr("batch-enqueue");
      this._event_queue.push({
        url,
        data: data2,
        options
      });
      if (!this.isPolling) {
        this.isPolling = true;
        this.poll();
      }
    }
  }, {
    key: "poll",
    value: function poll() {
      var _this2 = this;
      clearTimeout(this._poller);
      this._poller = setTimeout(function() {
        if (_this2._event_queue.length > 0) {
          var requests = _this2.formatQueue();
          var _loop = function _loop2(key2) {
            var _requests$key = requests[key2], url = _requests$key.url, data2 = _requests$key.data, options = _requests$key.options;
            _.each(data2, function(_2, dataKey) {
              data2[dataKey]["offset"] = Math.abs(data2[dataKey]["timestamp"] - _this2.getTime());
              delete data2[dataKey]["timestamp"];
            });
            _this2.handlePollRequest(url, data2, options);
            _this2.captureMetrics.incr("batch-requests");
            _this2.captureMetrics.incr("batch-requests-".concat(url.slice(url.length - 2)));
            _this2.captureMetrics.incr("batch-handle", data2.length);
            _this2.captureMetrics.incr("batch-handle-".concat(url.slice(url.length - 2)), data2.length);
          };
          for (var key in requests) {
            _loop(key);
          }
          _this2._event_queue.length = 0;
          _this2._empty_queue_count = 0;
        } else {
          _this2._empty_queue_count++;
        }
        if (_this2._empty_queue_count > 4) {
          _this2.isPolling = false;
          _this2._empty_queue_count = 0;
        }
        if (_this2.isPolling) {
          _this2.poll();
        }
      }, this._pollInterval);
    }
  }, {
    key: "updateUnloadMetrics",
    value: function updateUnloadMetrics() {
      var requests = this.formatQueue();
      for (var key in requests) {
        var _requests$key2 = requests[key], url = _requests$key2.url, data2 = _requests$key2.data;
        this.captureMetrics.incr("batch-unload-requests");
        this.captureMetrics.incr("batch-unload-requests-".concat(url.slice(url.length - 2)));
        this.captureMetrics.incr("batch-unload", data2.length);
        this.captureMetrics.incr("batch-unload-".concat(url.slice(url.length - 2)), data2.length);
      }
    }
  }, {
    key: "unload",
    value: function unload() {
      clearTimeout(this._poller);
      var requests = this._event_queue.length > 0 ? this.formatQueue() : {};
      this._event_queue.length = 0;
      for (var key in requests) {
        var _requests$key3 = requests[key], url = _requests$key3.url, data2 = _requests$key3.data, options = _requests$key3.options;
        this.handlePollRequest(url, data2, _objectSpread2(_objectSpread2({}, options), {}, {
          transport: "sendbeacon"
        }));
      }
    }
  }, {
    key: "formatQueue",
    value: function formatQueue() {
      var requests = {};
      _.each(this._event_queue, function(request) {
        var url = request.url, data2 = request.data, options = request.options;
        var key = (options ? options._batchKey : null) || url;
        if (requests[key] === void 0) {
          requests[key] = {
            data: [],
            url,
            options
          };
        }
        if (options && requests[key].options && requests[key].options._metrics && !requests[key].options._metrics["rrweb_full_snapshot"]) {
          requests[key].options._metrics["rrweb_full_snapshot"] = options._metrics["rrweb_full_snapshot"];
        }
        requests[key].data.push(data2);
      });
      return requests;
    }
  }]);
  return RequestQueue2;
}(RequestQueueScaffold);
var CaptureMetrics = /* @__PURE__ */ function() {
  function CaptureMetrics2(enabled) {
    _classCallCheck(this, CaptureMetrics2);
    this.enabled = enabled;
    this.metrics = {};
  }
  _createClass(CaptureMetrics2, [{
    key: "incr",
    value: function incr(key) {
      var by = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 1;
      if (this.enabled) {
        key = "phjs-".concat(key);
        this.metrics[key] = (this.metrics[key] || 0) + by;
      }
    }
  }, {
    key: "decr",
    value: function decr(key) {
      if (this.enabled) {
        key = "phjs-".concat(key);
        this.metrics[key] = (this.metrics[key] || 0) - 1;
      }
    }
  }]);
  return CaptureMetrics2;
}();
var u8 = Uint8Array, u16 = Uint16Array, u32 = Uint32Array;
var fleb = new u8([
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  0,
  1,
  1,
  1,
  1,
  2,
  2,
  2,
  2,
  3,
  3,
  3,
  3,
  4,
  4,
  4,
  4,
  5,
  5,
  5,
  5,
  0,
  0,
  0,
  0
]);
var fdeb = new u8([
  0,
  0,
  0,
  0,
  1,
  1,
  2,
  2,
  3,
  3,
  4,
  4,
  5,
  5,
  6,
  6,
  7,
  7,
  8,
  8,
  9,
  9,
  10,
  10,
  11,
  11,
  12,
  12,
  13,
  13,
  0,
  0
]);
var clim = new u8([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);
var freb = function freb2(eb, start) {
  var b = new u16(31);
  for (var i2 = 0; i2 < 31; ++i2) {
    b[i2] = start += 1 << eb[i2 - 1];
  }
  var r = new u32(b[30]);
  for (var i2 = 1; i2 < 30; ++i2) {
    for (var j = b[i2]; j < b[i2 + 1]; ++j) {
      r[j] = j - b[i2] << 5 | i2;
    }
  }
  return [b, r];
};
var _a = freb(fleb, 2), fl = _a[0], revfl = _a[1];
fl[28] = 258, revfl[258] = 28;
var _b = freb(fdeb, 0), revfd = _b[1];
var rev = new u16(32768);
for (var i = 0; i < 32768; ++i) {
  var x = (i & 43690) >>> 1 | (i & 21845) << 1;
  x = (x & 52428) >>> 2 | (x & 13107) << 2;
  x = (x & 61680) >>> 4 | (x & 3855) << 4;
  rev[i] = ((x & 65280) >>> 8 | (x & 255) << 8) >>> 1;
}
var hMap = function hMap2(cd, mb, r) {
  var s2 = cd.length;
  var i2 = 0;
  var l = new u16(mb);
  for (; i2 < s2; ++i2) {
    ++l[cd[i2] - 1];
  }
  var le = new u16(mb);
  for (i2 = 0; i2 < mb; ++i2) {
    le[i2] = le[i2 - 1] + l[i2 - 1] << 1;
  }
  var co;
  if (r) {
    co = new u16(1 << mb);
    var rvb = 15 - mb;
    for (i2 = 0; i2 < s2; ++i2) {
      if (cd[i2]) {
        var sv = i2 << 4 | cd[i2];
        var r_1 = mb - cd[i2];
        var v = le[cd[i2] - 1]++ << r_1;
        for (var m2 = v | (1 << r_1) - 1; v <= m2; ++v) {
          co[rev[v] >>> rvb] = sv;
        }
      }
    }
  } else {
    co = new u16(s2);
    for (i2 = 0; i2 < s2; ++i2) {
      co[i2] = rev[le[cd[i2] - 1]++] >>> 15 - cd[i2];
    }
  }
  return co;
};
var flt = new u8(288);
for (var i = 0; i < 144; ++i) {
  flt[i] = 8;
}
for (var i = 144; i < 256; ++i) {
  flt[i] = 9;
}
for (var i = 256; i < 280; ++i) {
  flt[i] = 7;
}
for (var i = 280; i < 288; ++i) {
  flt[i] = 8;
}
var fdt = new u8(32);
for (var i = 0; i < 32; ++i) {
  fdt[i] = 5;
}
var flm = /* @__PURE__ */ hMap(flt, 9, 0);
var fdm = /* @__PURE__ */ hMap(fdt, 5, 0);
var shft = function shft2(p) {
  return (p / 8 >> 0) + (p & 7 && 1);
};
var slc = function slc2(v, s2, e) {
  if (s2 == null || s2 < 0)
    s2 = 0;
  if (e == null || e > v.length)
    e = v.length;
  var n = new (v instanceof u16 ? u16 : v instanceof u32 ? u32 : u8)(e - s2);
  n.set(v.subarray(s2, e));
  return n;
};
var wbits = function wbits2(d2, p, v) {
  v <<= p & 7;
  var o = p / 8 >> 0;
  d2[o] |= v;
  d2[o + 1] |= v >>> 8;
};
var wbits16 = function wbits162(d2, p, v) {
  v <<= p & 7;
  var o = p / 8 >> 0;
  d2[o] |= v;
  d2[o + 1] |= v >>> 8;
  d2[o + 2] |= v >>> 16;
};
var hTree = function hTree2(d2, mb) {
  var t = [];
  for (var i2 = 0; i2 < d2.length; ++i2) {
    if (d2[i2])
      t.push({
        s: i2,
        f: d2[i2]
      });
  }
  var s2 = t.length;
  var t2 = t.slice();
  if (!s2)
    return [new u8(0), 0];
  if (s2 == 1) {
    var v = new u8(t[0].s + 1);
    v[t[0].s] = 1;
    return [v, 1];
  }
  t.sort(function(a, b) {
    return a.f - b.f;
  });
  t.push({
    s: -1,
    f: 25001
  });
  var l = t[0], r = t[1], i0 = 0, i1 = 1, i22 = 2;
  t[0] = {
    s: -1,
    f: l.f + r.f,
    l,
    r
  };
  while (i1 != s2 - 1) {
    l = t[t[i0].f < t[i22].f ? i0++ : i22++];
    r = t[i0 != i1 && t[i0].f < t[i22].f ? i0++ : i22++];
    t[i1++] = {
      s: -1,
      f: l.f + r.f,
      l,
      r
    };
  }
  var maxSym = t2[0].s;
  for (var i2 = 1; i2 < s2; ++i2) {
    if (t2[i2].s > maxSym)
      maxSym = t2[i2].s;
  }
  var tr = new u16(maxSym + 1);
  var mbt = ln(t[i1 - 1], tr, 0);
  if (mbt > mb) {
    var i2 = 0, dt = 0;
    var lft = mbt - mb, cst = 1 << lft;
    t2.sort(function(a, b) {
      return tr[b.s] - tr[a.s] || a.f - b.f;
    });
    for (; i2 < s2; ++i2) {
      var i2_1 = t2[i2].s;
      if (tr[i2_1] > mb) {
        dt += cst - (1 << mbt - tr[i2_1]);
        tr[i2_1] = mb;
      } else
        break;
    }
    dt >>>= lft;
    while (dt > 0) {
      var i2_2 = t2[i2].s;
      if (tr[i2_2] < mb)
        dt -= 1 << mb - tr[i2_2]++ - 1;
      else
        ++i2;
    }
    for (; i2 >= 0 && dt; --i2) {
      var i2_3 = t2[i2].s;
      if (tr[i2_3] == mb) {
        --tr[i2_3];
        ++dt;
      }
    }
    mbt = mb;
  }
  return [new u8(tr), mbt];
};
var ln = function ln2(n, l, d2) {
  return n.s == -1 ? Math.max(ln2(n.l, l, d2 + 1), ln2(n.r, l, d2 + 1)) : l[n.s] = d2;
};
var lc = function lc2(c) {
  var s2 = c.length;
  while (s2 && !c[--s2]) {
  }
  var cl = new u16(++s2);
  var cli = 0, cln = c[0], cls = 1;
  var w = function w2(v) {
    cl[cli++] = v;
  };
  for (var i2 = 1; i2 <= s2; ++i2) {
    if (c[i2] == cln && i2 != s2)
      ++cls;
    else {
      if (!cln && cls > 2) {
        for (; cls > 138; cls -= 138) {
          w(32754);
        }
        if (cls > 2) {
          w(cls > 10 ? cls - 11 << 5 | 28690 : cls - 3 << 5 | 12305);
          cls = 0;
        }
      } else if (cls > 3) {
        w(cln), --cls;
        for (; cls > 6; cls -= 6) {
          w(8304);
        }
        if (cls > 2)
          w(cls - 3 << 5 | 8208), cls = 0;
      }
      while (cls--) {
        w(cln);
      }
      cls = 1;
      cln = c[i2];
    }
  }
  return [cl.subarray(0, cli), s2];
};
var clen = function clen2(cf, cl) {
  var l = 0;
  for (var i2 = 0; i2 < cl.length; ++i2) {
    l += cf[i2] * cl[i2];
  }
  return l;
};
var wfblk = function wfblk2(out, pos, dat) {
  var s2 = dat.length;
  var o = shft(pos + 2);
  out[o] = s2 & 255;
  out[o + 1] = s2 >>> 8;
  out[o + 2] = out[o] ^ 255;
  out[o + 3] = out[o + 1] ^ 255;
  for (var i2 = 0; i2 < s2; ++i2) {
    out[o + i2 + 4] = dat[i2];
  }
  return (o + 4 + s2) * 8;
};
var wblk = function wblk2(dat, out, _final2, syms, lf, df, eb, li, bs, bl, p) {
  wbits(out, p++, _final2);
  ++lf[256];
  var _a3 = hTree(lf, 15), dlt = _a3[0], mlb = _a3[1];
  var _b2 = hTree(df, 15), ddt = _b2[0], mdb = _b2[1];
  var _c = lc(dlt), lclt = _c[0], nlc = _c[1];
  var _d = lc(ddt), lcdt = _d[0], ndc = _d[1];
  var lcfreq = new u16(19);
  for (var i2 = 0; i2 < lclt.length; ++i2) {
    lcfreq[lclt[i2] & 31]++;
  }
  for (var i2 = 0; i2 < lcdt.length; ++i2) {
    lcfreq[lcdt[i2] & 31]++;
  }
  var _e = hTree(lcfreq, 7), lct = _e[0], mlcb = _e[1];
  var nlcc = 19;
  for (; nlcc > 4 && !lct[clim[nlcc - 1]]; --nlcc) {
  }
  var flen = bl + 5 << 3;
  var ftlen = clen(lf, flt) + clen(df, fdt) + eb;
  var dtlen = clen(lf, dlt) + clen(df, ddt) + eb + 14 + 3 * nlcc + clen(lcfreq, lct) + (2 * lcfreq[16] + 3 * lcfreq[17] + 7 * lcfreq[18]);
  if (flen <= ftlen && flen <= dtlen)
    return wfblk(out, p, dat.subarray(bs, bs + bl));
  var lm, ll, dm, dl;
  wbits(out, p, 1 + (dtlen < ftlen)), p += 2;
  if (dtlen < ftlen) {
    lm = hMap(dlt, mlb, 0), ll = dlt, dm = hMap(ddt, mdb, 0), dl = ddt;
    var llm = hMap(lct, mlcb, 0);
    wbits(out, p, nlc - 257);
    wbits(out, p + 5, ndc - 1);
    wbits(out, p + 10, nlcc - 4);
    p += 14;
    for (var i2 = 0; i2 < nlcc; ++i2) {
      wbits(out, p + 3 * i2, lct[clim[i2]]);
    }
    p += 3 * nlcc;
    var lcts = [lclt, lcdt];
    for (var it = 0; it < 2; ++it) {
      var clct = lcts[it];
      for (var i2 = 0; i2 < clct.length; ++i2) {
        var len = clct[i2] & 31;
        wbits(out, p, llm[len]), p += lct[len];
        if (len > 15)
          wbits(out, p, clct[i2] >>> 5 & 127), p += clct[i2] >>> 12;
      }
    }
  } else {
    lm = flm, ll = flt, dm = fdm, dl = fdt;
  }
  for (var i2 = 0; i2 < li; ++i2) {
    if (syms[i2] > 255) {
      var len = syms[i2] >>> 18 & 31;
      wbits16(out, p, lm[len + 257]), p += ll[len + 257];
      if (len > 7)
        wbits(out, p, syms[i2] >>> 23 & 31), p += fleb[len];
      var dst = syms[i2] & 31;
      wbits16(out, p, dm[dst]), p += dl[dst];
      if (dst > 3)
        wbits16(out, p, syms[i2] >>> 5 & 8191), p += fdeb[dst];
    } else {
      wbits16(out, p, lm[syms[i2]]), p += ll[syms[i2]];
    }
  }
  wbits16(out, p, lm[256]);
  return p + ll[256];
};
var deo = /* @__PURE__ */ new u32([65540, 131080, 131088, 131104, 262176, 1048704, 1048832, 2114560, 2117632]);
var et = /* @__PURE__ */ new u8(0);
var dflt = function dflt2(dat, lvl, plvl, pre, post, lst) {
  var s2 = dat.length;
  var o = new u8(pre + s2 + 5 * (1 + Math.floor(s2 / 7e3)) + post);
  var w = o.subarray(pre, o.length - post);
  var pos = 0;
  if (!lvl || s2 < 8) {
    for (var i2 = 0; i2 <= s2; i2 += 65535) {
      var e = i2 + 65535;
      if (e < s2) {
        pos = wfblk(w, pos, dat.subarray(i2, e));
      } else {
        w[i2] = lst;
        pos = wfblk(w, pos, dat.subarray(i2, s2));
      }
    }
  } else {
    var opt = deo[lvl - 1];
    var n = opt >>> 13, c = opt & 8191;
    var msk_1 = (1 << plvl) - 1;
    var prev = new u16(32768), head = new u16(msk_1 + 1);
    var bs1_1 = Math.ceil(plvl / 3), bs2_1 = 2 * bs1_1;
    var hsh = function hsh2(i3) {
      return (dat[i3] ^ dat[i3 + 1] << bs1_1 ^ dat[i3 + 2] << bs2_1) & msk_1;
    };
    var syms = new u32(25e3);
    var lf = new u16(288), df = new u16(32);
    var lc_1 = 0, eb = 0, i2 = 0, li = 0, wi = 0, bs = 0;
    for (; i2 < s2; ++i2) {
      var hv = hsh(i2);
      var imod = i2 & 32767;
      var pimod = head[hv];
      prev[imod] = pimod;
      head[hv] = imod;
      if (wi <= i2) {
        var rem = s2 - i2;
        if ((lc_1 > 7e3 || li > 24576) && rem > 423) {
          pos = wblk(dat, w, 0, syms, lf, df, eb, li, bs, i2 - bs, pos);
          li = lc_1 = eb = 0, bs = i2;
          for (var j = 0; j < 286; ++j) {
            lf[j] = 0;
          }
          for (var j = 0; j < 30; ++j) {
            df[j] = 0;
          }
        }
        var l = 2, d2 = 0, ch_1 = c, dif = imod - pimod & 32767;
        if (rem > 2 && hv == hsh(i2 - dif)) {
          var maxn = Math.min(n, rem) - 1;
          var maxd = Math.min(32767, i2);
          var ml = Math.min(258, rem);
          while (dif <= maxd && --ch_1 && imod != pimod) {
            if (dat[i2 + l] == dat[i2 + l - dif]) {
              var nl = 0;
              for (; nl < ml && dat[i2 + nl] == dat[i2 + nl - dif]; ++nl) {
              }
              if (nl > l) {
                l = nl, d2 = dif;
                if (nl > maxn)
                  break;
                var mmd = Math.min(dif, nl - 2);
                var md = 0;
                for (var j = 0; j < mmd; ++j) {
                  var ti = i2 - dif + j + 32768 & 32767;
                  var pti = prev[ti];
                  var cd = ti - pti + 32768 & 32767;
                  if (cd > md)
                    md = cd, pimod = ti;
                }
              }
            }
            imod = pimod, pimod = prev[imod];
            dif += imod - pimod + 32768 & 32767;
          }
        }
        if (d2) {
          syms[li++] = 268435456 | revfl[l] << 18 | revfd[d2];
          var lin = revfl[l] & 31, din = revfd[d2] & 31;
          eb += fleb[lin] + fdeb[din];
          ++lf[257 + lin];
          ++df[din];
          wi = i2 + l;
          ++lc_1;
        } else {
          syms[li++] = dat[i2];
          ++lf[dat[i2]];
        }
      }
    }
    pos = wblk(dat, w, lst, syms, lf, df, eb, li, bs, i2 - bs, pos);
    if (!lst)
      pos = wfblk(w, pos, et);
  }
  return slc(o, 0, pre + shft(pos) + post);
};
var crct = /* @__PURE__ */ function() {
  var t = new u32(256);
  for (var i2 = 0; i2 < 256; ++i2) {
    var c = i2, k = 9;
    while (--k) {
      c = (c & 1 && 3988292384) ^ c >>> 1;
    }
    t[i2] = c;
  }
  return t;
}();
var crc = function crc2() {
  var c = 4294967295;
  return {
    p: function p(d2) {
      var cr = c;
      for (var i2 = 0; i2 < d2.length; ++i2) {
        cr = crct[cr & 255 ^ d2[i2]] ^ cr >>> 8;
      }
      c = cr;
    },
    d: function d2() {
      return c ^ 4294967295;
    }
  };
};
var dopt = function dopt2(dat, opt, pre, post, st) {
  return dflt(dat, opt.level == null ? 6 : opt.level, opt.mem == null ? Math.ceil(Math.max(8, Math.min(13, Math.log(dat.length))) * 1.5) : 12 + opt.mem, pre, post, !st);
};
var wbytes = function wbytes2(d2, b, v) {
  for (; v; ++b) {
    d2[b] = v, v >>>= 8;
  }
};
var gzh = function gzh2(c, o) {
  var fn = o.filename;
  c[0] = 31, c[1] = 139, c[2] = 8, c[8] = o.level < 2 ? 4 : o.level == 9 ? 2 : 0, c[9] = 3;
  if (o.mtime != 0)
    wbytes(c, 4, Math.floor(new Date(o.mtime || Date.now()) / 1e3));
  if (fn) {
    c[3] = 8;
    for (var i2 = 0; i2 <= fn.length; ++i2) {
      c[i2 + 10] = fn.charCodeAt(i2);
    }
  }
};
var gzhl = function gzhl2(o) {
  return 10 + (o.filename && o.filename.length + 1 || 0);
};
function gzipSync(data2, opts) {
  if (opts === void 0) {
    opts = {};
  }
  var c = crc(), l = data2.length;
  c.p(data2);
  var d2 = dopt(data2, opts, gzhl(opts), 8), s2 = d2.length;
  return gzh(d2, opts), wbytes(d2, s2 - 8, c.d()), wbytes(d2, s2 - 4, l), d2;
}
function strToU8(str2, latin1) {
  var l = str2.length;
  if (!latin1 && typeof TextEncoder != "undefined")
    return new TextEncoder().encode(str2);
  var ar = new u8(str2.length + (str2.length >>> 1));
  var ai = 0;
  var w = function w2(v) {
    ar[ai++] = v;
  };
  for (var i2 = 0; i2 < l; ++i2) {
    if (ai + 5 > ar.length) {
      var n = new u8(ai + 8 + (l - i2 << 1));
      n.set(ar);
      ar = n;
    }
    var c = str2.charCodeAt(i2);
    if (c < 128 || latin1)
      w(c);
    else if (c < 2048)
      w(192 | c >>> 6), w(128 | c & 63);
    else if (c > 55295 && c < 57344)
      c = 65536 + (c & 1023 << 10) | str2.charCodeAt(++i2) & 1023, w(240 | c >>> 18), w(128 | c >>> 12 & 63), w(128 | c >>> 6 & 63), w(128 | c & 63);
    else
      w(224 | c >>> 12), w(128 | c >>> 6 & 63), w(128 | c & 63);
  }
  return slc(ar, 0, ai);
}
function decideCompression(compressionSupport) {
  if (compressionSupport["gzip-js"]) {
    return "gzip-js";
  } else if (compressionSupport["lz64"]) {
    return "lz64";
  } else {
    return "base64";
  }
}
function compressData(compression, jsonData, options) {
  if (compression === "lz64") {
    return [{
      data: LZString.compressToBase64(jsonData),
      compression: "lz64"
    }, options];
  } else if (compression === "gzip-js") {
    return [gzipSync(strToU8(jsonData), {
      mtime: 0
    }), _objectSpread2(_objectSpread2({}, options), {}, {
      blob: true,
      urlQueryArgs: {
        compression: "gzip-js"
      }
    })];
  } else {
    return [{
      data: _.base64Encode(jsonData)
    }, options];
  }
}
var addParamsToURL = function addParamsToURL2(url, urlQueryArgs, parameterOptions) {
  var args = urlQueryArgs || {};
  args["ip"] = parameterOptions["ip"] ? 1 : 0;
  args["_"] = new Date().getTime().toString();
  args["ver"] = Config$1.LIB_VERSION;
  var halves = url.split("?");
  if (halves.length > 1) {
    var params = halves[1].split("&");
    var _iterator = _createForOfIteratorHelper(params), _step;
    try {
      for (_iterator.s(); !(_step = _iterator.n()).done; ) {
        var p = _step.value;
        var key = p.split("=")[0];
        if (args[key]) {
          delete args[key];
        }
      }
    } catch (err) {
      _iterator.e(err);
    } finally {
      _iterator.f();
    }
  }
  var argSeparator = url.indexOf("?") > -1 ? "&" : "?";
  return url + argSeparator + _.HTTPBuildQuery(args);
};
var encodePostData = function encodePostData2(data2, options) {
  if (options.blob && data2.buffer) {
    return new Blob([data2.buffer], {
      type: "text/plain"
    });
  }
  if (options.sendBeacon || options.blob) {
    var body = encodePostData2(data2, {
      method: "POST"
    });
    return new Blob([body], {
      type: "application/x-www-form-urlencoded"
    });
  }
  if (options.method !== "POST") {
    return null;
  }
  var body_data;
  var isUint8Array = function isUint8Array2(d2) {
    return Object.prototype.toString.call(d2) === "[object Uint8Array]";
  };
  if (Array.isArray(data2) || isUint8Array(data2)) {
    body_data = "data=" + encodeURIComponent(data2);
  } else {
    body_data = "data=" + encodeURIComponent(data2["data"]);
  }
  if (data2["compression"]) {
    body_data += "&compression=" + data2["compression"];
  }
  return body_data;
};
var xhr = function xhr2(_ref) {
  var url = _ref.url, data2 = _ref.data, headers = _ref.headers, options = _ref.options, captureMetrics = _ref.captureMetrics, callback = _ref.callback, retriesPerformedSoFar = _ref.retriesPerformedSoFar, retryQueue = _ref.retryQueue, onXHRError = _ref.onXHRError;
  var req = new XMLHttpRequest();
  req.open(options.method, url, true);
  var body = encodePostData(data2, options);
  captureMetrics.incr("_send_request");
  captureMetrics.incr("_send_request_inflight");
  _.each(headers, function(headerValue, headerName) {
    req.setRequestHeader(headerName, headerValue);
  });
  if (options.method === "POST" && !options.blob) {
    req.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
  }
  req.withCredentials = true;
  req.onreadystatechange = function() {
    if (req.readyState === 4) {
      captureMetrics.incr("xhr-response");
      captureMetrics.incr("xhr-response-".concat(req.status));
      captureMetrics.decr("_send_request_inflight");
      if (req.status === 200) {
        if (callback) {
          var response;
          try {
            response = JSON.parse(req.responseText);
          } catch (e) {
            logger.error(e);
            return;
          }
          callback(response);
        }
      } else {
        if (typeof onXHRError === "function") {
          onXHRError(req);
        }
        if ([401, 403, 404, 500].indexOf(req.status) < 0) {
          retryQueue.enqueue({
            url,
            data: data2,
            options,
            headers,
            retriesPerformedSoFar: (retriesPerformedSoFar || 0) + 1,
            callback
          });
        }
        if (callback) {
          if (options.verbose) {
            callback({
              status: 0,
              error
            });
          } else {
            callback(0);
          }
        }
      }
    }
  };
  req.send(body);
};
var RetryQueue = /* @__PURE__ */ function(_RequestQueueScaffold) {
  _inherits(RetryQueue2, _RequestQueueScaffold);
  var _super = _createSuper(RetryQueue2);
  function RetryQueue2(captureMetrics, onXHRError) {
    var _this;
    _classCallCheck(this, RetryQueue2);
    _this = _super.call(this);
    _this.captureMetrics = captureMetrics;
    _this.isPolling = false;
    _this.queue = [];
    _this.areWeOnline = true;
    _this.onXHRError = onXHRError;
    if ("onLine" in window.navigator) {
      _this.areWeOnline = window.navigator.onLine;
      window.addEventListener("online", function() {
        _this._handleWeAreNowOnline();
      });
      window.addEventListener("offline", function() {
        _this.areWeOnline = false;
      });
    }
    return _this;
  }
  _createClass(RetryQueue2, [{
    key: "enqueue",
    value: function enqueue(requestData) {
      var retriesPerformedSoFar = requestData.retriesPerformedSoFar || 0;
      if (retriesPerformedSoFar >= 10) {
        return;
      }
      var msToNextRetry = 3e3 * Math.pow(2, retriesPerformedSoFar);
      var retryAt = new Date(Date.now() + msToNextRetry);
      console.warn("Enqueued failed request for retry in ".concat(msToNextRetry));
      this.queue.push({
        retryAt,
        requestData
      });
      if (!this.isPolling) {
        this.isPolling = true;
        this.poll();
      }
    }
  }, {
    key: "poll",
    value: function poll() {
      var _this2 = this;
      clearTimeout(this._poller);
      this._poller = setTimeout(function() {
        if (_this2.areWeOnline && _this2.queue.length > 0) {
          _this2.flush();
        }
        _this2.poll();
      }, this._pollInterval);
    }
  }, {
    key: "flush",
    value: function flush() {
      var now = new Date(Date.now());
      var toFlush = this.queue.filter(function(_ref) {
        var retryAt = _ref.retryAt;
        return retryAt < now;
      });
      if (toFlush.length > 0) {
        this.queue = this.queue.filter(function(_ref2) {
          var retryAt = _ref2.retryAt;
          return retryAt >= now;
        });
        var _iterator = _createForOfIteratorHelper(toFlush), _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done; ) {
            var requestData = _step.value.requestData;
            this._executeXhrRequest(requestData);
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
      }
    }
  }, {
    key: "unload",
    value: function unload() {
      clearTimeout(this._poller);
      var _iterator2 = _createForOfIteratorHelper(this.queue), _step2;
      try {
        for (_iterator2.s(); !(_step2 = _iterator2.n()).done; ) {
          var requestData = _step2.value.requestData;
          var url = requestData.url, data2 = requestData.data, options = requestData.options;
          try {
            window.navigator.sendBeacon(url, encodePostData(data2, _objectSpread2(_objectSpread2({}, options), {}, {
              sendBeacon: true
            })));
          } catch (e) {
            var _this$get_config;
            if ((_this$get_config = this.get_config) !== null && _this$get_config !== void 0 && _this$get_config.call(this, "debug")) {
              console.error(e);
            }
          }
        }
      } catch (err) {
        _iterator2.e(err);
      } finally {
        _iterator2.f();
      }
      this.queue = [];
    }
  }, {
    key: "_executeXhrRequest",
    value: function _executeXhrRequest(_ref3) {
      var url = _ref3.url, data2 = _ref3.data, options = _ref3.options, headers = _ref3.headers, callback = _ref3.callback, retriesPerformedSoFar = _ref3.retriesPerformedSoFar;
      xhr({
        url,
        data: data2 || {},
        options: options || {},
        headers: headers || {},
        retriesPerformedSoFar: retriesPerformedSoFar || 0,
        callback,
        captureMetrics: this.captureMetrics,
        retryQueue: this,
        onXHRError: this.onXHRError
      });
    }
  }, {
    key: "_handleWeAreNowOnline",
    value: function _handleWeAreNowOnline() {
      this.areWeOnline = true;
      this.flush();
    }
  }]);
  return RetryQueue2;
}(RequestQueueScaffold);
var SESSION_CHANGE_THRESHOLD = 30 * 60 * 1e3;
var SESSION_LENGTH_LIMIT = 24 * 3600 * 1e3;
var SessionIdManager = /* @__PURE__ */ function() {
  function SessionIdManager2(config, persistence) {
    _classCallCheck(this, SessionIdManager2);
    this.persistence = persistence;
    if (config["persistence_name"]) {
      this.window_id_storage_key = "ph_" + config["persistence_name"] + "_window_id";
    } else {
      this.window_id_storage_key = "ph_" + config["token"] + "_window_id";
    }
  }
  _createClass(SessionIdManager2, [{
    key: "_setWindowId",
    value: function _setWindowId(windowId) {
      if (windowId !== this._windowId) {
        this._windowId = windowId;
        if (!this.persistence.disabled && sessionStore.is_supported()) {
          sessionStore.set(this.window_id_storage_key, windowId);
        }
      }
    }
  }, {
    key: "_getWindowId",
    value: function _getWindowId() {
      if (this._windowId) {
        return this._windowId;
      }
      if (!this.persistence.disabled && sessionStore.is_supported()) {
        return sessionStore.parse(this.window_id_storage_key);
      }
      return null;
    }
  }, {
    key: "_setSessionId",
    value: function _setSessionId(sessionId, sessionActivityTimestamp, sessionStartTimestamp) {
      if (sessionId !== this._sessionId || sessionActivityTimestamp !== this._sessionActivityTimestamp || sessionStartTimestamp !== this._sessionStartTimestamp) {
        this._sessionStartTimestamp = sessionStartTimestamp;
        this._sessionActivityTimestamp = sessionActivityTimestamp;
        this._sessionId = sessionId;
        this.persistence.register(_defineProperty({}, SESSION_ID, [sessionActivityTimestamp, sessionId, sessionStartTimestamp]));
      }
    }
  }, {
    key: "_getSessionId",
    value: function _getSessionId() {
      if (this._sessionId && this._sessionActivityTimestamp && this._sessionStartTimestamp) {
        return [this._sessionActivityTimestamp, this._sessionId, this._sessionStartTimestamp];
      }
      var sessionId = this.persistence["props"][SESSION_ID];
      if (Array.isArray(sessionId) && sessionId.length === 2) {
        sessionId.push(sessionId[0]);
      }
      return sessionId || [0, null, 0];
    }
  }, {
    key: "resetSessionId",
    value: function resetSessionId() {
      this._setSessionId(null, null, null);
    }
  }, {
    key: "checkAndGetSessionAndWindowId",
    value: function checkAndGetSessionAndWindowId() {
      var readOnly = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : false;
      var timestamp = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : null;
      timestamp = timestamp || new Date().getTime();
      var _this$_getSessionId = this._getSessionId(), _this$_getSessionId2 = _slicedToArray(_this$_getSessionId, 3), lastTimestamp = _this$_getSessionId2[0], sessionId = _this$_getSessionId2[1], startTimestamp = _this$_getSessionId2[2];
      var windowId = this._getWindowId();
      var sessionPastMaximumLength = startTimestamp && startTimestamp > 0 && Math.abs(timestamp - startTimestamp) > SESSION_LENGTH_LIMIT;
      if (!sessionId || !readOnly && Math.abs(timestamp - lastTimestamp) > SESSION_CHANGE_THRESHOLD || sessionPastMaximumLength) {
        sessionId = _.UUID();
        windowId = _.UUID();
        startTimestamp = timestamp;
      } else if (!windowId) {
        windowId = _.UUID();
      }
      var newTimestamp = lastTimestamp === 0 || !readOnly || sessionPastMaximumLength ? timestamp : lastTimestamp;
      var sessionStartTimestamp = startTimestamp === 0 ? new Date().getTime() : startTimestamp;
      this._setWindowId(windowId);
      this._setSessionId(sessionId, newTimestamp, sessionStartTimestamp);
      return {
        sessionId,
        windowId
      };
    }
  }]);
  return SessionIdManager2;
}();
function isFloat(n) {
  return Number(n) === n && n % 1 !== 0;
}
function optimisePerformanceData(performanceEntries) {
  performanceEntries.forEach(function(performanceEntry, index) {
    for (var performanceEntryItemKey in performanceEntry) {
      if (isFloat(performanceEntry[performanceEntryItemKey]) && performanceEntry[performanceEntryItemKey].toString().match(/^\d+\.\d{4,}$/)) {
        performanceEntries[index][performanceEntryItemKey] = Number(performanceEntry[performanceEntryItemKey].toFixed(3));
      }
      if (["serverTiming", "workerTiming"].includes(performanceEntryItemKey) && performanceEntry[performanceEntryItemKey].length === 0) {
        delete performanceEntries[index][performanceEntryItemKey];
      }
      if (performanceEntryItemKey === "entryType" && performanceEntry[performanceEntryItemKey] === "resource") {
        delete performanceEntries[index][performanceEntryItemKey];
      }
      if (performanceEntryItemKey === "nextHopProtocol") {
        delete performanceEntries[index][performanceEntryItemKey];
      }
      if (performanceEntry[performanceEntryItemKey] === 0) {
        delete performanceEntries[index][performanceEntryItemKey];
      }
    }
  });
  return deduplicateKeys(performanceEntries);
}
function getPerformanceEntriesByType(type) {
  try {
    var entriesOfType = JSON.parse(JSON.stringify(win.performance.getEntriesByType(type)));
    return optimisePerformanceData(entriesOfType);
  } catch (ex) {
    if (Config$1.DEBUG) {
      console.warn("not able to capture performance data (" + type + ") - " + ex);
    }
    return [];
  }
}
function deduplicateKeys(performanceEntries) {
  if (performanceEntries.length === 0) {
    return [];
  }
  var keys3 = Object.keys(performanceEntries[0]);
  return [keys3, performanceEntries.map(function(obj) {
    return keys3.map(function(key) {
      return obj[key];
    });
  })];
}
function pageLoadFrom(performanceData) {
  var keys3 = performanceData.navigation && performanceData.navigation[0];
  var values2 = performanceData.navigation && performanceData.navigation[1] && performanceData.navigation[1][0];
  var durationIndex = keys3 && keys3.indexOf("duration");
  if (durationIndex > -1) {
    return values2[durationIndex];
  } else {
    var endKeyIndex = keys3 && keys3.indexOf("loadEventEnd");
    var startKeyIndex = keys3 && keys3.indexOf("startTime");
    if (endKeyIndex > -1) {
      var end = values2 && values2[endKeyIndex];
      var start = values2 && values2[startKeyIndex] || 0;
      return end - start;
    }
  }
}
function getPerformanceData() {
  var performanceEntries = {
    navigation: getPerformanceEntriesByType("navigation"),
    paint: getPerformanceEntriesByType("paint"),
    resource: getPerformanceEntriesByType("resource")
  };
  if (_typeof(win) !== void 0 && win.performance && win.performance.clearResourceTimings) {
    win.performance.clearResourceTimings();
  }
  var properties2 = {};
  var pageLoad = pageLoadFrom(performanceEntries);
  if (pageLoad) {
    properties2["$performance_page_loaded"] = pageLoad;
  }
  properties2["$performance_raw"] = JSON.stringify(performanceEntries);
  return properties2;
}
var init_type;
var posthog_master;
var INIT_MODULE = 0;
var INIT_SNIPPET = 1;
var __NOOP = function __NOOP2() {
};
var __NOOPTIONS = {};
var PRIMARY_INSTANCE_NAME = "posthog";
var USE_XHR = win.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
var ENQUEUE_REQUESTS = !USE_XHR && userAgent$1.indexOf("MSIE") === -1 && userAgent$1.indexOf("Mozilla") === -1;
var defaultConfig = function defaultConfig2() {
  return {
    api_host: "https://app.posthog.com",
    api_method: "POST",
    api_transport: "XHR",
    autocapture: true,
    rageclick: false,
    cross_subdomain_cookie: document$1$1.location.hostname.indexOf("herokuapp.com") === -1,
    persistence: "cookie",
    persistence_name: "",
    cookie_name: "",
    loaded: function loaded() {
    },
    store_google: true,
    save_referrer: true,
    test: false,
    verbose: false,
    img: false,
    capture_pageview: true,
    debug: false,
    cookie_expiration: 365,
    upgrade: false,
    disable_session_recording: false,
    disable_persistence: false,
    disable_cookie: false,
    enable_recording_console_log: false,
    secure_cookie: win.location.protocol === "https:",
    ip: true,
    opt_out_capturing_by_default: false,
    opt_out_persistence_by_default: false,
    opt_out_capturing_persistence_type: "localStorage",
    opt_out_capturing_cookie_prefix: null,
    property_blacklist: [],
    sanitize_properties: null,
    xhr_headers: {},
    inapp_protocol: "//",
    inapp_link_new_window: false,
    request_batching: true,
    properties_string_max_length: 65535,
    session_recording: {
      blockClass: "ph-no-capture",
      blockSelector: null,
      ignoreClass: "ph-ignore-input",
      maskAllInputs: true,
      maskInputOptions: {},
      maskInputFn: null,
      slimDOMOptions: {},
      collectFonts: false,
      inlineStylesheet: true
    },
    mask_all_element_attributes: false,
    mask_all_text: false,
    advanced_disable_decide: false,
    advanced_disable_toolbar_metrics: false,
    on_xhr_error: function on_xhr_error(req) {
      var error6 = "Bad HTTP status: " + req.status + " " + req.statusText;
      console.error(error6);
    },
    get_device_id: function get_device_id(uuid) {
      return uuid;
    },
    _onCapture: function _onCapture() {
    },
    _capture_metrics: false,
    _capture_performance: false
  };
};
var PostHogLib = function PostHogLib2() {
};
var create_mplib = function create_mplib2(token, config, name) {
  var instance, target = name === PRIMARY_INSTANCE_NAME || !posthog_master ? posthog_master : posthog_master[name];
  if (target && init_type === INIT_MODULE) {
    instance = target;
  } else {
    if (target && !_.isArray(target)) {
      console.error("You have already initialized " + name);
      return;
    }
    instance = new PostHogLib();
  }
  instance._init(token, config, name);
  instance["people"] = new PostHogPeople();
  instance["people"]._init(instance);
  instance.featureFlags = new PostHogFeatureFlags(instance);
  instance.feature_flags = instance.featureFlags;
  instance.toolbar = new Toolbar(instance);
  instance.toolbar.maybeLoadEditor();
  instance.sessionRecording = new SessionRecording(instance);
  instance.sessionRecording.startRecordingIfEnabled();
  instance["__autocapture_enabled"] = instance.get_config("autocapture");
  if (instance.get_config("autocapture")) {
    var num_buckets = 100;
    var num_enabled_buckets = 100;
    if (!autocapture.enabledForProject(instance.get_config("token"), num_buckets, num_enabled_buckets)) {
      instance["__autocapture_enabled"] = false;
      logger.log("Not in active bucket: disabling Automatic Event Collection.");
    } else if (!autocapture.isBrowserSupported()) {
      instance["__autocapture_enabled"] = false;
      logger.log("Disabling Automatic Event Collection because this browser is not supported");
    } else {
      autocapture.init(instance);
    }
  }
  Config$1.DEBUG = Config$1.DEBUG || instance.get_config("debug");
  if (!_.isUndefined(target) && _.isArray(target)) {
    instance._execute_array.call(instance["people"], target["people"]);
    instance._execute_array(target);
  }
  return instance;
};
PostHogLib.prototype.init = function(token, config, name) {
  if (_.isUndefined(name)) {
    console.error("You must name your new library: init(token, config, name)");
    return;
  }
  if (name === PRIMARY_INSTANCE_NAME) {
    console.error("You must initialize the main posthog object right after you include the PostHog js snippet");
    return;
  }
  var instance = create_mplib(token, config, name);
  posthog_master[name] = instance;
  instance._loaded();
  return instance;
};
PostHogLib.prototype._init = function(token, config, name) {
  this["__loaded"] = true;
  this["config"] = {};
  this["_triggered_notifs"] = [];
  this["compression"] = {};
  this.set_config(_.extend({}, defaultConfig(), config, {
    name,
    token,
    callback_fn: (name === PRIMARY_INSTANCE_NAME ? name : PRIMARY_INSTANCE_NAME + "." + name) + "._jsc"
  }));
  this["_jsc"] = function() {
  };
  this._captureMetrics = new CaptureMetrics(this.get_config("_capture_metrics"));
  this._requestQueue = new RequestQueue(this._captureMetrics, _.bind(this._handle_queued_event, this));
  this._retryQueue = new RetryQueue(this._captureMetrics, this.get_config("on_xhr_error"));
  this.__captureHooks = [];
  this.__request_queue = [];
  this["persistence"] = new PostHogPersistence(this["config"]);
  this["sessionManager"] = new SessionIdManager(this["config"], this["persistence"]);
  this._gdpr_init();
  if (!this.get_distinct_id()) {
    var uuid = this.get_config("get_device_id")(_.UUID());
    this.register_once({
      distinct_id: uuid,
      $device_id: uuid
    }, "");
  }
  win.addEventListener && win.addEventListener("unload", this._handle_unload.bind(this));
};
PostHogLib.prototype._loaded = function() {
  this.featureFlags.setReloadingPaused(true);
  try {
    this.get_config("loaded")(this);
  } catch (err) {
    console.error("`loaded` function failed", err);
  }
  this._start_queue_if_opted_in();
  if (this.get_config("capture_pageview")) {
    this.capture("$pageview", {}, {
      send_instantly: true
    });
  }
  if (!this.get_config("advanced_disable_decide")) {
    new Decide(this).call();
  }
  this.featureFlags.resetRequestQueue();
  this.featureFlags.setReloadingPaused(false);
};
PostHogLib.prototype._start_queue_if_opted_in = function() {
  if (!this.has_opted_out_capturing()) {
    if (this.get_config("request_batching")) {
      this._requestQueue.poll();
    }
  }
};
PostHogLib.prototype._dom_loaded = function() {
  if (!this.has_opted_out_capturing()) {
    _.each(this.__request_queue, function(item) {
      this._send_request.apply(this, item);
    }, this);
  }
  delete this.__request_queue;
  this._start_queue_if_opted_in();
};
PostHogLib.prototype._prepare_callback = function(callback, data2) {
  if (_.isUndefined(callback)) {
    return null;
  }
  if (USE_XHR) {
    var callback_function = function callback_function2(response) {
      callback(response, data2);
    };
    return callback_function;
  } else {
    var jsc = this["_jsc"];
    var randomized_cb = "" + Math.floor(Math.random() * 1e8);
    var callback_string = this.get_config("callback_fn") + "[" + randomized_cb + "]";
    jsc[randomized_cb] = function(response) {
      delete jsc[randomized_cb];
      callback(response, data2);
    };
    return callback_string;
  }
};
PostHogLib.prototype._handle_unload = function() {
  if (!this.get_config("request_batching")) {
    if (this.get_config("capture_pageview")) {
      this.capture("$pageleave", null, {
        transport: "sendbeacon"
      });
    }
    return;
  }
  if (this.get_config("capture_pageview")) {
    this.capture("$pageleave");
  }
  if (this.get_config("_capture_metrics")) {
    this._requestQueue.updateUnloadMetrics();
    this.capture("$capture_metrics", this._captureMetrics.metrics);
  }
  this._requestQueue.unload();
  this._retryQueue.unload();
};
PostHogLib.prototype._handle_queued_event = function(url, data2, options) {
  var jsonData = JSON.stringify(data2);
  this.__compress_and_send_json_request(url, jsonData, options || __NOOPTIONS, __NOOP);
};
PostHogLib.prototype.__compress_and_send_json_request = function(url, jsonData, options, callback) {
  var _compressData = compressData(decideCompression(this.compression), jsonData, options), _compressData2 = _slicedToArray(_compressData, 2), data2 = _compressData2[0], _options = _compressData2[1];
  this._send_request(url, data2, _options, callback);
};
PostHogLib.prototype._send_request = function(url, data2, options, callback) {
  if (ENQUEUE_REQUESTS) {
    this.__request_queue.push(arguments);
    return;
  }
  var DEFAULT_OPTIONS = {
    method: this.get_config("api_method"),
    transport: this.get_config("api_transport"),
    verbose: this.get_config("verbose")
  };
  options = _.extend(DEFAULT_OPTIONS, options || {});
  if (!USE_XHR) {
    options.method = "GET";
  }
  var useSendBeacon = win.navigator.sendBeacon && options.transport.toLowerCase() === "sendbeacon";
  url = addParamsToURL(url, options.urlQueryArgs, {
    ip: this.get_config("ip")
  });
  if (_.isObject(data2) && this.get_config("img")) {
    var img = document$1$1.createElement("img");
    img.src = url;
    document$1$1.body.appendChild(img);
  } else if (useSendBeacon) {
    try {
      win.navigator.sendBeacon(url, encodePostData(data2, _objectSpread2(_objectSpread2({}, options), {}, {
        sendBeacon: true
      })));
    } catch (e) {
      if (this.get_config("debug")) {
        console.error(e);
      }
    }
  } else if (USE_XHR) {
    try {
      xhr({
        url,
        data: data2,
        headers: this.get_config("xhr_headers"),
        options,
        captureMetrics: this._captureMetrics,
        callback,
        retriesPerformedSoFar: 0,
        retryQueue: this._retryQueue,
        onXHRError: this.get_config("on_xhr_error")
      });
    } catch (e) {
      console.error(e);
    }
  } else {
    var script = document$1$1.createElement("script");
    script.type = "text/javascript";
    script.async = true;
    script.defer = true;
    script.src = url;
    var s2 = document$1$1.getElementsByTagName("script")[0];
    s2.parentNode.insertBefore(script, s2);
  }
};
PostHogLib.prototype._execute_array = function(array) {
  var fn_name, alias_calls = [], other_calls = [], capturing_calls = [];
  _.each(array, function(item) {
    if (item) {
      fn_name = item[0];
      if (_.isArray(fn_name)) {
        capturing_calls.push(item);
      } else if (typeof item === "function") {
        item.call(this);
      } else if (_.isArray(item) && fn_name === "alias") {
        alias_calls.push(item);
      } else if (_.isArray(item) && fn_name.indexOf("capture") !== -1 && typeof this[fn_name] === "function") {
        capturing_calls.push(item);
      } else {
        other_calls.push(item);
      }
    }
  }, this);
  var execute = function execute2(calls, context) {
    _.each(calls, function(item) {
      if (_.isArray(item[0])) {
        var caller = context;
        _.each(item, function(call2) {
          caller = caller[call2[0]].apply(caller, call2.slice(1));
        });
      } else {
        this[item[0]].apply(this, item.slice(1));
      }
    }, context);
  };
  execute(alias_calls, this);
  execute(other_calls, this);
  execute(capturing_calls, this);
};
PostHogLib.prototype.push = function(item) {
  this._execute_array([item]);
};
PostHogLib.prototype.capture = addOptOutCheckPostHogLib(function(event_name, properties2, options) {
  if (!this["__loaded"]) {
    return;
  }
  this._captureMetrics.incr("capture");
  if (event_name === "$snapshot") {
    this._captureMetrics.incr("snapshot");
  }
  options = options || __NOOPTIONS;
  var transport = options["transport"];
  if (transport) {
    options.transport = transport;
  }
  if (_.isUndefined(event_name) || typeof event_name !== "string") {
    console.error("No event name provided to posthog.capture");
    return;
  }
  if (_.isBlockedUA(userAgent$1)) {
    return;
  }
  var start_timestamp = this["persistence"].remove_event_timer(event_name);
  this["persistence"].update_search_keyword(document$1$1.referrer);
  if (this.get_config("store_google")) {
    this["persistence"].update_campaign_params();
  }
  if (this.get_config("save_referrer")) {
    this["persistence"].update_referrer_info(document$1$1.referrer);
  }
  var data2 = {
    event: event_name,
    properties: this._calculate_event_properties(event_name, properties2, start_timestamp)
  };
  if (event_name === "$identify" && options.$set) {
    data2["$set"] = options["$set"];
  }
  data2 = _.copyAndTruncateStrings(data2, options._noTruncate ? null : this.get_config("properties_string_max_length"));
  if (this.get_config("debug")) {
    logger.log("PostHog.js send", data2);
  }
  var jsonData = JSON.stringify(data2);
  var url = this.get_config("api_host") + (options.endpoint || "/e/");
  var has_unique_traits = options !== __NOOPTIONS;
  if (this.get_config("request_batching") && (!has_unique_traits || options._batchKey) && !options.send_instantly) {
    data2["timestamp"] = new Date();
    this._requestQueue.enqueue(url, data2, options);
  } else {
    this.__compress_and_send_json_request(url, jsonData, options);
  }
  this._invokeCaptureHooks(event_name, data2);
  return data2;
});
PostHogLib.prototype._addCaptureHook = function(callback) {
  this.__captureHooks.push(callback);
};
PostHogLib.prototype._invokeCaptureHooks = function(eventName, eventData) {
  this.config._onCapture(eventName, eventData);
  _.each(this.__captureHooks, function(callback) {
    return callback(eventName);
  });
};
PostHogLib.prototype._calculate_event_properties = function(event_name, event_properties, start_timestamp) {
  var properties2 = _objectSpread2({}, event_properties);
  properties2["token"] = this.get_config("token");
  if (event_name === "$snapshot") {
    var persistenceProps = this.persistence.properties();
    properties2["distinct_id"] = persistenceProps.distinct_id;
    return properties2;
  }
  if (!_.isUndefined(start_timestamp)) {
    var duration_in_ms = new Date().getTime() - start_timestamp;
    properties2["$duration"] = parseFloat((duration_in_ms / 1e3).toFixed(3));
  }
  if (this.sessionManager) {
    var _this$sessionManager$ = this.sessionManager.checkAndGetSessionAndWindowId(), sessionId = _this$sessionManager$.sessionId, windowId = _this$sessionManager$.windowId;
    properties2["$session_id"] = sessionId;
    properties2["$window_id"] = windowId;
  }
  properties2 = _.extend({}, _.info.properties(), this["persistence"].properties(), properties2);
  if (event_name === "$pageview" && this.get_config("_capture_performance")) {
    properties2 = _.extend(properties2, getPerformanceData());
  }
  var property_blacklist = this.get_config("property_blacklist");
  if (_.isArray(property_blacklist)) {
    _.each(property_blacklist, function(blacklisted_prop) {
      delete properties2[blacklisted_prop];
    });
  } else {
    console.error("Invalid value for property_blacklist config: " + property_blacklist);
  }
  var sanitize_properties = this.get_config("sanitize_properties");
  if (sanitize_properties) {
    properties2 = sanitize_properties(properties2, event_name);
  }
  return properties2;
};
PostHogLib.prototype.register = function(props, days) {
  this["persistence"].register(props, days);
};
PostHogLib.prototype.register_once = function(props, default_value, days) {
  this["persistence"].register_once(props, default_value, days);
};
PostHogLib.prototype.unregister = function(property) {
  this["persistence"].unregister(property);
};
PostHogLib.prototype._register_single = function(prop, value) {
  var props = {};
  props[prop] = value;
  this.register(props);
};
PostHogLib.prototype.getFeatureFlag = function(key) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return this.featureFlags.getFeatureFlag(key, options);
};
PostHogLib.prototype.isFeatureEnabled = function(key) {
  var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return this.featureFlags.isFeatureEnabled(key, options);
};
PostHogLib.prototype.reloadFeatureFlags = function() {
  return this.featureFlags.reloadFeatureFlags();
};
PostHogLib.prototype.onFeatureFlags = function(callback) {
  this.featureFlags.onFeatureFlags(callback);
};
PostHogLib.prototype.identify = function(new_distinct_id, userPropertiesToSet, userPropertiesToSetOnce) {
  if (!new_distinct_id) {
    console.error("Unique user id has not been set in posthog.identify");
    return;
  }
  this._captureMetrics.incr("identify");
  var previous_distinct_id = this.get_distinct_id();
  this.register({
    $user_id: new_distinct_id
  });
  if (!this.get_property("$device_id")) {
    var device_id = previous_distinct_id;
    this.register_once({
      $had_persisted_distinct_id: true,
      $device_id: device_id
    }, "");
  }
  if (new_distinct_id !== previous_distinct_id && new_distinct_id !== this.get_property(ALIAS_ID_KEY)) {
    this.unregister(ALIAS_ID_KEY);
    this.register({
      distinct_id: new_distinct_id
    });
  }
  if (new_distinct_id !== previous_distinct_id && (!this.get_property("$device_id") || previous_distinct_id === this.get_property("$device_id"))) {
    this.capture("$identify", {
      distinct_id: new_distinct_id,
      $anon_distinct_id: previous_distinct_id
    }, {
      $set: userPropertiesToSet || {}
    }, {
      $set_once: userPropertiesToSetOnce || {}
    });
    this.featureFlags.setAnonymousDistinctId(previous_distinct_id);
  } else {
    if (userPropertiesToSet) {
      this["people"].set(userPropertiesToSet);
    }
    if (userPropertiesToSetOnce) {
      this["people"].set_once(userPropertiesToSetOnce);
    }
  }
  if (new_distinct_id !== previous_distinct_id) {
    this.reloadFeatureFlags();
  }
};
PostHogLib.prototype.group = function(groupType, groupKey, groupPropertiesToSet) {
  if (!groupType || !groupKey) {
    console.error("posthog.group requires a group type and group key");
    return;
  }
  this._captureMetrics.incr("group");
  var existingGroups = this.getGroups();
  this.register({
    $groups: _objectSpread2(_objectSpread2({}, existingGroups), {}, _defineProperty({}, groupType, groupKey))
  });
  if (groupPropertiesToSet) {
    this.capture("$groupidentify", {
      $group_type: groupType,
      $group_key: groupKey,
      $group_set: groupPropertiesToSet
    });
  }
  if (existingGroups[groupType] !== groupKey) {
    this.reloadFeatureFlags();
  }
};
PostHogLib.prototype.reset = function(reset_device_id) {
  var device_id = this.get_property("$device_id");
  this["persistence"].clear();
  var uuid = this.get_config("get_device_id")(_.UUID());
  this.register_once({
    distinct_id: uuid,
    $device_id: reset_device_id ? uuid : device_id
  }, "");
};
PostHogLib.prototype.get_distinct_id = function() {
  return this.get_property("distinct_id");
};
PostHogLib.prototype.getGroups = function() {
  return this.get_property("$groups") || {};
};
PostHogLib.prototype.alias = function(alias, original) {
  if (alias === this.get_property(PEOPLE_DISTINCT_ID_KEY)) {
    console.critical("Attempting to create alias for existing People user - aborting.");
    return -2;
  }
  var _this = this;
  if (_.isUndefined(original)) {
    original = this.get_distinct_id();
  }
  if (alias !== original) {
    this._register_single(ALIAS_ID_KEY, alias);
    return this.capture("$create_alias", {
      alias,
      distinct_id: original
    }, function() {
      _this.identify(alias);
    });
  } else {
    console.error("alias matches current distinct_id - skipping api call.");
    this.identify(alias);
    return -1;
  }
};
PostHogLib.prototype.set_config = function(config) {
  var oldConfig = _objectSpread2({}, this.config);
  if (_.isObject(config)) {
    _.extend(this["config"], config);
    if (!this.get_config("persistence_name")) {
      this["config"]["persistence_name"] = this["config"]["cookie_name"];
    }
    if (!this.get_config("disable_persistence")) {
      this["config"]["disable_persistence"] = this["config"]["disable_cookie"];
    }
    if (this["persistence"]) {
      this["persistence"].update_config(this["config"]);
    }
    if (localStore.is_supported() && localStore.get("ph_debug") === "true") {
      this["config"]["debug"] = true;
    }
    Config$1.DEBUG = Config$1.DEBUG || this.get_config("debug");
    if (this.sessionRecording && typeof config.disable_session_recording !== "undefined") {
      if (oldConfig.disable_session_recording !== config.disable_session_recording) {
        if (config.disable_session_recording) {
          this.sessionRecording.stopRecording();
        } else {
          this.sessionRecording.startRecordingIfEnabled();
        }
      }
    }
  }
};
PostHogLib.prototype.startSessionRecording = function() {
  this.set_config({
    disable_session_recording: false
  });
};
PostHogLib.prototype.stopSessionRecording = function() {
  this.set_config({
    disable_session_recording: true
  });
};
PostHogLib.prototype.sessionRecordingStarted = function() {
  return this.sessionRecording.started();
};
PostHogLib.prototype.get_config = function(prop_name) {
  var _this$config;
  return (_this$config = this.config) === null || _this$config === void 0 ? void 0 : _this$config[prop_name];
};
PostHogLib.prototype.get_property = function(property_name) {
  return this["persistence"]["props"][property_name];
};
PostHogLib.prototype.toString = function() {
  var name = this.get_config("name");
  if (name !== PRIMARY_INSTANCE_NAME) {
    name = PRIMARY_INSTANCE_NAME + "." + name;
  }
  return name;
};
PostHogLib.prototype._gdpr_init = function() {
  var is_localStorage_requested = this.get_config("opt_out_capturing_persistence_type") === "localStorage";
  if (is_localStorage_requested && localStore.is_supported()) {
    if (!this.has_opted_in_capturing() && this.has_opted_in_capturing({
      persistence_type: "cookie"
    })) {
      this.opt_in_capturing({
        enable_persistence: false
      });
    }
    if (!this.has_opted_out_capturing() && this.has_opted_out_capturing({
      persistence_type: "cookie"
    })) {
      this.opt_out_capturing({
        clear_persistence: false
      });
    }
    this.clear_opt_in_out_capturing({
      persistence_type: "cookie",
      enable_persistence: false
    });
  }
  if (this.has_opted_out_capturing()) {
    this._gdpr_update_persistence({
      clear_persistence: true
    });
  } else if (!this.has_opted_in_capturing() && (this.get_config("opt_out_capturing_by_default") || cookieStore.get("ph_optout"))) {
    cookieStore.remove("ph_optout");
    this.opt_out_capturing({
      clear_persistence: this.get_config("opt_out_persistence_by_default")
    });
  }
};
PostHogLib.prototype._gdpr_update_persistence = function(options) {
  var disabled;
  if (options && options["clear_persistence"]) {
    disabled = true;
  } else if (options && options["enable_persistence"]) {
    disabled = false;
  } else {
    return;
  }
  if (!this.get_config("disable_persistence") && this["persistence"].disabled !== disabled) {
    this["persistence"].set_disabled(disabled);
  }
};
PostHogLib.prototype._gdpr_call_func = function(func, options) {
  options = _.extend({
    capture: _.bind(this.capture, this),
    persistence_type: this.get_config("opt_out_capturing_persistence_type"),
    cookie_prefix: this.get_config("opt_out_capturing_cookie_prefix"),
    cookie_expiration: this.get_config("cookie_expiration"),
    cross_subdomain_cookie: this.get_config("cross_subdomain_cookie"),
    secure_cookie: this.get_config("secure_cookie")
  }, options);
  if (!localStore.is_supported() && options["persistence_type"] === "localStorage") {
    options["persistence_type"] = "cookie";
  }
  return func(this.get_config("token"), {
    capture: options["capture"],
    captureEventName: options["capture_event_name"],
    captureProperties: options["capture_properties"],
    persistenceType: options["persistence_type"],
    persistencePrefix: options["cookie_prefix"],
    cookieExpiration: options["cookie_expiration"],
    crossSubdomainCookie: options["cross_subdomain_cookie"],
    secureCookie: options["secure_cookie"]
  });
};
PostHogLib.prototype.opt_in_capturing = function(options) {
  options = _.extend({
    enable_persistence: true
  }, options);
  this._gdpr_call_func(optIn, options);
  this._gdpr_update_persistence(options);
};
PostHogLib.prototype.opt_out_capturing = function(options) {
  options = _.extend({
    clear_persistence: true
  }, options);
  this._gdpr_call_func(optOut, options);
  this._gdpr_update_persistence(options);
};
PostHogLib.prototype.has_opted_in_capturing = function(options) {
  return this._gdpr_call_func(hasOptedIn, options);
};
PostHogLib.prototype.has_opted_out_capturing = function(options) {
  return this._gdpr_call_func(hasOptedOut, options);
};
PostHogLib.prototype.clear_opt_in_out_capturing = function(options) {
  options = _.extend({
    enable_persistence: true
  }, options);
  this._gdpr_call_func(clearOptInOut, options);
  this._gdpr_update_persistence(options);
};
PostHogLib.prototype.sentry_integration = function(_posthog, organization, projectId, prefix) {
  this.name = "posthog-js";
  this.setupOnce = function(addGlobalEventProcessor) {
    addGlobalEventProcessor(function(event) {
      if (event.level !== "error" || !_posthog.__loaded)
        return event;
      if (!event.tags)
        event.tags = {};
      event.tags["PostHog Person URL"] = _posthog.config.api_host + "/person/" + _posthog.get_distinct_id();
      if (_posthog.sessionRecordingStarted()) {
        event.tags["PostHog Recording URL"] = _posthog.config.api_host + "/recordings/#sessionRecordingId=" + _posthog.sessionManager.checkAndGetSessionAndWindowId(true).sessionId;
      }
      var data2 = {
        $sentry_event_id: event.event_id,
        $sentry_exception: event.exception
      };
      if (organization && projectId)
        data2["$sentry_url"] = (prefix || "https://sentry.io/organizations/") + organization + "/issues/?project=" + projectId + "&query=" + event.event_id;
      _posthog.capture("$exception", data2);
      return event;
    });
  };
};
PostHogLib.prototype.debug = function(debug2) {
  if (debug2 === false) {
    win.console.log("You've disabled debug mode.");
    localStorage && localStorage.setItem("ph_debug", void 0);
    this.set_config({
      debug: false
    });
  } else {
    win.console.log("You're now in debug mode. All calls to PostHog will be logged in your console.\nYou can disable this with `posthog.debug(false)`.");
    localStorage && localStorage.setItem("ph_debug", "true");
    this.set_config({
      debug: true
    });
  }
};
PostHogLib.prototype.decodeLZ64 = LZString.decompressFromBase64;
PostHogLib.prototype["init"] = PostHogLib.prototype.init;
PostHogLib.prototype["reset"] = PostHogLib.prototype.reset;
PostHogLib.prototype["capture"] = PostHogLib.prototype.capture;
PostHogLib.prototype["register"] = PostHogLib.prototype.register;
PostHogLib.prototype["register_once"] = PostHogLib.prototype.register_once;
PostHogLib.prototype["unregister"] = PostHogLib.prototype.unregister;
PostHogLib.prototype["identify"] = PostHogLib.prototype.identify;
PostHogLib.prototype["getGroups"] = PostHogLib.prototype.getGroups;
PostHogLib.prototype["group"] = PostHogLib.prototype.group;
PostHogLib.prototype["alias"] = PostHogLib.prototype.alias;
PostHogLib.prototype["set_config"] = PostHogLib.prototype.set_config;
PostHogLib.prototype["get_config"] = PostHogLib.prototype.get_config;
PostHogLib.prototype["get_property"] = PostHogLib.prototype.get_property;
PostHogLib.prototype["get_distinct_id"] = PostHogLib.prototype.get_distinct_id;
PostHogLib.prototype["toString"] = PostHogLib.prototype.toString;
PostHogLib.prototype["opt_out_captureing"] = PostHogLib.prototype.opt_out_captureing;
PostHogLib.prototype["opt_in_captureing"] = PostHogLib.prototype.opt_in_captureing;
PostHogLib.prototype["has_opted_out_captureing"] = PostHogLib.prototype.has_opted_out_captureing;
PostHogLib.prototype["has_opted_in_captureing"] = PostHogLib.prototype.has_opted_in_captureing;
PostHogLib.prototype["clear_opt_in_out_captureing"] = PostHogLib.prototype.clear_opt_in_out_captureing;
PostHogLib.prototype["opt_out_capturing"] = PostHogLib.prototype.opt_out_capturing;
PostHogLib.prototype["opt_in_capturing"] = PostHogLib.prototype.opt_in_capturing;
PostHogLib.prototype["has_opted_out_capturing"] = PostHogLib.prototype.has_opted_out_capturing;
PostHogLib.prototype["has_opted_in_capturing"] = PostHogLib.prototype.has_opted_in_capturing;
PostHogLib.prototype["clear_opt_in_out_capturing"] = PostHogLib.prototype.clear_opt_in_out_capturing;
PostHogLib.prototype["getFeatureFlag"] = PostHogLib.prototype.getFeatureFlag;
PostHogLib.prototype["isFeatureEnabled"] = PostHogLib.prototype.isFeatureEnabled;
PostHogLib.prototype["reloadFeatureFlags"] = PostHogLib.prototype.reloadFeatureFlags;
PostHogLib.prototype["onFeatureFlags"] = PostHogLib.prototype.onFeatureFlags;
PostHogLib.prototype["decodeLZ64"] = PostHogLib.prototype.decodeLZ64;
PostHogLib.prototype["SentryIntegration"] = PostHogLib.prototype.sentry_integration;
PostHogLib.prototype["debug"] = PostHogLib.prototype.debug;
PostHogLib.prototype["LIB_VERSION"] = Config$1.LIB_VERSION;
PostHogLib.prototype["startSessionRecording"] = PostHogLib.prototype.startSessionRecording;
PostHogLib.prototype["stopSessionRecording"] = PostHogLib.prototype.stopSessionRecording;
PostHogLib.prototype["sessionRecordingStarted"] = PostHogLib.prototype.sessionRecordingStarted;
PostHogPersistence.prototype["properties"] = PostHogPersistence.prototype.properties;
PostHogPersistence.prototype["update_search_keyword"] = PostHogPersistence.prototype.update_search_keyword;
PostHogPersistence.prototype["update_referrer_info"] = PostHogPersistence.prototype.update_referrer_info;
PostHogPersistence.prototype["get_cross_subdomain"] = PostHogPersistence.prototype.get_cross_subdomain;
PostHogPersistence.prototype["clear"] = PostHogPersistence.prototype.clear;
_.safewrap_class(PostHogLib, ["identify"]);
var instances = {};
var extend_mp = function extend_mp2() {
  _.each(instances, function(instance, name) {
    if (name !== PRIMARY_INSTANCE_NAME) {
      posthog_master[name] = instance;
    }
  });
  posthog_master["_"] = _;
};
var override_ph_init_func = function override_ph_init_func2() {
  posthog_master["init"] = function(token, config, name) {
    if (name) {
      if (!posthog_master[name]) {
        posthog_master[name] = instances[name] = create_mplib(token, config, name);
        posthog_master[name]._loaded();
      }
      return posthog_master[name];
    } else {
      var instance = posthog_master;
      if (instances[PRIMARY_INSTANCE_NAME]) {
        instance = instances[PRIMARY_INSTANCE_NAME];
      } else if (token) {
        instance = create_mplib(token, config, PRIMARY_INSTANCE_NAME);
        instance._loaded();
        instances[PRIMARY_INSTANCE_NAME] = instance;
      }
      posthog_master = instance;
      if (init_type === INIT_SNIPPET) {
        win[PRIMARY_INSTANCE_NAME] = posthog_master;
      }
      extend_mp();
    }
  };
};
var add_dom_loaded_handler = function add_dom_loaded_handler2() {
  function dom_loaded_handler() {
    if (dom_loaded_handler.done) {
      return;
    }
    dom_loaded_handler.done = true;
    ENQUEUE_REQUESTS = false;
    _.each(instances, function(inst) {
      inst._dom_loaded();
    });
  }
  function do_scroll_check() {
    try {
      document$1$1.documentElement.doScroll("left");
    } catch (e) {
      setTimeout(do_scroll_check, 1);
      return;
    }
    dom_loaded_handler();
  }
  if (document$1$1.addEventListener) {
    if (document$1$1.readyState === "complete") {
      dom_loaded_handler();
    } else {
      document$1$1.addEventListener("DOMContentLoaded", dom_loaded_handler, false);
    }
  } else if (document$1$1.attachEvent) {
    document$1$1.attachEvent("onreadystatechange", dom_loaded_handler);
    var toplevel = false;
    try {
      toplevel = win.frameElement === null;
    } catch (e) {
    }
    if (document$1$1.documentElement.doScroll && toplevel) {
      do_scroll_check();
    }
  }
  _.register_event(win, "load", dom_loaded_handler, true);
};
function init_as_module() {
  init_type = INIT_MODULE;
  posthog_master = new PostHogLib();
  override_ph_init_func();
  posthog_master["init"]();
  add_dom_loaded_handler();
  return posthog_master;
}
var posthog = init_as_module();
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x2) {
  return x2 && x2.__esModule && Object.prototype.hasOwnProperty.call(x2, "default") ? x2["default"] : x2;
}
var browser = { exports: {} };
var debug$1 = { exports: {} };
var s = 1e3;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;
var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === "string" && val.length > 0) {
    return parse(val);
  } else if (type === "number" && isNaN(val) === false) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    "val is not a non-empty string or a valid number. val=" + JSON.stringify(val)
  );
};
function parse(str2) {
  str2 = String(str2);
  if (str2.length > 100) {
    return;
  }
  var match2 = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(
    str2
  );
  if (!match2) {
    return;
  }
  var n = parseFloat(match2[1]);
  var type = (match2[2] || "ms").toLowerCase();
  switch (type) {
    case "years":
    case "year":
    case "yrs":
    case "yr":
    case "y":
      return n * y;
    case "days":
    case "day":
    case "d":
      return n * d;
    case "hours":
    case "hour":
    case "hrs":
    case "hr":
    case "h":
      return n * h;
    case "minutes":
    case "minute":
    case "mins":
    case "min":
    case "m":
      return n * m;
    case "seconds":
    case "second":
    case "secs":
    case "sec":
    case "s":
      return n * s;
    case "milliseconds":
    case "millisecond":
    case "msecs":
    case "msec":
    case "ms":
      return n;
    default:
      return void 0;
  }
}
function fmtShort(ms2) {
  if (ms2 >= d) {
    return Math.round(ms2 / d) + "d";
  }
  if (ms2 >= h) {
    return Math.round(ms2 / h) + "h";
  }
  if (ms2 >= m) {
    return Math.round(ms2 / m) + "m";
  }
  if (ms2 >= s) {
    return Math.round(ms2 / s) + "s";
  }
  return ms2 + "ms";
}
function fmtLong(ms2) {
  return plural(ms2, d, "day") || plural(ms2, h, "hour") || plural(ms2, m, "minute") || plural(ms2, s, "second") || ms2 + " ms";
}
function plural(ms2, n, name) {
  if (ms2 < n) {
    return;
  }
  if (ms2 < n * 1.5) {
    return Math.floor(ms2 / n) + " " + name;
  }
  return Math.ceil(ms2 / n) + " " + name + "s";
}
(function(module, exports) {
  exports = module.exports = createDebug.debug = createDebug["default"] = createDebug;
  exports.coerce = coerce;
  exports.disable = disable;
  exports.enable = enable;
  exports.enabled = enabled;
  exports.humanize = ms;
  exports.names = [];
  exports.skips = [];
  exports.formatters = {};
  var prevTime;
  function selectColor(namespace) {
    var hash = 0, i2;
    for (i2 in namespace) {
      hash = (hash << 5) - hash + namespace.charCodeAt(i2);
      hash |= 0;
    }
    return exports.colors[Math.abs(hash) % exports.colors.length];
  }
  function createDebug(namespace) {
    function debug2() {
      if (!debug2.enabled)
        return;
      var self2 = debug2;
      var curr = +new Date();
      var ms2 = curr - (prevTime || curr);
      self2.diff = ms2;
      self2.prev = prevTime;
      self2.curr = curr;
      prevTime = curr;
      var args = new Array(arguments.length);
      for (var i2 = 0; i2 < args.length; i2++) {
        args[i2] = arguments[i2];
      }
      args[0] = exports.coerce(args[0]);
      if ("string" !== typeof args[0]) {
        args.unshift("%O");
      }
      var index = 0;
      args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match2, format) {
        if (match2 === "%%")
          return match2;
        index++;
        var formatter = exports.formatters[format];
        if ("function" === typeof formatter) {
          var val = args[index];
          match2 = formatter.call(self2, val);
          args.splice(index, 1);
          index--;
        }
        return match2;
      });
      exports.formatArgs.call(self2, args);
      var logFn = debug2.log || exports.log || console.log.bind(console);
      logFn.apply(self2, args);
    }
    debug2.namespace = namespace;
    debug2.enabled = exports.enabled(namespace);
    debug2.useColors = exports.useColors();
    debug2.color = selectColor(namespace);
    if ("function" === typeof exports.init) {
      exports.init(debug2);
    }
    return debug2;
  }
  function enable(namespaces) {
    exports.save(namespaces);
    exports.names = [];
    exports.skips = [];
    var split2 = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
    var len = split2.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (!split2[i2])
        continue;
      namespaces = split2[i2].replace(/\*/g, ".*?");
      if (namespaces[0] === "-") {
        exports.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
      } else {
        exports.names.push(new RegExp("^" + namespaces + "$"));
      }
    }
  }
  function disable() {
    exports.enable("");
  }
  function enabled(name) {
    var i2, len;
    for (i2 = 0, len = exports.skips.length; i2 < len; i2++) {
      if (exports.skips[i2].test(name)) {
        return false;
      }
    }
    for (i2 = 0, len = exports.names.length; i2 < len; i2++) {
      if (exports.names[i2].test(name)) {
        return true;
      }
    }
    return false;
  }
  function coerce(val) {
    if (val instanceof Error)
      return val.stack || val.message;
    return val;
  }
})(debug$1, debug$1.exports);
(function(module, exports) {
  exports = module.exports = debug$1.exports;
  exports.log = log2;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = "undefined" != typeof chrome && "undefined" != typeof chrome.storage ? chrome.storage.local : localstorage();
  exports.colors = [
    "lightseagreen",
    "forestgreen",
    "goldenrod",
    "dodgerblue",
    "darkorchid",
    "crimson"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && window.process.type === "renderer") {
      return true;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  exports.formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (err) {
      return "[UnexpectedJSONParseError]: " + err.message;
    }
  };
  function formatArgs(args) {
    var useColors2 = this.useColors;
    args[0] = (useColors2 ? "%c" : "") + this.namespace + (useColors2 ? " %c" : " ") + args[0] + (useColors2 ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!useColors2)
      return;
    var c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    var index = 0;
    var lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, function(match2) {
      if ("%%" === match2)
        return;
      index++;
      if ("%c" === match2) {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  function log2() {
    return "object" === typeof console && console.log && Function.prototype.apply.call(console.log, console, arguments);
  }
  function save(namespaces) {
    try {
      if (null == namespaces) {
        exports.storage.removeItem("debug");
      } else {
        exports.storage.debug = namespaces;
      }
    } catch (e) {
    }
  }
  function load() {
    var r;
    try {
      r = exports.storage.debug;
    } catch (e) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = {}.DEBUG;
    }
    return r;
  }
  exports.enable(load());
  function localstorage() {
    try {
      return window.localStorage;
    } catch (e) {
    }
  }
})(browser, browser.exports);
const debug = browser.exports("FastMutex");
const randomId = () => Math.random() + "";
const resolveWithStats = (resolve, stats) => {
  const currentTime = new Date().getTime();
  stats.acquireEnd = currentTime;
  stats.acquireDuration = stats.acquireEnd - stats.acquireStart;
  stats.lockStart = currentTime;
  resolve(stats);
};
class FastMutex {
  constructor({ clientId = randomId(), xPrefix = "_MUTEX_LOCK_X_", yPrefix = "_MUTEX_LOCK_Y_", timeout = 5e3, localStorage: localStorage2 } = {}) {
    this.clientId = clientId;
    this.xPrefix = xPrefix;
    this.yPrefix = yPrefix;
    this.timeout = timeout;
    this.localStorage = localStorage2 || window.localStorage;
    this.resetStats();
  }
  lock(key) {
    debug('Attempting to acquire Lock on "%s" using FastMutex instance "%s"', key, this.clientId);
    const x2 = this.xPrefix + key;
    const y2 = this.yPrefix + key;
    this.resetStats();
    if (!this.lockStats.acquireStart) {
      this.lockStats.acquireStart = new Date().getTime();
    }
    return new Promise((resolve, reject) => {
      const acquireLock = (key2) => {
        const elapsedTime = new Date().getTime() - this.lockStats.acquireStart;
        if (elapsedTime >= this.timeout) {
          debug('Lock on "%s" could not be acquired within %sms by FastMutex client "%s"', key2, this.timeout, this.clientId);
          return reject(new Error(`Lock could not be acquired within ${this.timeout}ms`));
        }
        this.setItem(x2, this.clientId);
        let lsY = this.getItem(y2);
        if (lsY) {
          debug("Lock exists on Y (%s), restarting...", lsY);
          this.lockStats.restartCount++;
          setTimeout(() => acquireLock(key2));
          return;
        }
        this.setItem(y2, this.clientId);
        let lsX = this.getItem(x2);
        if (lsX !== this.clientId) {
          this.lockStats.contentionCount++;
          debug('Lock contention detected. X="%s"', lsX);
          setTimeout(() => {
            lsY = this.getItem(y2);
            if (lsY === this.clientId) {
              debug('FastMutex client "%s" won the lock contention on "%s"', this.clientId, key2);
              resolveWithStats(resolve, this.lockStats);
            } else {
              this.lockStats.restartCount++;
              this.lockStats.locksLost++;
              debug('FastMutex client "%s" lost the lock contention on "%s" to another process (%s). Restarting...', this.clientId, key2, lsY);
              setTimeout(() => acquireLock(key2));
            }
          }, 50);
          return;
        }
        debug('FastMutex client "%s" acquired a lock on "%s" with no contention', this.clientId, key2);
        resolveWithStats(resolve, this.lockStats);
      };
      acquireLock(key);
    });
  }
  release(key) {
    debug('FastMutex client "%s" is releasing lock on "%s"', this.clientId, key);
    const y2 = this.yPrefix + key;
    return new Promise((resolve) => {
      this.localStorage.removeItem(y2);
      this.lockStats.lockEnd = new Date().getTime();
      this.lockStats.lockDuration = this.lockStats.lockEnd - this.lockStats.lockStart;
      resolve(this.lockStats);
      this.resetStats();
    });
  }
  setItem(key, value) {
    return this.localStorage.setItem(key, JSON.stringify({
      expiresAt: new Date().getTime() + this.timeout,
      value
    }));
  }
  getItem(key) {
    const item = this.localStorage.getItem(key);
    if (!item)
      return null;
    const parsed = JSON.parse(item);
    if (new Date().getTime() - parsed.expiresAt >= this.timeout) {
      debug('FastMutex client "%s" removed an expired record on "%s"', this.clientId, key);
      this.localStorage.removeItem(key);
      return null;
    }
    return JSON.parse(item).value;
  }
  resetStats() {
    this.lockStats = {
      restartCount: 0,
      locksLost: 0,
      contentionCount: 0,
      acquireDuration: 0,
      acquireStart: null
    };
  }
}
var fastMutex = FastMutex;
const API_HOST = "https://events.datapane.com";
urlJoin(
  (_a2 = env.url) != null ? _a2 : "https://cloud.datapane.com/",
  "dp-kpis/"
);
const LOCK_NAME = "ph_datapane_store";
const mutex = new fastMutex();
const identifyUser = async (posthog2, userId) => {
  try {
    posthog2.identify(userId);
  } catch (e) {
    console.error("An analytics error occurred", e);
  }
};
const setupPostHog = async (apiKey, userId) => {
  try {
    await mutex.lock(LOCK_NAME);
    posthog.init(apiKey, {
      api_host: API_HOST,
      loaded: async (posthog2) => {
        window.posthog = posthog2;
        userId && await identifyUser(posthog2, userId);
        await mutex.release(LOCK_NAME);
      }
    });
  } catch (e) {
    console.error("Posthog setup error", e);
    await mutex.release(LOCK_NAME);
  }
};
var clipboard = { exports: {} };
/*!
 * clipboard.js v2.0.11
 * https://clipboardjs.com/
 *
 * Licensed MIT © Zeno Rocha
 */
(function(module, exports) {
  (function webpackUniversalModuleDefinition(root, factory) {
    module.exports = factory();
  })(commonjsGlobal, function() {
    return function() {
      var __webpack_modules__ = {
        686: function(__unused_webpack_module, __webpack_exports__, __webpack_require__2) {
          __webpack_require__2.d(__webpack_exports__, {
            "default": function() {
              return clipboard2;
            }
          });
          var tiny_emitter = __webpack_require__2(279);
          var tiny_emitter_default = /* @__PURE__ */ __webpack_require__2.n(tiny_emitter);
          var listen = __webpack_require__2(370);
          var listen_default = /* @__PURE__ */ __webpack_require__2.n(listen);
          var src_select = __webpack_require__2(817);
          var select_default = /* @__PURE__ */ __webpack_require__2.n(src_select);
          function command(type) {
            try {
              return document.execCommand(type);
            } catch (err) {
              return false;
            }
          }
          var ClipboardActionCut = function ClipboardActionCut2(target) {
            var selectedText = select_default()(target);
            command("cut");
            return selectedText;
          };
          var actions_cut = ClipboardActionCut;
          function createFakeElement(value) {
            var isRTL = document.documentElement.getAttribute("dir") === "rtl";
            var fakeElement = document.createElement("textarea");
            fakeElement.style.fontSize = "12pt";
            fakeElement.style.border = "0";
            fakeElement.style.padding = "0";
            fakeElement.style.margin = "0";
            fakeElement.style.position = "absolute";
            fakeElement.style[isRTL ? "right" : "left"] = "-9999px";
            var yPosition = window.pageYOffset || document.documentElement.scrollTop;
            fakeElement.style.top = "".concat(yPosition, "px");
            fakeElement.setAttribute("readonly", "");
            fakeElement.value = value;
            return fakeElement;
          }
          var fakeCopyAction = function fakeCopyAction2(value, options) {
            var fakeElement = createFakeElement(value);
            options.container.appendChild(fakeElement);
            var selectedText = select_default()(fakeElement);
            command("copy");
            fakeElement.remove();
            return selectedText;
          };
          var ClipboardActionCopy = function ClipboardActionCopy2(target) {
            var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
              container: document.body
            };
            var selectedText = "";
            if (typeof target === "string") {
              selectedText = fakeCopyAction(target, options);
            } else if (target instanceof HTMLInputElement && !["text", "search", "url", "tel", "password"].includes(target === null || target === void 0 ? void 0 : target.type)) {
              selectedText = fakeCopyAction(target.value, options);
            } else {
              selectedText = select_default()(target);
              command("copy");
            }
            return selectedText;
          };
          var actions_copy = ClipboardActionCopy;
          function _typeof2(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              _typeof2 = function _typeof3(obj2) {
                return typeof obj2;
              };
            } else {
              _typeof2 = function _typeof3(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return _typeof2(obj);
          }
          var ClipboardActionDefault = function ClipboardActionDefault2() {
            var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
            var _options$action = options.action, action = _options$action === void 0 ? "copy" : _options$action, container = options.container, target = options.target, text = options.text;
            if (action !== "copy" && action !== "cut") {
              throw new Error('Invalid "action" value, use either "copy" or "cut"');
            }
            if (target !== void 0) {
              if (target && _typeof2(target) === "object" && target.nodeType === 1) {
                if (action === "copy" && target.hasAttribute("disabled")) {
                  throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                }
                if (action === "cut" && (target.hasAttribute("readonly") || target.hasAttribute("disabled"))) {
                  throw new Error(`Invalid "target" attribute. You can't cut text from elements with "readonly" or "disabled" attributes`);
                }
              } else {
                throw new Error('Invalid "target" value, use a valid Element');
              }
            }
            if (text) {
              return actions_copy(text, {
                container
              });
            }
            if (target) {
              return action === "cut" ? actions_cut(target) : actions_copy(target, {
                container
              });
            }
          };
          var actions_default = ClipboardActionDefault;
          function clipboard_typeof(obj) {
            "@babel/helpers - typeof";
            if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
              clipboard_typeof = function _typeof3(obj2) {
                return typeof obj2;
              };
            } else {
              clipboard_typeof = function _typeof3(obj2) {
                return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
              };
            }
            return clipboard_typeof(obj);
          }
          function _classCallCheck2(instance, Constructor) {
            if (!(instance instanceof Constructor)) {
              throw new TypeError("Cannot call a class as a function");
            }
          }
          function _defineProperties2(target, props) {
            for (var i2 = 0; i2 < props.length; i2++) {
              var descriptor = props[i2];
              descriptor.enumerable = descriptor.enumerable || false;
              descriptor.configurable = true;
              if ("value" in descriptor)
                descriptor.writable = true;
              Object.defineProperty(target, descriptor.key, descriptor);
            }
          }
          function _createClass2(Constructor, protoProps, staticProps) {
            if (protoProps)
              _defineProperties2(Constructor.prototype, protoProps);
            if (staticProps)
              _defineProperties2(Constructor, staticProps);
            return Constructor;
          }
          function _inherits2(subClass, superClass) {
            if (typeof superClass !== "function" && superClass !== null) {
              throw new TypeError("Super expression must either be null or a function");
            }
            subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } });
            if (superClass)
              _setPrototypeOf2(subClass, superClass);
          }
          function _setPrototypeOf2(o, p) {
            _setPrototypeOf2 = Object.setPrototypeOf || function _setPrototypeOf3(o2, p2) {
              o2.__proto__ = p2;
              return o2;
            };
            return _setPrototypeOf2(o, p);
          }
          function _createSuper2(Derived) {
            var hasNativeReflectConstruct = _isNativeReflectConstruct2();
            return function _createSuperInternal() {
              var Super = _getPrototypeOf2(Derived), result;
              if (hasNativeReflectConstruct) {
                var NewTarget = _getPrototypeOf2(this).constructor;
                result = Reflect.construct(Super, arguments, NewTarget);
              } else {
                result = Super.apply(this, arguments);
              }
              return _possibleConstructorReturn2(this, result);
            };
          }
          function _possibleConstructorReturn2(self2, call2) {
            if (call2 && (clipboard_typeof(call2) === "object" || typeof call2 === "function")) {
              return call2;
            }
            return _assertThisInitialized2(self2);
          }
          function _assertThisInitialized2(self2) {
            if (self2 === void 0) {
              throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
            }
            return self2;
          }
          function _isNativeReflectConstruct2() {
            if (typeof Reflect === "undefined" || !Reflect.construct)
              return false;
            if (Reflect.construct.sham)
              return false;
            if (typeof Proxy === "function")
              return true;
            try {
              Date.prototype.toString.call(Reflect.construct(Date, [], function() {
              }));
              return true;
            } catch (e) {
              return false;
            }
          }
          function _getPrototypeOf2(o) {
            _getPrototypeOf2 = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf3(o2) {
              return o2.__proto__ || Object.getPrototypeOf(o2);
            };
            return _getPrototypeOf2(o);
          }
          function getAttributeValue2(suffix, element) {
            var attribute = "data-clipboard-".concat(suffix);
            if (!element.hasAttribute(attribute)) {
              return;
            }
            return element.getAttribute(attribute);
          }
          var Clipboard = /* @__PURE__ */ function(_Emitter) {
            _inherits2(Clipboard2, _Emitter);
            var _super = _createSuper2(Clipboard2);
            function Clipboard2(trigger, options) {
              var _this;
              _classCallCheck2(this, Clipboard2);
              _this = _super.call(this);
              _this.resolveOptions(options);
              _this.listenClick(trigger);
              return _this;
            }
            _createClass2(Clipboard2, [{
              key: "resolveOptions",
              value: function resolveOptions() {
                var options = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
                this.action = typeof options.action === "function" ? options.action : this.defaultAction;
                this.target = typeof options.target === "function" ? options.target : this.defaultTarget;
                this.text = typeof options.text === "function" ? options.text : this.defaultText;
                this.container = clipboard_typeof(options.container) === "object" ? options.container : document.body;
              }
            }, {
              key: "listenClick",
              value: function listenClick(trigger) {
                var _this2 = this;
                this.listener = listen_default()(trigger, "click", function(e) {
                  return _this2.onClick(e);
                });
              }
            }, {
              key: "onClick",
              value: function onClick(e) {
                var trigger = e.delegateTarget || e.currentTarget;
                var action = this.action(trigger) || "copy";
                var text = actions_default({
                  action,
                  container: this.container,
                  target: this.target(trigger),
                  text: this.text(trigger)
                });
                this.emit(text ? "success" : "error", {
                  action,
                  text,
                  trigger,
                  clearSelection: function clearSelection() {
                    if (trigger) {
                      trigger.focus();
                    }
                    window.getSelection().removeAllRanges();
                  }
                });
              }
            }, {
              key: "defaultAction",
              value: function defaultAction(trigger) {
                return getAttributeValue2("action", trigger);
              }
            }, {
              key: "defaultTarget",
              value: function defaultTarget(trigger) {
                var selector = getAttributeValue2("target", trigger);
                if (selector) {
                  return document.querySelector(selector);
                }
              }
            }, {
              key: "defaultText",
              value: function defaultText(trigger) {
                return getAttributeValue2("text", trigger);
              }
            }, {
              key: "destroy",
              value: function destroy() {
                this.listener.destroy();
              }
            }], [{
              key: "copy",
              value: function copy(target) {
                var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
                  container: document.body
                };
                return actions_copy(target, options);
              }
            }, {
              key: "cut",
              value: function cut(target) {
                return actions_cut(target);
              }
            }, {
              key: "isSupported",
              value: function isSupported() {
                var action = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : ["copy", "cut"];
                var actions = typeof action === "string" ? [action] : action;
                var support2 = !!document.queryCommandSupported;
                actions.forEach(function(action2) {
                  support2 = support2 && !!document.queryCommandSupported(action2);
                });
                return support2;
              }
            }]);
            return Clipboard2;
          }(tiny_emitter_default());
          var clipboard2 = Clipboard;
        },
        828: function(module2) {
          var DOCUMENT_NODE_TYPE = 9;
          if (typeof Element !== "undefined" && !Element.prototype.matches) {
            var proto = Element.prototype;
            proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
          }
          function closest2(element, selector) {
            while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
              if (typeof element.matches === "function" && element.matches(selector)) {
                return element;
              }
              element = element.parentNode;
            }
          }
          module2.exports = closest2;
        },
        438: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var closest2 = __webpack_require__2(828);
          function _delegate(element, selector, type, callback, useCapture) {
            var listenerFn = listener.apply(this, arguments);
            element.addEventListener(type, listenerFn, useCapture);
            return {
              destroy: function() {
                element.removeEventListener(type, listenerFn, useCapture);
              }
            };
          }
          function delegate(elements, selector, type, callback, useCapture) {
            if (typeof elements.addEventListener === "function") {
              return _delegate.apply(null, arguments);
            }
            if (typeof type === "function") {
              return _delegate.bind(null, document).apply(null, arguments);
            }
            if (typeof elements === "string") {
              elements = document.querySelectorAll(elements);
            }
            return Array.prototype.map.call(elements, function(element) {
              return _delegate(element, selector, type, callback, useCapture);
            });
          }
          function listener(element, selector, type, callback) {
            return function(e) {
              e.delegateTarget = closest2(e.target, selector);
              if (e.delegateTarget) {
                callback.call(element, e);
              }
            };
          }
          module2.exports = delegate;
        },
        879: function(__unused_webpack_module, exports2) {
          exports2.node = function(value) {
            return value !== void 0 && value instanceof HTMLElement && value.nodeType === 1;
          };
          exports2.nodeList = function(value) {
            var type = Object.prototype.toString.call(value);
            return value !== void 0 && (type === "[object NodeList]" || type === "[object HTMLCollection]") && "length" in value && (value.length === 0 || exports2.node(value[0]));
          };
          exports2.string = function(value) {
            return typeof value === "string" || value instanceof String;
          };
          exports2.fn = function(value) {
            var type = Object.prototype.toString.call(value);
            return type === "[object Function]";
          };
        },
        370: function(module2, __unused_webpack_exports, __webpack_require__2) {
          var is = __webpack_require__2(879);
          var delegate = __webpack_require__2(438);
          function listen(target, type, callback) {
            if (!target && !type && !callback) {
              throw new Error("Missing required arguments");
            }
            if (!is.string(type)) {
              throw new TypeError("Second argument must be a String");
            }
            if (!is.fn(callback)) {
              throw new TypeError("Third argument must be a Function");
            }
            if (is.node(target)) {
              return listenNode(target, type, callback);
            } else if (is.nodeList(target)) {
              return listenNodeList(target, type, callback);
            } else if (is.string(target)) {
              return listenSelector(target, type, callback);
            } else {
              throw new TypeError("First argument must be a String, HTMLElement, HTMLCollection, or NodeList");
            }
          }
          function listenNode(node, type, callback) {
            node.addEventListener(type, callback);
            return {
              destroy: function() {
                node.removeEventListener(type, callback);
              }
            };
          }
          function listenNodeList(nodeList, type, callback) {
            Array.prototype.forEach.call(nodeList, function(node) {
              node.addEventListener(type, callback);
            });
            return {
              destroy: function() {
                Array.prototype.forEach.call(nodeList, function(node) {
                  node.removeEventListener(type, callback);
                });
              }
            };
          }
          function listenSelector(selector, type, callback) {
            return delegate(document.body, selector, type, callback);
          }
          module2.exports = listen;
        },
        817: function(module2) {
          function select(element) {
            var selectedText;
            if (element.nodeName === "SELECT") {
              element.focus();
              selectedText = element.value;
            } else if (element.nodeName === "INPUT" || element.nodeName === "TEXTAREA") {
              var isReadOnly = element.hasAttribute("readonly");
              if (!isReadOnly) {
                element.setAttribute("readonly", "");
              }
              element.select();
              element.setSelectionRange(0, element.value.length);
              if (!isReadOnly) {
                element.removeAttribute("readonly");
              }
              selectedText = element.value;
            } else {
              if (element.hasAttribute("contenteditable")) {
                element.focus();
              }
              var selection = window.getSelection();
              var range = document.createRange();
              range.selectNodeContents(element);
              selection.removeAllRanges();
              selection.addRange(range);
              selectedText = selection.toString();
            }
            return selectedText;
          }
          module2.exports = select;
        },
        279: function(module2) {
          function E() {
          }
          E.prototype = {
            on: function(name, callback, ctx) {
              var e = this.e || (this.e = {});
              (e[name] || (e[name] = [])).push({
                fn: callback,
                ctx
              });
              return this;
            },
            once: function(name, callback, ctx) {
              var self2 = this;
              function listener() {
                self2.off(name, listener);
                callback.apply(ctx, arguments);
              }
              listener._ = callback;
              return this.on(name, listener, ctx);
            },
            emit: function(name) {
              var data2 = [].slice.call(arguments, 1);
              var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
              var i2 = 0;
              var len = evtArr.length;
              for (i2; i2 < len; i2++) {
                evtArr[i2].fn.apply(evtArr[i2].ctx, data2);
              }
              return this;
            },
            off: function(name, callback) {
              var e = this.e || (this.e = {});
              var evts = e[name];
              var liveEvents = [];
              if (evts && callback) {
                for (var i2 = 0, len = evts.length; i2 < len; i2++) {
                  if (evts[i2].fn !== callback && evts[i2].fn._ !== callback)
                    liveEvents.push(evts[i2]);
                }
              }
              liveEvents.length ? e[name] = liveEvents : delete e[name];
              return this;
            }
          };
          module2.exports = E;
          module2.exports.TinyEmitter = E;
        }
      };
      var __webpack_module_cache__ = {};
      function __webpack_require__(moduleId) {
        if (__webpack_module_cache__[moduleId]) {
          return __webpack_module_cache__[moduleId].exports;
        }
        var module2 = __webpack_module_cache__[moduleId] = {
          exports: {}
        };
        __webpack_modules__[moduleId](module2, module2.exports, __webpack_require__);
        return module2.exports;
      }
      !function() {
        __webpack_require__.n = function(module2) {
          var getter = module2 && module2.__esModule ? function() {
            return module2["default"];
          } : function() {
            return module2;
          };
          __webpack_require__.d(getter, { a: getter });
          return getter;
        };
      }();
      !function() {
        __webpack_require__.d = function(exports2, definition) {
          for (var key in definition) {
            if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports2, key)) {
              Object.defineProperty(exports2, key, { enumerable: true, get: definition[key] });
            }
          }
        };
      }();
      !function() {
        __webpack_require__.o = function(obj, prop) {
          return Object.prototype.hasOwnProperty.call(obj, prop);
        };
      }();
      return __webpack_require__(686);
    }().default;
  });
})(clipboard);
var ClipboardJS = /* @__PURE__ */ getDefaultExportFromCjs(clipboard.exports);
const _DPClipboard = class {
  constructor(btn, options) {
    __publicField(this, "clip");
    this.clip = new ClipboardJS(btn, {
      text() {
        const textToCopy = options.text ? options.text : _DPClipboard.getFieldValue(options.fieldId);
        return textToCopy;
      }
    });
    this.clip.on(
      "error",
      () => console.error("An error occurred while copying to clipboard")
    );
    this.clip.on("success", _DPClipboard.onSuccess);
  }
  destroy() {
    this.clip.destroy();
  }
  static getFieldValue(fieldId) {
    const field = document.querySelector(`#${fieldId}`);
    if (!field) {
      throw `Field with ID ${fieldId} not found`;
    }
    return field.value;
  }
  static async copyOnce(text) {
    try {
      await navigator.clipboard.writeText(text);
      _DPClipboard.onSuccess();
    } catch (e) {
      console.error("Error copying to clipboard: ", e);
    }
  }
};
let DPClipboard = _DPClipboard;
__publicField(DPClipboard, "onSuccess", () => {
  window.Alpine && window.Alpine.store("copy").toggle();
});
var global$d = typeof globalThis !== "undefined" && globalThis || typeof self !== "undefined" && self || typeof global$d !== "undefined" && global$d;
var support = {
  searchParams: "URLSearchParams" in global$d,
  iterable: "Symbol" in global$d && "iterator" in Symbol,
  blob: "FileReader" in global$d && "Blob" in global$d && function() {
    try {
      new Blob();
      return true;
    } catch (e) {
      return false;
    }
  }(),
  formData: "FormData" in global$d,
  arrayBuffer: "ArrayBuffer" in global$d
};
function isDataView(obj) {
  return obj && DataView.prototype.isPrototypeOf(obj);
}
if (support.arrayBuffer) {
  var viewClasses = [
    "[object Int8Array]",
    "[object Uint8Array]",
    "[object Uint8ClampedArray]",
    "[object Int16Array]",
    "[object Uint16Array]",
    "[object Int32Array]",
    "[object Uint32Array]",
    "[object Float32Array]",
    "[object Float64Array]"
  ];
  var isArrayBufferView = ArrayBuffer.isView || function(obj) {
    return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
  };
}
function normalizeName(name) {
  if (typeof name !== "string") {
    name = String(name);
  }
  if (/[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(name) || name === "") {
    throw new TypeError('Invalid character in header field name: "' + name + '"');
  }
  return name.toLowerCase();
}
function normalizeValue(value) {
  if (typeof value !== "string") {
    value = String(value);
  }
  return value;
}
function iteratorFor(items) {
  var iterator = {
    next: function() {
      var value = items.shift();
      return { done: value === void 0, value };
    }
  };
  if (support.iterable) {
    iterator[Symbol.iterator] = function() {
      return iterator;
    };
  }
  return iterator;
}
function Headers(headers) {
  this.map = {};
  if (headers instanceof Headers) {
    headers.forEach(function(value, name) {
      this.append(name, value);
    }, this);
  } else if (Array.isArray(headers)) {
    headers.forEach(function(header) {
      this.append(header[0], header[1]);
    }, this);
  } else if (headers) {
    Object.getOwnPropertyNames(headers).forEach(function(name) {
      this.append(name, headers[name]);
    }, this);
  }
}
Headers.prototype.append = function(name, value) {
  name = normalizeName(name);
  value = normalizeValue(value);
  var oldValue = this.map[name];
  this.map[name] = oldValue ? oldValue + ", " + value : value;
};
Headers.prototype["delete"] = function(name) {
  delete this.map[normalizeName(name)];
};
Headers.prototype.get = function(name) {
  name = normalizeName(name);
  return this.has(name) ? this.map[name] : null;
};
Headers.prototype.has = function(name) {
  return this.map.hasOwnProperty(normalizeName(name));
};
Headers.prototype.set = function(name, value) {
  this.map[normalizeName(name)] = normalizeValue(value);
};
Headers.prototype.forEach = function(callback, thisArg) {
  for (var name in this.map) {
    if (this.map.hasOwnProperty(name)) {
      callback.call(thisArg, this.map[name], name, this);
    }
  }
};
Headers.prototype.keys = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push(name);
  });
  return iteratorFor(items);
};
Headers.prototype.values = function() {
  var items = [];
  this.forEach(function(value) {
    items.push(value);
  });
  return iteratorFor(items);
};
Headers.prototype.entries = function() {
  var items = [];
  this.forEach(function(value, name) {
    items.push([name, value]);
  });
  return iteratorFor(items);
};
if (support.iterable) {
  Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
}
function consumed(body) {
  if (body.bodyUsed) {
    return Promise.reject(new TypeError("Already read"));
  }
  body.bodyUsed = true;
}
function fileReaderReady(reader) {
  return new Promise(function(resolve, reject) {
    reader.onload = function() {
      resolve(reader.result);
    };
    reader.onerror = function() {
      reject(reader.error);
    };
  });
}
function readBlobAsArrayBuffer(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsArrayBuffer(blob);
  return promise;
}
function readBlobAsText(blob) {
  var reader = new FileReader();
  var promise = fileReaderReady(reader);
  reader.readAsText(blob);
  return promise;
}
function readArrayBufferAsText(buf) {
  var view = new Uint8Array(buf);
  var chars = new Array(view.length);
  for (var i2 = 0; i2 < view.length; i2++) {
    chars[i2] = String.fromCharCode(view[i2]);
  }
  return chars.join("");
}
function bufferClone(buf) {
  if (buf.slice) {
    return buf.slice(0);
  } else {
    var view = new Uint8Array(buf.byteLength);
    view.set(new Uint8Array(buf));
    return view.buffer;
  }
}
function Body() {
  this.bodyUsed = false;
  this._initBody = function(body) {
    this.bodyUsed = this.bodyUsed;
    this._bodyInit = body;
    if (!body) {
      this._bodyText = "";
    } else if (typeof body === "string") {
      this._bodyText = body;
    } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
      this._bodyBlob = body;
    } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
      this._bodyFormData = body;
    } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
      this._bodyText = body.toString();
    } else if (support.arrayBuffer && support.blob && isDataView(body)) {
      this._bodyArrayBuffer = bufferClone(body.buffer);
      this._bodyInit = new Blob([this._bodyArrayBuffer]);
    } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
      this._bodyArrayBuffer = bufferClone(body);
    } else {
      this._bodyText = body = Object.prototype.toString.call(body);
    }
    if (!this.headers.get("content-type")) {
      if (typeof body === "string") {
        this.headers.set("content-type", "text/plain;charset=UTF-8");
      } else if (this._bodyBlob && this._bodyBlob.type) {
        this.headers.set("content-type", this._bodyBlob.type);
      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
        this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8");
      }
    }
  };
  if (support.blob) {
    this.blob = function() {
      var rejected = consumed(this);
      if (rejected) {
        return rejected;
      }
      if (this._bodyBlob) {
        return Promise.resolve(this._bodyBlob);
      } else if (this._bodyArrayBuffer) {
        return Promise.resolve(new Blob([this._bodyArrayBuffer]));
      } else if (this._bodyFormData) {
        throw new Error("could not read FormData body as blob");
      } else {
        return Promise.resolve(new Blob([this._bodyText]));
      }
    };
    this.arrayBuffer = function() {
      if (this._bodyArrayBuffer) {
        var isConsumed = consumed(this);
        if (isConsumed) {
          return isConsumed;
        }
        if (ArrayBuffer.isView(this._bodyArrayBuffer)) {
          return Promise.resolve(
            this._bodyArrayBuffer.buffer.slice(
              this._bodyArrayBuffer.byteOffset,
              this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength
            )
          );
        } else {
          return Promise.resolve(this._bodyArrayBuffer);
        }
      } else {
        return this.blob().then(readBlobAsArrayBuffer);
      }
    };
  }
  this.text = function() {
    var rejected = consumed(this);
    if (rejected) {
      return rejected;
    }
    if (this._bodyBlob) {
      return readBlobAsText(this._bodyBlob);
    } else if (this._bodyArrayBuffer) {
      return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
    } else if (this._bodyFormData) {
      throw new Error("could not read FormData body as text");
    } else {
      return Promise.resolve(this._bodyText);
    }
  };
  if (support.formData) {
    this.formData = function() {
      return this.text().then(decode);
    };
  }
  this.json = function() {
    return this.text().then(JSON.parse);
  };
  return this;
}
var methods = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
function normalizeMethod(method) {
  var upcased = method.toUpperCase();
  return methods.indexOf(upcased) > -1 ? upcased : method;
}
function Request(input, options) {
  if (!(this instanceof Request)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  options = options || {};
  var body = options.body;
  if (input instanceof Request) {
    if (input.bodyUsed) {
      throw new TypeError("Already read");
    }
    this.url = input.url;
    this.credentials = input.credentials;
    if (!options.headers) {
      this.headers = new Headers(input.headers);
    }
    this.method = input.method;
    this.mode = input.mode;
    this.signal = input.signal;
    if (!body && input._bodyInit != null) {
      body = input._bodyInit;
      input.bodyUsed = true;
    }
  } else {
    this.url = String(input);
  }
  this.credentials = options.credentials || this.credentials || "same-origin";
  if (options.headers || !this.headers) {
    this.headers = new Headers(options.headers);
  }
  this.method = normalizeMethod(options.method || this.method || "GET");
  this.mode = options.mode || this.mode || null;
  this.signal = options.signal || this.signal;
  this.referrer = null;
  if ((this.method === "GET" || this.method === "HEAD") && body) {
    throw new TypeError("Body not allowed for GET or HEAD requests");
  }
  this._initBody(body);
  if (this.method === "GET" || this.method === "HEAD") {
    if (options.cache === "no-store" || options.cache === "no-cache") {
      var reParamSearch = /([?&])_=[^&]*/;
      if (reParamSearch.test(this.url)) {
        this.url = this.url.replace(reParamSearch, "$1_=" + new Date().getTime());
      } else {
        var reQueryString = /\?/;
        this.url += (reQueryString.test(this.url) ? "&" : "?") + "_=" + new Date().getTime();
      }
    }
  }
}
Request.prototype.clone = function() {
  return new Request(this, { body: this._bodyInit });
};
function decode(body) {
  var form = new FormData();
  body.trim().split("&").forEach(function(bytes) {
    if (bytes) {
      var split2 = bytes.split("=");
      var name = split2.shift().replace(/\+/g, " ");
      var value = split2.join("=").replace(/\+/g, " ");
      form.append(decodeURIComponent(name), decodeURIComponent(value));
    }
  });
  return form;
}
function parseHeaders(rawHeaders) {
  var headers = new Headers();
  var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, " ");
  preProcessedHeaders.split("\r").map(function(header) {
    return header.indexOf("\n") === 0 ? header.substr(1, header.length) : header;
  }).forEach(function(line) {
    var parts = line.split(":");
    var key = parts.shift().trim();
    if (key) {
      var value = parts.join(":").trim();
      headers.append(key, value);
    }
  });
  return headers;
}
Body.call(Request.prototype);
function Response(bodyInit, options) {
  if (!(this instanceof Response)) {
    throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
  }
  if (!options) {
    options = {};
  }
  this.type = "default";
  this.status = options.status === void 0 ? 200 : options.status;
  this.ok = this.status >= 200 && this.status < 300;
  this.statusText = options.statusText === void 0 ? "" : "" + options.statusText;
  this.headers = new Headers(options.headers);
  this.url = options.url || "";
  this._initBody(bodyInit);
}
Body.call(Response.prototype);
Response.prototype.clone = function() {
  return new Response(this._bodyInit, {
    status: this.status,
    statusText: this.statusText,
    headers: new Headers(this.headers),
    url: this.url
  });
};
Response.error = function() {
  var response = new Response(null, { status: 0, statusText: "" });
  response.type = "error";
  return response;
};
var redirectStatuses = [301, 302, 303, 307, 308];
Response.redirect = function(url, status) {
  if (redirectStatuses.indexOf(status) === -1) {
    throw new RangeError("Invalid status code");
  }
  return new Response(null, { status, headers: { location: url } });
};
var DOMException = global$d.DOMException;
try {
  new DOMException();
} catch (err) {
  DOMException = function(message, name) {
    this.message = message;
    this.name = name;
    var error6 = Error(message);
    this.stack = error6.stack;
  };
  DOMException.prototype = Object.create(Error.prototype);
  DOMException.prototype.constructor = DOMException;
}
function fetch(input, init2) {
  return new Promise(function(resolve, reject) {
    var request = new Request(input, init2);
    if (request.signal && request.signal.aborted) {
      return reject(new DOMException("Aborted", "AbortError"));
    }
    var xhr3 = new XMLHttpRequest();
    function abortXhr() {
      xhr3.abort();
    }
    xhr3.onload = function() {
      var options = {
        status: xhr3.status,
        statusText: xhr3.statusText,
        headers: parseHeaders(xhr3.getAllResponseHeaders() || "")
      };
      options.url = "responseURL" in xhr3 ? xhr3.responseURL : options.headers.get("X-Request-URL");
      var body = "response" in xhr3 ? xhr3.response : xhr3.responseText;
      setTimeout(function() {
        resolve(new Response(body, options));
      }, 0);
    };
    xhr3.onerror = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr3.ontimeout = function() {
      setTimeout(function() {
        reject(new TypeError("Network request failed"));
      }, 0);
    };
    xhr3.onabort = function() {
      setTimeout(function() {
        reject(new DOMException("Aborted", "AbortError"));
      }, 0);
    };
    function fixUrl(url) {
      try {
        return url === "" && global$d.location.href ? global$d.location.href : url;
      } catch (e) {
        return url;
      }
    }
    xhr3.open(request.method, fixUrl(request.url), true);
    if (request.credentials === "include") {
      xhr3.withCredentials = true;
    } else if (request.credentials === "omit") {
      xhr3.withCredentials = false;
    }
    if ("responseType" in xhr3) {
      if (support.blob) {
        xhr3.responseType = "blob";
      } else if (support.arrayBuffer && request.headers.get("Content-Type") && request.headers.get("Content-Type").indexOf("application/octet-stream") !== -1) {
        xhr3.responseType = "arraybuffer";
      }
    }
    if (init2 && typeof init2.headers === "object" && !(init2.headers instanceof Headers)) {
      Object.getOwnPropertyNames(init2.headers).forEach(function(name) {
        xhr3.setRequestHeader(name, normalizeValue(init2.headers[name]));
      });
    } else {
      request.headers.forEach(function(value, name) {
        xhr3.setRequestHeader(name, value);
      });
    }
    if (request.signal) {
      request.signal.addEventListener("abort", abortXhr);
      xhr3.onreadystatechange = function() {
        if (xhr3.readyState === 4) {
          request.signal.removeEventListener("abort", abortXhr);
        }
      };
    }
    xhr3.send(typeof request._bodyInit === "undefined" ? null : request._bodyInit);
  });
}
fetch.polyfill = true;
if (!global$d.fetch) {
  global$d.fetch = fetch;
  global$d.Headers = Headers;
  global$d.Request = Request;
  global$d.Response = Response;
}
var check = function(it) {
  return it && it.Math == Math && it;
};
var global$c = check(typeof globalThis == "object" && globalThis) || check(typeof window == "object" && window) || check(typeof self == "object" && self) || check(typeof commonjsGlobal == "object" && commonjsGlobal) || function() {
  return this;
}() || Function("return this")();
var objectGetOwnPropertyDescriptor = {};
var fails$9 = function(exec2) {
  try {
    return !!exec2();
  } catch (error6) {
    return true;
  }
};
var fails$8 = fails$9;
var descriptors = !fails$8(function() {
  return Object.defineProperty({}, 1, { get: function() {
    return 7;
  } })[1] != 7;
});
var fails$7 = fails$9;
var functionBindNative = !fails$7(function() {
  var test2 = function() {
  }.bind();
  return typeof test2 != "function" || test2.hasOwnProperty("prototype");
});
var NATIVE_BIND$2 = functionBindNative;
var call$4 = Function.prototype.call;
var functionCall = NATIVE_BIND$2 ? call$4.bind(call$4) : function() {
  return call$4.apply(call$4, arguments);
};
var objectPropertyIsEnumerable = {};
var $propertyIsEnumerable$1 = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !$propertyIsEnumerable$1.call({ 1: 2 }, 1);
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable2(V) {
  var descriptor = getOwnPropertyDescriptor$1(this, V);
  return !!descriptor && descriptor.enumerable;
} : $propertyIsEnumerable$1;
var createPropertyDescriptor$2 = function(bitmap, value) {
  return {
    enumerable: !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable: !(bitmap & 4),
    value
  };
};
var NATIVE_BIND$1 = functionBindNative;
var FunctionPrototype$1 = Function.prototype;
var bind$2 = FunctionPrototype$1.bind;
var call$3 = FunctionPrototype$1.call;
var uncurryThis$d = NATIVE_BIND$1 && bind$2.bind(call$3, call$3);
var functionUncurryThis = NATIVE_BIND$1 ? function(fn) {
  return fn && uncurryThis$d(fn);
} : function(fn) {
  return fn && function() {
    return call$3.apply(fn, arguments);
  };
};
var uncurryThis$c = functionUncurryThis;
var toString$1 = uncurryThis$c({}.toString);
var stringSlice = uncurryThis$c("".slice);
var classofRaw$1 = function(it) {
  return stringSlice(toString$1(it), 8, -1);
};
var uncurryThis$b = functionUncurryThis;
var fails$6 = fails$9;
var classof$3 = classofRaw$1;
var $Object$3 = Object;
var split = uncurryThis$b("".split);
var indexedObject = fails$6(function() {
  return !$Object$3("z").propertyIsEnumerable(0);
}) ? function(it) {
  return classof$3(it) == "String" ? split(it, "") : $Object$3(it);
} : $Object$3;
var $TypeError$6 = TypeError;
var requireObjectCoercible$2 = function(it) {
  if (it == void 0)
    throw $TypeError$6("Can't call method on " + it);
  return it;
};
var IndexedObject = indexedObject;
var requireObjectCoercible$1 = requireObjectCoercible$2;
var toIndexedObject$5 = function(it) {
  return IndexedObject(requireObjectCoercible$1(it));
};
var isCallable$c = function(argument) {
  return typeof argument == "function";
};
var isCallable$b = isCallable$c;
var isObject$6 = function(it) {
  return typeof it == "object" ? it !== null : isCallable$b(it);
};
var global$b = global$c;
var isCallable$a = isCallable$c;
var aFunction = function(argument) {
  return isCallable$a(argument) ? argument : void 0;
};
var getBuiltIn$5 = function(namespace, method) {
  return arguments.length < 2 ? aFunction(global$b[namespace]) : global$b[namespace] && global$b[namespace][method];
};
var uncurryThis$a = functionUncurryThis;
var objectIsPrototypeOf = uncurryThis$a({}.isPrototypeOf);
var getBuiltIn$4 = getBuiltIn$5;
var engineUserAgent = getBuiltIn$4("navigator", "userAgent") || "";
var global$a = global$c;
var userAgent = engineUserAgent;
var process$1 = global$a.process;
var Deno = global$a.Deno;
var versions = process$1 && process$1.versions || Deno && Deno.version;
var v8 = versions && versions.v8;
var match, version;
if (v8) {
  match = v8.split(".");
  version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);
}
if (!version && userAgent) {
  match = userAgent.match(/Edge\/(\d+)/);
  if (!match || match[1] >= 74) {
    match = userAgent.match(/Chrome\/(\d+)/);
    if (match)
      version = +match[1];
  }
}
var engineV8Version = version;
var V8_VERSION = engineV8Version;
var fails$5 = fails$9;
var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$5(function() {
  var symbol = Symbol();
  return !String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;
});
var NATIVE_SYMBOL$1 = nativeSymbol;
var useSymbolAsUid = NATIVE_SYMBOL$1 && !Symbol.sham && typeof Symbol.iterator == "symbol";
var getBuiltIn$3 = getBuiltIn$5;
var isCallable$9 = isCallable$c;
var isPrototypeOf = objectIsPrototypeOf;
var USE_SYMBOL_AS_UID$1 = useSymbolAsUid;
var $Object$2 = Object;
var isSymbol$2 = USE_SYMBOL_AS_UID$1 ? function(it) {
  return typeof it == "symbol";
} : function(it) {
  var $Symbol = getBuiltIn$3("Symbol");
  return isCallable$9($Symbol) && isPrototypeOf($Symbol.prototype, $Object$2(it));
};
var $String$1 = String;
var tryToString$1 = function(argument) {
  try {
    return $String$1(argument);
  } catch (error6) {
    return "Object";
  }
};
var isCallable$8 = isCallable$c;
var tryToString = tryToString$1;
var $TypeError$5 = TypeError;
var aCallable$3 = function(argument) {
  if (isCallable$8(argument))
    return argument;
  throw $TypeError$5(tryToString(argument) + " is not a function");
};
var aCallable$2 = aCallable$3;
var getMethod$1 = function(V, P) {
  var func = V[P];
  return func == null ? void 0 : aCallable$2(func);
};
var call$2 = functionCall;
var isCallable$7 = isCallable$c;
var isObject$5 = isObject$6;
var $TypeError$4 = TypeError;
var ordinaryToPrimitive$1 = function(input, pref) {
  var fn, val;
  if (pref === "string" && isCallable$7(fn = input.toString) && !isObject$5(val = call$2(fn, input)))
    return val;
  if (isCallable$7(fn = input.valueOf) && !isObject$5(val = call$2(fn, input)))
    return val;
  if (pref !== "string" && isCallable$7(fn = input.toString) && !isObject$5(val = call$2(fn, input)))
    return val;
  throw $TypeError$4("Can't convert object to primitive value");
};
var shared$3 = { exports: {} };
var global$9 = global$c;
var defineProperty$2 = Object.defineProperty;
var defineGlobalProperty$3 = function(key, value) {
  try {
    defineProperty$2(global$9, key, { value, configurable: true, writable: true });
  } catch (error6) {
    global$9[key] = value;
  }
  return value;
};
var global$8 = global$c;
var defineGlobalProperty$2 = defineGlobalProperty$3;
var SHARED = "__core-js_shared__";
var store$3 = global$8[SHARED] || defineGlobalProperty$2(SHARED, {});
var sharedStore = store$3;
var store$2 = sharedStore;
(shared$3.exports = function(key, value) {
  return store$2[key] || (store$2[key] = value !== void 0 ? value : {});
})("versions", []).push({
  version: "3.23.3",
  mode: "global",
  copyright: "\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",
  license: "https://github.com/zloirock/core-js/blob/v3.23.3/LICENSE",
  source: "https://github.com/zloirock/core-js"
});
var requireObjectCoercible = requireObjectCoercible$2;
var $Object$1 = Object;
var toObject$2 = function(argument) {
  return $Object$1(requireObjectCoercible(argument));
};
var uncurryThis$9 = functionUncurryThis;
var toObject$1 = toObject$2;
var hasOwnProperty = uncurryThis$9({}.hasOwnProperty);
var hasOwnProperty_1 = Object.hasOwn || function hasOwn2(it, key) {
  return hasOwnProperty(toObject$1(it), key);
};
var uncurryThis$8 = functionUncurryThis;
var id = 0;
var postfix = Math.random();
var toString = uncurryThis$8(1 .toString);
var uid$2 = function(key) {
  return "Symbol(" + (key === void 0 ? "" : key) + ")_" + toString(++id + postfix, 36);
};
var global$7 = global$c;
var shared$2 = shared$3.exports;
var hasOwn$6 = hasOwnProperty_1;
var uid$1 = uid$2;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;
var WellKnownSymbolsStore = shared$2("wks");
var Symbol$1 = global$7.Symbol;
var symbolFor = Symbol$1 && Symbol$1["for"];
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$1;
var wellKnownSymbol$5 = function(name) {
  if (!hasOwn$6(WellKnownSymbolsStore, name) || !(NATIVE_SYMBOL || typeof WellKnownSymbolsStore[name] == "string")) {
    var description = "Symbol." + name;
    if (NATIVE_SYMBOL && hasOwn$6(Symbol$1, name)) {
      WellKnownSymbolsStore[name] = Symbol$1[name];
    } else if (USE_SYMBOL_AS_UID && symbolFor) {
      WellKnownSymbolsStore[name] = symbolFor(description);
    } else {
      WellKnownSymbolsStore[name] = createWellKnownSymbol(description);
    }
  }
  return WellKnownSymbolsStore[name];
};
var call$1 = functionCall;
var isObject$4 = isObject$6;
var isSymbol$1 = isSymbol$2;
var getMethod = getMethod$1;
var ordinaryToPrimitive = ordinaryToPrimitive$1;
var wellKnownSymbol$4 = wellKnownSymbol$5;
var $TypeError$3 = TypeError;
var TO_PRIMITIVE = wellKnownSymbol$4("toPrimitive");
var toPrimitive$1 = function(input, pref) {
  if (!isObject$4(input) || isSymbol$1(input))
    return input;
  var exoticToPrim = getMethod(input, TO_PRIMITIVE);
  var result;
  if (exoticToPrim) {
    if (pref === void 0)
      pref = "default";
    result = call$1(exoticToPrim, input, pref);
    if (!isObject$4(result) || isSymbol$1(result))
      return result;
    throw $TypeError$3("Can't convert object to primitive value");
  }
  if (pref === void 0)
    pref = "number";
  return ordinaryToPrimitive(input, pref);
};
var toPrimitive = toPrimitive$1;
var isSymbol = isSymbol$2;
var toPropertyKey$2 = function(argument) {
  var key = toPrimitive(argument, "string");
  return isSymbol(key) ? key : key + "";
};
var global$6 = global$c;
var isObject$3 = isObject$6;
var document$1 = global$6.document;
var EXISTS$1 = isObject$3(document$1) && isObject$3(document$1.createElement);
var documentCreateElement$1 = function(it) {
  return EXISTS$1 ? document$1.createElement(it) : {};
};
var DESCRIPTORS$8 = descriptors;
var fails$4 = fails$9;
var createElement = documentCreateElement$1;
var ie8DomDefine = !DESCRIPTORS$8 && !fails$4(function() {
  return Object.defineProperty(createElement("div"), "a", {
    get: function() {
      return 7;
    }
  }).a != 7;
});
var DESCRIPTORS$7 = descriptors;
var call = functionCall;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$1 = createPropertyDescriptor$2;
var toIndexedObject$4 = toIndexedObject$5;
var toPropertyKey$1 = toPropertyKey$2;
var hasOwn$5 = hasOwnProperty_1;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var $getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$7 ? $getOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor2(O, P) {
  O = toIndexedObject$4(O);
  P = toPropertyKey$1(P);
  if (IE8_DOM_DEFINE$1)
    try {
      return $getOwnPropertyDescriptor$1(O, P);
    } catch (error6) {
    }
  if (hasOwn$5(O, P))
    return createPropertyDescriptor$1(!call(propertyIsEnumerableModule.f, O, P), O[P]);
};
var objectDefineProperty = {};
var DESCRIPTORS$6 = descriptors;
var fails$3 = fails$9;
var v8PrototypeDefineBug = DESCRIPTORS$6 && fails$3(function() {
  return Object.defineProperty(function() {
  }, "prototype", {
    value: 42,
    writable: false
  }).prototype != 42;
});
var isObject$2 = isObject$6;
var $String = String;
var $TypeError$2 = TypeError;
var anObject$4 = function(argument) {
  if (isObject$2(argument))
    return argument;
  throw $TypeError$2($String(argument) + " is not an object");
};
var DESCRIPTORS$5 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var V8_PROTOTYPE_DEFINE_BUG$1 = v8PrototypeDefineBug;
var anObject$3 = anObject$4;
var toPropertyKey = toPropertyKey$2;
var $TypeError$1 = TypeError;
var $defineProperty = Object.defineProperty;
var $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
var ENUMERABLE = "enumerable";
var CONFIGURABLE$1 = "configurable";
var WRITABLE = "writable";
objectDefineProperty.f = DESCRIPTORS$5 ? V8_PROTOTYPE_DEFINE_BUG$1 ? function defineProperty2(O, P, Attributes) {
  anObject$3(O);
  P = toPropertyKey(P);
  anObject$3(Attributes);
  if (typeof O === "function" && P === "prototype" && "value" in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {
    var current = $getOwnPropertyDescriptor(O, P);
    if (current && current[WRITABLE]) {
      O[P] = Attributes.value;
      Attributes = {
        configurable: CONFIGURABLE$1 in Attributes ? Attributes[CONFIGURABLE$1] : current[CONFIGURABLE$1],
        enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],
        writable: false
      };
    }
  }
  return $defineProperty(O, P, Attributes);
} : $defineProperty : function defineProperty3(O, P, Attributes) {
  anObject$3(O);
  P = toPropertyKey(P);
  anObject$3(Attributes);
  if (IE8_DOM_DEFINE)
    try {
      return $defineProperty(O, P, Attributes);
    } catch (error6) {
    }
  if ("get" in Attributes || "set" in Attributes)
    throw $TypeError$1("Accessors not supported");
  if ("value" in Attributes)
    O[P] = Attributes.value;
  return O;
};
var DESCRIPTORS$4 = descriptors;
var definePropertyModule$3 = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$2;
var createNonEnumerableProperty$2 = DESCRIPTORS$4 ? function(object, key, value) {
  return definePropertyModule$3.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
  object[key] = value;
  return object;
};
var makeBuiltIn$2 = { exports: {} };
var DESCRIPTORS$3 = descriptors;
var hasOwn$4 = hasOwnProperty_1;
var FunctionPrototype = Function.prototype;
var getDescriptor = DESCRIPTORS$3 && Object.getOwnPropertyDescriptor;
var EXISTS = hasOwn$4(FunctionPrototype, "name");
var PROPER = EXISTS && function something() {
}.name === "something";
var CONFIGURABLE = EXISTS && (!DESCRIPTORS$3 || DESCRIPTORS$3 && getDescriptor(FunctionPrototype, "name").configurable);
var functionName = {
  EXISTS,
  PROPER,
  CONFIGURABLE
};
var uncurryThis$7 = functionUncurryThis;
var isCallable$6 = isCallable$c;
var store$1 = sharedStore;
var functionToString = uncurryThis$7(Function.toString);
if (!isCallable$6(store$1.inspectSource)) {
  store$1.inspectSource = function(it) {
    return functionToString(it);
  };
}
var inspectSource$3 = store$1.inspectSource;
var global$5 = global$c;
var isCallable$5 = isCallable$c;
var inspectSource$2 = inspectSource$3;
var WeakMap$1 = global$5.WeakMap;
var nativeWeakMap = isCallable$5(WeakMap$1) && /native code/.test(inspectSource$2(WeakMap$1));
var shared$1 = shared$3.exports;
var uid = uid$2;
var keys = shared$1("keys");
var sharedKey$2 = function(key) {
  return keys[key] || (keys[key] = uid(key));
};
var hiddenKeys$4 = {};
var NATIVE_WEAK_MAP = nativeWeakMap;
var global$4 = global$c;
var uncurryThis$6 = functionUncurryThis;
var isObject$1 = isObject$6;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$2;
var hasOwn$3 = hasOwnProperty_1;
var shared = sharedStore;
var sharedKey$1 = sharedKey$2;
var hiddenKeys$3 = hiddenKeys$4;
var OBJECT_ALREADY_INITIALIZED = "Object already initialized";
var TypeError$1 = global$4.TypeError;
var WeakMap = global$4.WeakMap;
var set, get, has;
var enforce = function(it) {
  return has(it) ? get(it) : set(it, {});
};
var getterFor = function(TYPE) {
  return function(it) {
    var state;
    if (!isObject$1(it) || (state = get(it)).type !== TYPE) {
      throw TypeError$1("Incompatible receiver, " + TYPE + " required");
    }
    return state;
  };
};
if (NATIVE_WEAK_MAP || shared.state) {
  var store = shared.state || (shared.state = new WeakMap());
  var wmget = uncurryThis$6(store.get);
  var wmhas = uncurryThis$6(store.has);
  var wmset = uncurryThis$6(store.set);
  set = function(it, metadata) {
    if (wmhas(store, it))
      throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    wmset(store, it, metadata);
    return metadata;
  };
  get = function(it) {
    return wmget(store, it) || {};
  };
  has = function(it) {
    return wmhas(store, it);
  };
} else {
  var STATE = sharedKey$1("state");
  hiddenKeys$3[STATE] = true;
  set = function(it, metadata) {
    if (hasOwn$3(it, STATE))
      throw new TypeError$1(OBJECT_ALREADY_INITIALIZED);
    metadata.facade = it;
    createNonEnumerableProperty$1(it, STATE, metadata);
    return metadata;
  };
  get = function(it) {
    return hasOwn$3(it, STATE) ? it[STATE] : {};
  };
  has = function(it) {
    return hasOwn$3(it, STATE);
  };
}
var internalState = {
  set,
  get,
  has,
  enforce,
  getterFor
};
var fails$2 = fails$9;
var isCallable$4 = isCallable$c;
var hasOwn$2 = hasOwnProperty_1;
var DESCRIPTORS$2 = descriptors;
var CONFIGURABLE_FUNCTION_NAME = functionName.CONFIGURABLE;
var inspectSource$1 = inspectSource$3;
var InternalStateModule = internalState;
var enforceInternalState = InternalStateModule.enforce;
var getInternalState = InternalStateModule.get;
var defineProperty$1 = Object.defineProperty;
var CONFIGURABLE_LENGTH = DESCRIPTORS$2 && !fails$2(function() {
  return defineProperty$1(function() {
  }, "length", { value: 8 }).length !== 8;
});
var TEMPLATE = String(String).split("String");
var makeBuiltIn$1 = makeBuiltIn$2.exports = function(value, name, options) {
  if (String(name).slice(0, 7) === "Symbol(") {
    name = "[" + String(name).replace(/^Symbol\(([^)]*)\)/, "$1") + "]";
  }
  if (options && options.getter)
    name = "get " + name;
  if (options && options.setter)
    name = "set " + name;
  if (!hasOwn$2(value, "name") || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {
    if (DESCRIPTORS$2)
      defineProperty$1(value, "name", { value: name, configurable: true });
    else
      value.name = name;
  }
  if (CONFIGURABLE_LENGTH && options && hasOwn$2(options, "arity") && value.length !== options.arity) {
    defineProperty$1(value, "length", { value: options.arity });
  }
  try {
    if (options && hasOwn$2(options, "constructor") && options.constructor) {
      if (DESCRIPTORS$2)
        defineProperty$1(value, "prototype", { writable: false });
    } else if (value.prototype)
      value.prototype = void 0;
  } catch (error6) {
  }
  var state = enforceInternalState(value);
  if (!hasOwn$2(state, "source")) {
    state.source = TEMPLATE.join(typeof name == "string" ? name : "");
  }
  return value;
};
Function.prototype.toString = makeBuiltIn$1(function toString2() {
  return isCallable$4(this) && getInternalState(this).source || inspectSource$1(this);
}, "toString");
var isCallable$3 = isCallable$c;
var definePropertyModule$2 = objectDefineProperty;
var makeBuiltIn = makeBuiltIn$2.exports;
var defineGlobalProperty$1 = defineGlobalProperty$3;
var defineBuiltIn$1 = function(O, key, value, options) {
  if (!options)
    options = {};
  var simple = options.enumerable;
  var name = options.name !== void 0 ? options.name : key;
  if (isCallable$3(value))
    makeBuiltIn(value, name, options);
  if (options.global) {
    if (simple)
      O[key] = value;
    else
      defineGlobalProperty$1(key, value);
  } else {
    try {
      if (!options.unsafe)
        delete O[key];
      else if (O[key])
        simple = true;
    } catch (error6) {
    }
    if (simple)
      O[key] = value;
    else
      definePropertyModule$2.f(O, key, {
        value,
        enumerable: false,
        configurable: !options.nonConfigurable,
        writable: !options.nonWritable
      });
  }
  return O;
};
var objectGetOwnPropertyNames = {};
var ceil = Math.ceil;
var floor = Math.floor;
var mathTrunc = Math.trunc || function trunc2(x2) {
  var n = +x2;
  return (n > 0 ? floor : ceil)(n);
};
var trunc = mathTrunc;
var toIntegerOrInfinity$2 = function(argument) {
  var number = +argument;
  return number !== number || number === 0 ? 0 : trunc(number);
};
var toIntegerOrInfinity$1 = toIntegerOrInfinity$2;
var max = Math.max;
var min$1 = Math.min;
var toAbsoluteIndex$1 = function(index, length) {
  var integer = toIntegerOrInfinity$1(index);
  return integer < 0 ? max(integer + length, 0) : min$1(integer, length);
};
var toIntegerOrInfinity = toIntegerOrInfinity$2;
var min = Math.min;
var toLength$1 = function(argument) {
  return argument > 0 ? min(toIntegerOrInfinity(argument), 9007199254740991) : 0;
};
var toLength = toLength$1;
var lengthOfArrayLike$3 = function(obj) {
  return toLength(obj.length);
};
var toIndexedObject$3 = toIndexedObject$5;
var toAbsoluteIndex = toAbsoluteIndex$1;
var lengthOfArrayLike$2 = lengthOfArrayLike$3;
var createMethod$1 = function(IS_INCLUDES) {
  return function($this, el, fromIndex) {
    var O = toIndexedObject$3($this);
    var length = lengthOfArrayLike$2(O);
    var index = toAbsoluteIndex(fromIndex, length);
    var value;
    if (IS_INCLUDES && el != el)
      while (length > index) {
        value = O[index++];
        if (value != value)
          return true;
      }
    else
      for (; length > index; index++) {
        if ((IS_INCLUDES || index in O) && O[index] === el)
          return IS_INCLUDES || index || 0;
      }
    return !IS_INCLUDES && -1;
  };
};
var arrayIncludes = {
  includes: createMethod$1(true),
  indexOf: createMethod$1(false)
};
var uncurryThis$5 = functionUncurryThis;
var hasOwn$1 = hasOwnProperty_1;
var toIndexedObject$2 = toIndexedObject$5;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$2 = hiddenKeys$4;
var push$1 = uncurryThis$5([].push);
var objectKeysInternal = function(object, names) {
  var O = toIndexedObject$2(object);
  var i2 = 0;
  var result = [];
  var key;
  for (key in O)
    !hasOwn$1(hiddenKeys$2, key) && hasOwn$1(O, key) && push$1(result, key);
  while (names.length > i2)
    if (hasOwn$1(O, key = names[i2++])) {
      ~indexOf(result, key) || push$1(result, key);
    }
  return result;
};
var enumBugKeys$3 = [
  "constructor",
  "hasOwnProperty",
  "isPrototypeOf",
  "propertyIsEnumerable",
  "toLocaleString",
  "toString",
  "valueOf"
];
var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;
var hiddenKeys$1 = enumBugKeys$2.concat("length", "prototype");
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
  return internalObjectKeys$1(O, hiddenKeys$1);
};
var objectGetOwnPropertySymbols = {};
objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;
var getBuiltIn$2 = getBuiltIn$5;
var uncurryThis$4 = functionUncurryThis;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$2 = anObject$4;
var concat = uncurryThis$4([].concat);
var ownKeys$1 = getBuiltIn$2("Reflect", "ownKeys") || function ownKeys2(it) {
  var keys3 = getOwnPropertyNamesModule.f(anObject$2(it));
  var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
  return getOwnPropertySymbols ? concat(keys3, getOwnPropertySymbols(it)) : keys3;
};
var hasOwn = hasOwnProperty_1;
var ownKeys = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;
var copyConstructorProperties$1 = function(target, source, exceptions) {
  var keys3 = ownKeys(source);
  var defineProperty4 = definePropertyModule$1.f;
  var getOwnPropertyDescriptor3 = getOwnPropertyDescriptorModule.f;
  for (var i2 = 0; i2 < keys3.length; i2++) {
    var key = keys3[i2];
    if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {
      defineProperty4(target, key, getOwnPropertyDescriptor3(source, key));
    }
  }
};
var fails$1 = fails$9;
var isCallable$2 = isCallable$c;
var replacement = /#|\.prototype\./;
var isForced$1 = function(feature, detection) {
  var value = data[normalize(feature)];
  return value == POLYFILL ? true : value == NATIVE ? false : isCallable$2(detection) ? fails$1(detection) : !!detection;
};
var normalize = isForced$1.normalize = function(string) {
  return String(string).replace(replacement, ".").toLowerCase();
};
var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = "N";
var POLYFILL = isForced$1.POLYFILL = "P";
var isForced_1 = isForced$1;
var global$3 = global$c;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty = createNonEnumerableProperty$2;
var defineBuiltIn = defineBuiltIn$1;
var defineGlobalProperty = defineGlobalProperty$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;
var _export = function(options, source) {
  var TARGET = options.target;
  var GLOBAL = options.global;
  var STATIC = options.stat;
  var FORCED, target, key, targetProperty, sourceProperty, descriptor;
  if (GLOBAL) {
    target = global$3;
  } else if (STATIC) {
    target = global$3[TARGET] || defineGlobalProperty(TARGET, {});
  } else {
    target = (global$3[TARGET] || {}).prototype;
  }
  if (target)
    for (key in source) {
      sourceProperty = source[key];
      if (options.dontCallGetSet) {
        descriptor = getOwnPropertyDescriptor(target, key);
        targetProperty = descriptor && descriptor.value;
      } else
        targetProperty = target[key];
      FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? "." : "#") + key, options.forced);
      if (!FORCED && targetProperty !== void 0) {
        if (typeof sourceProperty == typeof targetProperty)
          continue;
        copyConstructorProperties(sourceProperty, targetProperty);
      }
      if (options.sham || targetProperty && targetProperty.sham) {
        createNonEnumerableProperty(sourceProperty, "sham", true);
      }
      defineBuiltIn(target, key, sourceProperty, options);
    }
};
var classof$2 = classofRaw$1;
var isArray$2 = Array.isArray || function isArray2(argument) {
  return classof$2(argument) == "Array";
};
var $TypeError = TypeError;
var MAX_SAFE_INTEGER = 9007199254740991;
var doesNotExceedSafeInteger$1 = function(it) {
  if (it > MAX_SAFE_INTEGER)
    throw $TypeError("Maximum allowed index exceeded");
  return it;
};
var uncurryThis$3 = functionUncurryThis;
var aCallable$1 = aCallable$3;
var NATIVE_BIND = functionBindNative;
var bind$1 = uncurryThis$3(uncurryThis$3.bind);
var functionBindContext = function(fn, that) {
  aCallable$1(fn);
  return that === void 0 ? fn : NATIVE_BIND ? bind$1(fn, that) : function() {
    return fn.apply(that, arguments);
  };
};
var isArray$1 = isArray$2;
var lengthOfArrayLike$1 = lengthOfArrayLike$3;
var doesNotExceedSafeInteger = doesNotExceedSafeInteger$1;
var bind = functionBindContext;
var flattenIntoArray$1 = function(target, original, source, sourceLen, start, depth, mapper, thisArg) {
  var targetIndex = start;
  var sourceIndex = 0;
  var mapFn = mapper ? bind(mapper, thisArg) : false;
  var element, elementLen;
  while (sourceIndex < sourceLen) {
    if (sourceIndex in source) {
      element = mapFn ? mapFn(source[sourceIndex], sourceIndex, original) : source[sourceIndex];
      if (depth > 0 && isArray$1(element)) {
        elementLen = lengthOfArrayLike$1(element);
        targetIndex = flattenIntoArray$1(target, original, element, elementLen, targetIndex, depth - 1) - 1;
      } else {
        doesNotExceedSafeInteger(targetIndex + 1);
        target[targetIndex] = element;
      }
      targetIndex++;
    }
    sourceIndex++;
  }
  return targetIndex;
};
var flattenIntoArray_1 = flattenIntoArray$1;
var wellKnownSymbol$3 = wellKnownSymbol$5;
var TO_STRING_TAG$1 = wellKnownSymbol$3("toStringTag");
var test = {};
test[TO_STRING_TAG$1] = "z";
var toStringTagSupport = String(test) === "[object z]";
var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var isCallable$1 = isCallable$c;
var classofRaw = classofRaw$1;
var wellKnownSymbol$2 = wellKnownSymbol$5;
var TO_STRING_TAG = wellKnownSymbol$2("toStringTag");
var $Object = Object;
var CORRECT_ARGUMENTS = classofRaw(function() {
  return arguments;
}()) == "Arguments";
var tryGet = function(it, key) {
  try {
    return it[key];
  } catch (error6) {
  }
};
var classof$1 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
  var O, tag, result;
  return it === void 0 ? "Undefined" : it === null ? "Null" : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == "string" ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) == "Object" && isCallable$1(O.callee) ? "Arguments" : result;
};
var uncurryThis$2 = functionUncurryThis;
var fails = fails$9;
var isCallable = isCallable$c;
var classof = classof$1;
var getBuiltIn$1 = getBuiltIn$5;
var inspectSource = inspectSource$3;
var noop = function() {
};
var empty = [];
var construct = getBuiltIn$1("Reflect", "construct");
var constructorRegExp = /^\s*(?:class|function)\b/;
var exec = uncurryThis$2(constructorRegExp.exec);
var INCORRECT_TO_STRING = !constructorRegExp.exec(noop);
var isConstructorModern = function isConstructor2(argument) {
  if (!isCallable(argument))
    return false;
  try {
    construct(noop, empty, argument);
    return true;
  } catch (error6) {
    return false;
  }
};
var isConstructorLegacy = function isConstructor3(argument) {
  if (!isCallable(argument))
    return false;
  switch (classof(argument)) {
    case "AsyncFunction":
    case "GeneratorFunction":
    case "AsyncGeneratorFunction":
      return false;
  }
  try {
    return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));
  } catch (error6) {
    return true;
  }
};
isConstructorLegacy.sham = true;
var isConstructor$1 = !construct || fails(function() {
  var called;
  return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function() {
    called = true;
  }) || called;
}) ? isConstructorLegacy : isConstructorModern;
var isArray = isArray$2;
var isConstructor = isConstructor$1;
var isObject = isObject$6;
var wellKnownSymbol$1 = wellKnownSymbol$5;
var SPECIES = wellKnownSymbol$1("species");
var $Array = Array;
var arraySpeciesConstructor$1 = function(originalArray) {
  var C;
  if (isArray(originalArray)) {
    C = originalArray.constructor;
    if (isConstructor(C) && (C === $Array || isArray(C.prototype)))
      C = void 0;
    else if (isObject(C)) {
      C = C[SPECIES];
      if (C === null)
        C = void 0;
    }
  }
  return C === void 0 ? $Array : C;
};
var arraySpeciesConstructor = arraySpeciesConstructor$1;
var arraySpeciesCreate$1 = function(originalArray, length) {
  return new (arraySpeciesConstructor(originalArray))(length === 0 ? 0 : length);
};
var $$2 = _export;
var flattenIntoArray = flattenIntoArray_1;
var aCallable = aCallable$3;
var toObject = toObject$2;
var lengthOfArrayLike = lengthOfArrayLike$3;
var arraySpeciesCreate = arraySpeciesCreate$1;
$$2({ target: "Array", proto: true }, {
  flatMap: function flatMap(callbackfn) {
    var O = toObject(this);
    var sourceLen = lengthOfArrayLike(O);
    var A;
    aCallable(callbackfn);
    A = arraySpeciesCreate(O, 0);
    A.length = flattenIntoArray(A, O, O, sourceLen, 0, 1, callbackfn, arguments.length > 1 ? arguments[1] : void 0);
    return A;
  }
});
var objectDefineProperties = {};
var internalObjectKeys = objectKeysInternal;
var enumBugKeys$1 = enumBugKeys$3;
var objectKeys$2 = Object.keys || function keys2(O) {
  return internalObjectKeys(O, enumBugKeys$1);
};
var DESCRIPTORS$1 = descriptors;
var V8_PROTOTYPE_DEFINE_BUG = v8PrototypeDefineBug;
var definePropertyModule = objectDefineProperty;
var anObject$1 = anObject$4;
var toIndexedObject$1 = toIndexedObject$5;
var objectKeys$1 = objectKeys$2;
objectDefineProperties.f = DESCRIPTORS$1 && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {
  anObject$1(O);
  var props = toIndexedObject$1(Properties);
  var keys3 = objectKeys$1(Properties);
  var length = keys3.length;
  var index = 0;
  var key;
  while (length > index)
    definePropertyModule.f(O, key = keys3[index++], props[key]);
  return O;
};
var getBuiltIn = getBuiltIn$5;
var html$1 = getBuiltIn("document", "documentElement");
var anObject = anObject$4;
var definePropertiesModule = objectDefineProperties;
var enumBugKeys = enumBugKeys$3;
var hiddenKeys = hiddenKeys$4;
var html = html$1;
var documentCreateElement = documentCreateElement$1;
var sharedKey = sharedKey$2;
var GT = ">";
var LT = "<";
var PROTOTYPE = "prototype";
var SCRIPT = "script";
var IE_PROTO = sharedKey("IE_PROTO");
var EmptyConstructor = function() {
};
var scriptTag = function(content) {
  return LT + SCRIPT + GT + content + LT + "/" + SCRIPT + GT;
};
var NullProtoObjectViaActiveX = function(activeXDocument2) {
  activeXDocument2.write(scriptTag(""));
  activeXDocument2.close();
  var temp = activeXDocument2.parentWindow.Object;
  activeXDocument2 = null;
  return temp;
};
var NullProtoObjectViaIFrame = function() {
  var iframe = documentCreateElement("iframe");
  var JS = "java" + SCRIPT + ":";
  var iframeDocument;
  iframe.style.display = "none";
  html.appendChild(iframe);
  iframe.src = String(JS);
  iframeDocument = iframe.contentWindow.document;
  iframeDocument.open();
  iframeDocument.write(scriptTag("document.F=Object"));
  iframeDocument.close();
  return iframeDocument.F;
};
var activeXDocument;
var NullProtoObject = function() {
  try {
    activeXDocument = new ActiveXObject("htmlfile");
  } catch (error6) {
  }
  NullProtoObject = typeof document != "undefined" ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);
  var length = enumBugKeys.length;
  while (length--)
    delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];
  return NullProtoObject();
};
hiddenKeys[IE_PROTO] = true;
var objectCreate = Object.create || function create2(O, Properties) {
  var result;
  if (O !== null) {
    EmptyConstructor[PROTOTYPE] = anObject(O);
    result = new EmptyConstructor();
    EmptyConstructor[PROTOTYPE] = null;
    result[IE_PROTO] = O;
  } else
    result = NullProtoObject();
  return Properties === void 0 ? result : definePropertiesModule.f(result, Properties);
};
var wellKnownSymbol = wellKnownSymbol$5;
var create = objectCreate;
var defineProperty = objectDefineProperty.f;
var UNSCOPABLES = wellKnownSymbol("unscopables");
var ArrayPrototype = Array.prototype;
if (ArrayPrototype[UNSCOPABLES] == void 0) {
  defineProperty(ArrayPrototype, UNSCOPABLES, {
    configurable: true,
    value: create(null)
  });
}
var addToUnscopables$1 = function(key) {
  ArrayPrototype[UNSCOPABLES][key] = true;
};
var addToUnscopables = addToUnscopables$1;
addToUnscopables("flatMap");
var global$2 = global$c;
var uncurryThis$1 = functionUncurryThis;
var entryUnbind$1 = function(CONSTRUCTOR, METHOD) {
  return uncurryThis$1(global$2[CONSTRUCTOR].prototype[METHOD]);
};
var entryUnbind = entryUnbind$1;
entryUnbind("Array", "flatMap");
var DESCRIPTORS = descriptors;
var uncurryThis = functionUncurryThis;
var objectKeys = objectKeys$2;
var toIndexedObject = toIndexedObject$5;
var $propertyIsEnumerable = objectPropertyIsEnumerable.f;
var propertyIsEnumerable = uncurryThis($propertyIsEnumerable);
var push = uncurryThis([].push);
var createMethod = function(TO_ENTRIES) {
  return function(it) {
    var O = toIndexedObject(it);
    var keys3 = objectKeys(O);
    var length = keys3.length;
    var i2 = 0;
    var result = [];
    var key;
    while (length > i2) {
      key = keys3[i2++];
      if (!DESCRIPTORS || propertyIsEnumerable(O, key)) {
        push(result, TO_ENTRIES ? [key, O[key]] : O[key]);
      }
    }
    return result;
  };
};
var objectToArray = {
  entries: createMethod(true),
  values: createMethod(false)
};
var $$1 = _export;
var $values = objectToArray.values;
$$1({ target: "Object", stat: true }, {
  values: function values(O) {
    return $values(O);
  }
});
var global$1 = global$c;
var path$2 = global$1;
var path$1 = path$2;
path$1.Object.values;
var $ = _export;
var $entries = objectToArray.entries;
$({ target: "Object", stat: true }, {
  entries: function entries(O) {
    return $entries(O);
  }
});
var path = path$2;
path.Object.entries;
(function(root, factory) {
  {
    root.htmx = factory();
  }
})(typeof self !== "undefined" ? self : commonjsGlobal, function() {
  return function() {
    var htmx = {
      onLoad: onLoadHelper,
      process: processNode,
      on: addEventListenerImpl,
      off: removeEventListenerImpl,
      trigger: triggerEvent,
      ajax: ajaxHelper,
      find,
      findAll,
      closest,
      values: function(elt, type) {
        var inputValues = getInputValues(elt, type || "post");
        return inputValues.values;
      },
      remove: removeElement,
      addClass: addClassToElement,
      removeClass: removeClassFromElement,
      toggleClass: toggleClassOnElement,
      takeClass: takeClassForElement,
      defineExtension,
      removeExtension,
      logAll,
      logger: null,
      config: {
        historyEnabled: true,
        historyCacheSize: 10,
        refreshOnHistoryMiss: false,
        defaultSwapStyle: "innerHTML",
        defaultSwapDelay: 0,
        defaultSettleDelay: 20,
        includeIndicatorStyles: true,
        indicatorClass: "htmx-indicator",
        requestClass: "htmx-request",
        addedClass: "htmx-added",
        settlingClass: "htmx-settling",
        swappingClass: "htmx-swapping",
        allowEval: true,
        inlineScriptNonce: "",
        attributesToSettle: ["class", "style", "width", "height"],
        withCredentials: false,
        timeout: 0,
        wsReconnectDelay: "full-jitter",
        disableSelector: "[hx-disable], [data-hx-disable]",
        useTemplateFragments: false,
        scrollBehavior: "smooth",
        defaultFocusScroll: false
      },
      parseInterval,
      _: internalEval,
      createEventSource: function(url) {
        return new EventSource(url, { withCredentials: true });
      },
      createWebSocket: function(url) {
        return new WebSocket(url, []);
      },
      version: "1.7.0"
    };
    var internalAPI = {
      bodyContains,
      filterValues,
      hasAttribute,
      getAttributeValue,
      getClosestMatch,
      getExpressionVars,
      getHeaders,
      getInputValues,
      getInternalData,
      getSwapSpecification,
      getTriggerSpecs,
      getTarget,
      makeFragment,
      mergeObjects,
      makeSettleInfo,
      oobSwap,
      selectAndSwap,
      settleImmediately,
      shouldCancel,
      triggerEvent,
      triggerErrorEvent,
      withExtensions
    };
    var VERBS = ["get", "post", "put", "delete", "patch"];
    var VERB_SELECTOR = VERBS.map(function(verb) {
      return "[hx-" + verb + "], [data-hx-" + verb + "]";
    }).join(", ");
    function parseInterval(str2) {
      if (str2 == void 0) {
        return void 0;
      }
      if (str2.slice(-2) == "ms") {
        return parseFloat(str2.slice(0, -2)) || void 0;
      }
      if (str2.slice(-1) == "s") {
        return parseFloat(str2.slice(0, -1)) * 1e3 || void 0;
      }
      return parseFloat(str2) || void 0;
    }
    function getRawAttribute(elt, name) {
      return elt.getAttribute && elt.getAttribute(name);
    }
    function hasAttribute(elt, qualifiedName) {
      return elt.hasAttribute && (elt.hasAttribute(qualifiedName) || elt.hasAttribute("data-" + qualifiedName));
    }
    function getAttributeValue(elt, qualifiedName) {
      return getRawAttribute(elt, qualifiedName) || getRawAttribute(elt, "data-" + qualifiedName);
    }
    function parentElt(elt) {
      return elt.parentElement;
    }
    function getDocument() {
      return document;
    }
    function getClosestMatch(elt, condition) {
      if (condition(elt)) {
        return elt;
      } else if (parentElt(elt)) {
        return getClosestMatch(parentElt(elt), condition);
      } else {
        return null;
      }
    }
    function getAttributeValueWithDisinheritance(initialElement, ancestor, attributeName) {
      var attributeValue = getAttributeValue(ancestor, attributeName);
      var disinherit = getAttributeValue(ancestor, "hx-disinherit");
      if (initialElement !== ancestor && disinherit && (disinherit === "*" || disinherit.split(" ").indexOf(attributeName) >= 0)) {
        return "unset";
      } else {
        return attributeValue;
      }
    }
    function getClosestAttributeValue(elt, attributeName) {
      var closestAttr = null;
      getClosestMatch(elt, function(e) {
        return closestAttr = getAttributeValueWithDisinheritance(elt, e, attributeName);
      });
      if (closestAttr !== "unset") {
        return closestAttr;
      }
    }
    function matches(elt, selector) {
      var matchesFunction = elt.matches || elt.matchesSelector || elt.msMatchesSelector || elt.mozMatchesSelector || elt.webkitMatchesSelector || elt.oMatchesSelector;
      return matchesFunction && matchesFunction.call(elt, selector);
    }
    function getStartTag(str2) {
      var tagMatcher = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i;
      var match2 = tagMatcher.exec(str2);
      if (match2) {
        return match2[1].toLowerCase();
      } else {
        return "";
      }
    }
    function parseHTML(resp, depth) {
      var parser = new DOMParser();
      var responseDoc = parser.parseFromString(resp, "text/html");
      var responseNode = responseDoc.body;
      while (depth > 0) {
        depth--;
        responseNode = responseNode.firstChild;
      }
      if (responseNode == null) {
        responseNode = getDocument().createDocumentFragment();
      }
      return responseNode;
    }
    function makeFragment(resp) {
      if (htmx.config.useTemplateFragments) {
        var documentFragment = parseHTML("<body><template>" + resp + "</template></body>", 0);
        return documentFragment.querySelector("template").content;
      } else {
        var startTag = getStartTag(resp);
        switch (startTag) {
          case "thead":
          case "tbody":
          case "tfoot":
          case "colgroup":
          case "caption":
            return parseHTML("<table>" + resp + "</table>", 1);
          case "col":
            return parseHTML("<table><colgroup>" + resp + "</colgroup></table>", 2);
          case "tr":
            return parseHTML("<table><tbody>" + resp + "</tbody></table>", 2);
          case "td":
          case "th":
            return parseHTML("<table><tbody><tr>" + resp + "</tr></tbody></table>", 3);
          case "script":
            return parseHTML("<div>" + resp + "</div>", 1);
          default:
            return parseHTML(resp, 0);
        }
      }
    }
    function maybeCall(func) {
      if (func) {
        func();
      }
    }
    function isType(o, type) {
      return Object.prototype.toString.call(o) === "[object " + type + "]";
    }
    function isFunction(o) {
      return isType(o, "Function");
    }
    function isRawObject(o) {
      return isType(o, "Object");
    }
    function getInternalData(elt) {
      var dataProp = "htmx-internal-data";
      var data2 = elt[dataProp];
      if (!data2) {
        data2 = elt[dataProp] = {};
      }
      return data2;
    }
    function toArray(arr) {
      var returnArr = [];
      if (arr) {
        for (var i2 = 0; i2 < arr.length; i2++) {
          returnArr.push(arr[i2]);
        }
      }
      return returnArr;
    }
    function forEach(arr, func) {
      if (arr) {
        for (var i2 = 0; i2 < arr.length; i2++) {
          func(arr[i2]);
        }
      }
    }
    function isScrolledIntoView(el) {
      var rect = el.getBoundingClientRect();
      var elemTop = rect.top;
      var elemBottom = rect.bottom;
      return elemTop < window.innerHeight && elemBottom >= 0;
    }
    function bodyContains(elt) {
      if (elt.getRootNode() instanceof ShadowRoot) {
        return getDocument().body.contains(elt.getRootNode().host);
      } else {
        return getDocument().body.contains(elt);
      }
    }
    function splitOnWhitespace(trigger) {
      return trigger.trim().split(/\s+/);
    }
    function mergeObjects(obj1, obj2) {
      for (var key in obj2) {
        if (obj2.hasOwnProperty(key)) {
          obj1[key] = obj2[key];
        }
      }
      return obj1;
    }
    function parseJSON(jString) {
      try {
        return JSON.parse(jString);
      } catch (error6) {
        logError(error6);
        return null;
      }
    }
    function internalEval(str) {
      return maybeEval(getDocument().body, function() {
        return eval(str);
      });
    }
    function onLoadHelper(callback) {
      var value = htmx.on("htmx:load", function(evt) {
        callback(evt.detail.elt);
      });
      return value;
    }
    function logAll() {
      htmx.logger = function(elt, event, data2) {
        if (console) {
          console.log(event, elt, data2);
        }
      };
    }
    function find(eltOrSelector, selector) {
      if (selector) {
        return eltOrSelector.querySelector(selector);
      } else {
        return find(getDocument(), eltOrSelector);
      }
    }
    function findAll(eltOrSelector, selector) {
      if (selector) {
        return eltOrSelector.querySelectorAll(selector);
      } else {
        return findAll(getDocument(), eltOrSelector);
      }
    }
    function removeElement(elt, delay) {
      elt = resolveTarget(elt);
      if (delay) {
        setTimeout(function() {
          removeElement(elt);
        }, delay);
      } else {
        elt.parentElement.removeChild(elt);
      }
    }
    function addClassToElement(elt, clazz, delay) {
      elt = resolveTarget(elt);
      if (delay) {
        setTimeout(function() {
          addClassToElement(elt, clazz);
        }, delay);
      } else {
        elt.classList && elt.classList.add(clazz);
      }
    }
    function removeClassFromElement(elt, clazz, delay) {
      elt = resolveTarget(elt);
      if (delay) {
        setTimeout(function() {
          removeClassFromElement(elt, clazz);
        }, delay);
      } else {
        if (elt.classList) {
          elt.classList.remove(clazz);
          if (elt.classList.length === 0) {
            elt.removeAttribute("class");
          }
        }
      }
    }
    function toggleClassOnElement(elt, clazz) {
      elt = resolveTarget(elt);
      elt.classList.toggle(clazz);
    }
    function takeClassForElement(elt, clazz) {
      elt = resolveTarget(elt);
      forEach(elt.parentElement.children, function(child) {
        removeClassFromElement(child, clazz);
      });
      addClassToElement(elt, clazz);
    }
    function closest(elt, selector) {
      elt = resolveTarget(elt);
      if (elt.closest) {
        return elt.closest(selector);
      } else {
        do {
          if (elt == null || matches(elt, selector)) {
            return elt;
          }
        } while (elt = elt && parentElt(elt));
      }
    }
    function querySelectorAllExt(elt, selector) {
      if (selector.indexOf("closest ") === 0) {
        return [closest(elt, selector.substr(8))];
      } else if (selector.indexOf("find ") === 0) {
        return [find(elt, selector.substr(5))];
      } else if (selector === "document") {
        return [document];
      } else if (selector === "window") {
        return [window];
      } else {
        return getDocument().querySelectorAll(selector);
      }
    }
    function querySelectorExt(eltOrSelector, selector) {
      if (selector) {
        return querySelectorAllExt(eltOrSelector, selector)[0];
      } else {
        return querySelectorAllExt(getDocument().body, eltOrSelector)[0];
      }
    }
    function resolveTarget(arg2) {
      if (isType(arg2, "String")) {
        return find(arg2);
      } else {
        return arg2;
      }
    }
    function processEventArgs(arg1, arg2, arg3) {
      if (isFunction(arg2)) {
        return {
          target: getDocument().body,
          event: arg1,
          listener: arg2
        };
      } else {
        return {
          target: resolveTarget(arg1),
          event: arg2,
          listener: arg3
        };
      }
    }
    function addEventListenerImpl(arg1, arg2, arg3) {
      ready(function() {
        var eventArgs = processEventArgs(arg1, arg2, arg3);
        eventArgs.target.addEventListener(eventArgs.event, eventArgs.listener);
      });
      var b = isFunction(arg2);
      return b ? arg2 : arg3;
    }
    function removeEventListenerImpl(arg1, arg2, arg3) {
      ready(function() {
        var eventArgs = processEventArgs(arg1, arg2, arg3);
        eventArgs.target.removeEventListener(eventArgs.event, eventArgs.listener);
      });
      return isFunction(arg2) ? arg2 : arg3;
    }
    var DUMMY_ELT = getDocument().createElement("output");
    function findAttributeTargets(elt, attrName) {
      var attrTarget = getClosestAttributeValue(elt, attrName);
      if (attrTarget) {
        if (attrTarget === "this") {
          return [findThisElement(elt, attrName)];
        } else {
          var result = querySelectorAllExt(elt, attrTarget);
          if (result.length === 0) {
            logError('The selector "' + attrTarget + '" on ' + attrName + " returned no matches!");
            return [DUMMY_ELT];
          } else {
            return result;
          }
        }
      }
    }
    function findThisElement(elt, attribute) {
      return getClosestMatch(elt, function(elt2) {
        return getAttributeValue(elt2, attribute) != null;
      });
    }
    function getTarget(elt) {
      var targetStr = getClosestAttributeValue(elt, "hx-target");
      if (targetStr) {
        if (targetStr === "this") {
          return findThisElement(elt, "hx-target");
        } else {
          return querySelectorExt(elt, targetStr);
        }
      } else {
        var data2 = getInternalData(elt);
        if (data2.boosted) {
          return getDocument().body;
        } else {
          return elt;
        }
      }
    }
    function shouldSettleAttribute(name) {
      var attributesToSettle = htmx.config.attributesToSettle;
      for (var i2 = 0; i2 < attributesToSettle.length; i2++) {
        if (name === attributesToSettle[i2]) {
          return true;
        }
      }
      return false;
    }
    function cloneAttributes(mergeTo, mergeFrom) {
      forEach(mergeTo.attributes, function(attr) {
        if (!mergeFrom.hasAttribute(attr.name) && shouldSettleAttribute(attr.name)) {
          mergeTo.removeAttribute(attr.name);
        }
      });
      forEach(mergeFrom.attributes, function(attr) {
        if (shouldSettleAttribute(attr.name)) {
          mergeTo.setAttribute(attr.name, attr.value);
        }
      });
    }
    function isInlineSwap(swapStyle, target) {
      var extensions2 = getExtensions(target);
      for (var i2 = 0; i2 < extensions2.length; i2++) {
        var extension = extensions2[i2];
        try {
          if (extension.isInlineSwap(swapStyle)) {
            return true;
          }
        } catch (e) {
          logError(e);
        }
      }
      return swapStyle === "outerHTML";
    }
    function oobSwap(oobValue, oobElement, settleInfo) {
      var selector = "#" + oobElement.id;
      var swapStyle = "outerHTML";
      if (oobValue === "true")
        ;
      else if (oobValue.indexOf(":") > 0) {
        swapStyle = oobValue.substr(0, oobValue.indexOf(":"));
        selector = oobValue.substr(oobValue.indexOf(":") + 1, oobValue.length);
      } else {
        swapStyle = oobValue;
      }
      var targets = getDocument().querySelectorAll(selector);
      if (targets) {
        forEach(
          targets,
          function(target) {
            var fragment;
            var oobElementClone = oobElement.cloneNode(true);
            fragment = getDocument().createDocumentFragment();
            fragment.appendChild(oobElementClone);
            if (!isInlineSwap(swapStyle, target)) {
              fragment = oobElementClone;
            }
            var beforeSwapDetails = { shouldSwap: true, target, fragment };
            if (!triggerEvent(target, "htmx:oobBeforeSwap", beforeSwapDetails))
              return;
            target = beforeSwapDetails.target;
            if (beforeSwapDetails["shouldSwap"]) {
              swap(swapStyle, target, target, fragment, settleInfo);
            }
            forEach(settleInfo.elts, function(elt) {
              triggerEvent(elt, "htmx:oobAfterSwap", beforeSwapDetails);
            });
          }
        );
        oobElement.parentNode.removeChild(oobElement);
      } else {
        oobElement.parentNode.removeChild(oobElement);
        triggerErrorEvent(getDocument().body, "htmx:oobErrorNoTarget", { content: oobElement });
      }
      return oobValue;
    }
    function handleOutOfBandSwaps(fragment, settleInfo) {
      forEach(findAll(fragment, "[hx-swap-oob], [data-hx-swap-oob]"), function(oobElement) {
        var oobValue = getAttributeValue(oobElement, "hx-swap-oob");
        if (oobValue != null) {
          oobSwap(oobValue, oobElement, settleInfo);
        }
      });
    }
    function handlePreservedElements(fragment) {
      forEach(findAll(fragment, "[hx-preserve], [data-hx-preserve]"), function(preservedElt) {
        var id2 = getAttributeValue(preservedElt, "id");
        var oldElt = getDocument().getElementById(id2);
        if (oldElt != null) {
          preservedElt.parentNode.replaceChild(oldElt, preservedElt);
        }
      });
    }
    function handleAttributes(parentNode, fragment, settleInfo) {
      forEach(fragment.querySelectorAll("[id]"), function(newNode) {
        if (newNode.id && newNode.id.length > 0) {
          var oldNode = parentNode.querySelector(newNode.tagName + "[id='" + newNode.id + "']");
          if (oldNode && oldNode !== parentNode) {
            var newAttributes = newNode.cloneNode();
            cloneAttributes(newNode, oldNode);
            settleInfo.tasks.push(function() {
              cloneAttributes(newNode, newAttributes);
            });
          }
        }
      });
    }
    function makeAjaxLoadTask(child) {
      return function() {
        removeClassFromElement(child, htmx.config.addedClass);
        processNode(child);
        processScripts(child);
        processFocus(child);
        triggerEvent(child, "htmx:load");
      };
    }
    function processFocus(child) {
      var autofocus = "[autofocus]";
      var autoFocusedElt = matches(child, autofocus) ? child : child.querySelector(autofocus);
      if (autoFocusedElt != null) {
        autoFocusedElt.focus();
      }
    }
    function insertNodesBefore(parentNode, insertBefore, fragment, settleInfo) {
      handleAttributes(parentNode, fragment, settleInfo);
      while (fragment.childNodes.length > 0) {
        var child = fragment.firstChild;
        addClassToElement(child, htmx.config.addedClass);
        parentNode.insertBefore(child, insertBefore);
        if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {
          settleInfo.tasks.push(makeAjaxLoadTask(child));
        }
      }
    }
    function cleanUpElement(element) {
      var internalData = getInternalData(element);
      if (internalData.webSocket) {
        internalData.webSocket.close();
      }
      if (internalData.sseEventSource) {
        internalData.sseEventSource.close();
      }
      triggerEvent(element, "htmx:beforeCleanupElement");
      if (internalData.listenerInfos) {
        forEach(internalData.listenerInfos, function(info) {
          if (element !== info.on) {
            info.on.removeEventListener(info.trigger, info.listener);
          }
        });
      }
      if (element.children) {
        forEach(element.children, function(child) {
          cleanUpElement(child);
        });
      }
    }
    function swapOuterHTML(target, fragment, settleInfo) {
      if (target.tagName === "BODY") {
        return swapInnerHTML(target, fragment, settleInfo);
      } else {
        var newElt;
        var eltBeforeNewContent = target.previousSibling;
        insertNodesBefore(parentElt(target), target, fragment, settleInfo);
        if (eltBeforeNewContent == null) {
          newElt = parentElt(target).firstChild;
        } else {
          newElt = eltBeforeNewContent.nextSibling;
        }
        getInternalData(target).replacedWith = newElt;
        settleInfo.elts = [];
        while (newElt && newElt !== target) {
          if (newElt.nodeType === Node.ELEMENT_NODE) {
            settleInfo.elts.push(newElt);
          }
          newElt = newElt.nextElementSibling;
        }
        cleanUpElement(target);
        parentElt(target).removeChild(target);
      }
    }
    function swapAfterBegin(target, fragment, settleInfo) {
      return insertNodesBefore(target, target.firstChild, fragment, settleInfo);
    }
    function swapBeforeBegin(target, fragment, settleInfo) {
      return insertNodesBefore(parentElt(target), target, fragment, settleInfo);
    }
    function swapBeforeEnd(target, fragment, settleInfo) {
      return insertNodesBefore(target, null, fragment, settleInfo);
    }
    function swapAfterEnd(target, fragment, settleInfo) {
      return insertNodesBefore(parentElt(target), target.nextSibling, fragment, settleInfo);
    }
    function swapDelete(target, fragment, settleInfo) {
      cleanUpElement(target);
      return parentElt(target).removeChild(target);
    }
    function swapInnerHTML(target, fragment, settleInfo) {
      var firstChild = target.firstChild;
      insertNodesBefore(target, firstChild, fragment, settleInfo);
      if (firstChild) {
        while (firstChild.nextSibling) {
          cleanUpElement(firstChild.nextSibling);
          target.removeChild(firstChild.nextSibling);
        }
        cleanUpElement(firstChild);
        target.removeChild(firstChild);
      }
    }
    function maybeSelectFromResponse(elt, fragment) {
      var selector = getClosestAttributeValue(elt, "hx-select");
      if (selector) {
        var newFragment = getDocument().createDocumentFragment();
        forEach(fragment.querySelectorAll(selector), function(node) {
          newFragment.appendChild(node);
        });
        fragment = newFragment;
      }
      return fragment;
    }
    function swap(swapStyle, elt, target, fragment, settleInfo) {
      switch (swapStyle) {
        case "none":
          return;
        case "outerHTML":
          swapOuterHTML(target, fragment, settleInfo);
          return;
        case "afterbegin":
          swapAfterBegin(target, fragment, settleInfo);
          return;
        case "beforebegin":
          swapBeforeBegin(target, fragment, settleInfo);
          return;
        case "beforeend":
          swapBeforeEnd(target, fragment, settleInfo);
          return;
        case "afterend":
          swapAfterEnd(target, fragment, settleInfo);
          return;
        case "delete":
          swapDelete(target);
          return;
        default:
          var extensions2 = getExtensions(elt);
          for (var i2 = 0; i2 < extensions2.length; i2++) {
            var ext = extensions2[i2];
            try {
              var newElements = ext.handleSwap(swapStyle, target, fragment, settleInfo);
              if (newElements) {
                if (typeof newElements.length !== "undefined") {
                  for (var j = 0; j < newElements.length; j++) {
                    var child = newElements[j];
                    if (child.nodeType !== Node.TEXT_NODE && child.nodeType !== Node.COMMENT_NODE) {
                      settleInfo.tasks.push(makeAjaxLoadTask(child));
                    }
                  }
                }
                return;
              }
            } catch (e) {
              logError(e);
            }
          }
          if (swapStyle === "innerHTML") {
            swapInnerHTML(target, fragment, settleInfo);
          } else {
            swap(htmx.config.defaultSwapStyle, elt, target, fragment, settleInfo);
          }
      }
    }
    function findTitle(content) {
      if (content.indexOf("<title") > -1) {
        var contentWithSvgsRemoved = content.replace(/<svg(\s[^>]*>|>)([\s\S]*?)<\/svg>/gim, "");
        var result = contentWithSvgsRemoved.match(/<title(\s[^>]*>|>)([\s\S]*?)<\/title>/im);
        if (result) {
          return result[2];
        }
      }
    }
    function selectAndSwap(swapStyle, target, elt, responseText, settleInfo) {
      settleInfo.title = findTitle(responseText);
      var fragment = makeFragment(responseText);
      if (fragment) {
        handleOutOfBandSwaps(fragment, settleInfo);
        fragment = maybeSelectFromResponse(elt, fragment);
        handlePreservedElements(fragment);
        return swap(swapStyle, elt, target, fragment, settleInfo);
      }
    }
    function handleTrigger(xhr3, header, elt) {
      var triggerBody = xhr3.getResponseHeader(header);
      if (triggerBody.indexOf("{") === 0) {
        var triggers = parseJSON(triggerBody);
        for (var eventName in triggers) {
          if (triggers.hasOwnProperty(eventName)) {
            var detail = triggers[eventName];
            if (!isRawObject(detail)) {
              detail = { "value": detail };
            }
            triggerEvent(elt, eventName, detail);
          }
        }
      } else {
        triggerEvent(elt, triggerBody, []);
      }
    }
    var WHITESPACE_OR_COMMA = /[\s,]/;
    var SYMBOL_START = /[_$a-zA-Z]/;
    var SYMBOL_CONT = /[_$a-zA-Z0-9]/;
    var STRINGISH_START = ['"', "'", "/"];
    var NOT_WHITESPACE = /[^\s]/;
    function tokenizeString(str2) {
      var tokens = [];
      var position = 0;
      while (position < str2.length) {
        if (SYMBOL_START.exec(str2.charAt(position))) {
          var startPosition = position;
          while (SYMBOL_CONT.exec(str2.charAt(position + 1))) {
            position++;
          }
          tokens.push(str2.substr(startPosition, position - startPosition + 1));
        } else if (STRINGISH_START.indexOf(str2.charAt(position)) !== -1) {
          var startChar = str2.charAt(position);
          var startPosition = position;
          position++;
          while (position < str2.length && str2.charAt(position) !== startChar) {
            if (str2.charAt(position) === "\\") {
              position++;
            }
            position++;
          }
          tokens.push(str2.substr(startPosition, position - startPosition + 1));
        } else {
          var symbol = str2.charAt(position);
          tokens.push(symbol);
        }
        position++;
      }
      return tokens;
    }
    function isPossibleRelativeReference(token, last, paramName) {
      return SYMBOL_START.exec(token.charAt(0)) && token !== "true" && token !== "false" && token !== "this" && token !== paramName && last !== ".";
    }
    function maybeGenerateConditional(elt, tokens, paramName) {
      if (tokens[0] === "[") {
        tokens.shift();
        var bracketCount = 1;
        var conditionalSource = " return (function(" + paramName + "){ return (";
        var last = null;
        while (tokens.length > 0) {
          var token = tokens[0];
          if (token === "]") {
            bracketCount--;
            if (bracketCount === 0) {
              if (last === null) {
                conditionalSource = conditionalSource + "true";
              }
              tokens.shift();
              conditionalSource += ")})";
              try {
                var conditionFunction = maybeEval(
                  elt,
                  function() {
                    return Function(conditionalSource)();
                  },
                  function() {
                    return true;
                  }
                );
                conditionFunction.source = conditionalSource;
                return conditionFunction;
              } catch (e) {
                triggerErrorEvent(getDocument().body, "htmx:syntax:error", { error: e, source: conditionalSource });
                return null;
              }
            }
          } else if (token === "[") {
            bracketCount++;
          }
          if (isPossibleRelativeReference(token, last, paramName)) {
            conditionalSource += "((" + paramName + "." + token + ") ? (" + paramName + "." + token + ") : (window." + token + "))";
          } else {
            conditionalSource = conditionalSource + token;
          }
          last = tokens.shift();
        }
      }
    }
    function consumeUntil(tokens, match2) {
      var result = "";
      while (tokens.length > 0 && !tokens[0].match(match2)) {
        result += tokens.shift();
      }
      return result;
    }
    var INPUT_SELECTOR = "input, textarea, select";
    function getTriggerSpecs(elt) {
      var explicitTrigger = getAttributeValue(elt, "hx-trigger");
      var triggerSpecs = [];
      if (explicitTrigger) {
        var tokens = tokenizeString(explicitTrigger);
        do {
          consumeUntil(tokens, NOT_WHITESPACE);
          var initialLength = tokens.length;
          var trigger = consumeUntil(tokens, /[,\[\s]/);
          if (trigger !== "") {
            if (trigger === "every") {
              var every = { trigger: "every" };
              consumeUntil(tokens, NOT_WHITESPACE);
              every.pollInterval = parseInterval(consumeUntil(tokens, /[,\[\s]/));
              consumeUntil(tokens, NOT_WHITESPACE);
              var eventFilter = maybeGenerateConditional(elt, tokens, "event");
              if (eventFilter) {
                every.eventFilter = eventFilter;
              }
              triggerSpecs.push(every);
            } else if (trigger.indexOf("sse:") === 0) {
              triggerSpecs.push({ trigger: "sse", sseEvent: trigger.substr(4) });
            } else {
              var triggerSpec = { trigger };
              var eventFilter = maybeGenerateConditional(elt, tokens, "event");
              if (eventFilter) {
                triggerSpec.eventFilter = eventFilter;
              }
              while (tokens.length > 0 && tokens[0] !== ",") {
                consumeUntil(tokens, NOT_WHITESPACE);
                var token = tokens.shift();
                if (token === "changed") {
                  triggerSpec.changed = true;
                } else if (token === "once") {
                  triggerSpec.once = true;
                } else if (token === "consume") {
                  triggerSpec.consume = true;
                } else if (token === "delay" && tokens[0] === ":") {
                  tokens.shift();
                  triggerSpec.delay = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));
                } else if (token === "from" && tokens[0] === ":") {
                  tokens.shift();
                  var from_arg = consumeUntil(tokens, WHITESPACE_OR_COMMA);
                  if (from_arg === "closest" || from_arg === "find") {
                    tokens.shift();
                    from_arg += " " + consumeUntil(
                      tokens,
                      WHITESPACE_OR_COMMA
                    );
                  }
                  triggerSpec.from = from_arg;
                } else if (token === "target" && tokens[0] === ":") {
                  tokens.shift();
                  triggerSpec.target = consumeUntil(tokens, WHITESPACE_OR_COMMA);
                } else if (token === "throttle" && tokens[0] === ":") {
                  tokens.shift();
                  triggerSpec.throttle = parseInterval(consumeUntil(tokens, WHITESPACE_OR_COMMA));
                } else if (token === "queue" && tokens[0] === ":") {
                  tokens.shift();
                  triggerSpec.queue = consumeUntil(tokens, WHITESPACE_OR_COMMA);
                } else if ((token === "root" || token === "threshold") && tokens[0] === ":") {
                  tokens.shift();
                  triggerSpec[token] = consumeUntil(tokens, WHITESPACE_OR_COMMA);
                } else {
                  triggerErrorEvent(elt, "htmx:syntax:error", { token: tokens.shift() });
                }
              }
              triggerSpecs.push(triggerSpec);
            }
          }
          if (tokens.length === initialLength) {
            triggerErrorEvent(elt, "htmx:syntax:error", { token: tokens.shift() });
          }
          consumeUntil(tokens, NOT_WHITESPACE);
        } while (tokens[0] === "," && tokens.shift());
      }
      if (triggerSpecs.length > 0) {
        return triggerSpecs;
      } else if (matches(elt, "form")) {
        return [{ trigger: "submit" }];
      } else if (matches(elt, INPUT_SELECTOR)) {
        return [{ trigger: "change" }];
      } else {
        return [{ trigger: "click" }];
      }
    }
    function cancelPolling(elt) {
      getInternalData(elt).cancelled = true;
    }
    function processPolling(elt, verb, path2, spec) {
      var nodeData = getInternalData(elt);
      nodeData.timeout = setTimeout(function() {
        if (bodyContains(elt) && nodeData.cancelled !== true) {
          if (!maybeFilterEvent(spec, makeEvent("hx:poll:trigger", { triggerSpec: spec, target: elt }))) {
            issueAjaxRequest(verb, path2, elt);
          }
          processPolling(elt, verb, getAttributeValue(elt, "hx-" + verb), spec);
        }
      }, spec.pollInterval);
    }
    function isLocalLink(elt) {
      return location.hostname === elt.hostname && getRawAttribute(elt, "href") && getRawAttribute(elt, "href").indexOf("#") !== 0;
    }
    function boostElement(elt, nodeData, triggerSpecs) {
      if (elt.tagName === "A" && isLocalLink(elt) && elt.target === "" || elt.tagName === "FORM") {
        nodeData.boosted = true;
        var verb, path2;
        if (elt.tagName === "A") {
          verb = "get";
          path2 = getRawAttribute(elt, "href");
          nodeData.pushURL = true;
        } else {
          var rawAttribute = getRawAttribute(elt, "method");
          verb = rawAttribute ? rawAttribute.toLowerCase() : "get";
          if (verb === "get") {
            nodeData.pushURL = true;
          }
          path2 = getRawAttribute(elt, "action");
        }
        triggerSpecs.forEach(function(triggerSpec) {
          addEventListener(elt, verb, path2, nodeData, triggerSpec, true);
        });
      }
    }
    function shouldCancel(evt, elt) {
      if (evt.type === "submit" || evt.type === "click") {
        if (elt.tagName === "FORM") {
          return true;
        }
        if (matches(elt, 'input[type="submit"], button') && closest(elt, "form") !== null) {
          return true;
        }
        if (elt.tagName === "A" && elt.href && (elt.getAttribute("href") === "#" || elt.getAttribute("href").indexOf("#") !== 0)) {
          return true;
        }
      }
      return false;
    }
    function ignoreBoostedAnchorCtrlClick(elt, evt) {
      return getInternalData(elt).boosted && elt.tagName === "A" && evt.type === "click" && (evt.ctrlKey || evt.metaKey);
    }
    function maybeFilterEvent(triggerSpec, evt) {
      var eventFilter = triggerSpec.eventFilter;
      if (eventFilter) {
        try {
          return eventFilter(evt) !== true;
        } catch (e) {
          triggerErrorEvent(getDocument().body, "htmx:eventFilter:error", { error: e, source: eventFilter.source });
          return true;
        }
      }
      return false;
    }
    function addEventListener(elt, verb, path2, nodeData, triggerSpec, explicitCancel) {
      var eltsToListenOn;
      if (triggerSpec.from) {
        eltsToListenOn = querySelectorAllExt(elt, triggerSpec.from);
      } else {
        eltsToListenOn = [elt];
      }
      forEach(eltsToListenOn, function(eltToListenOn) {
        var eventListener = function(evt) {
          if (!bodyContains(elt)) {
            eltToListenOn.removeEventListener(triggerSpec.trigger, eventListener);
            return;
          }
          if (ignoreBoostedAnchorCtrlClick(elt, evt)) {
            return;
          }
          if (explicitCancel || shouldCancel(evt, elt)) {
            evt.preventDefault();
          }
          if (maybeFilterEvent(triggerSpec, evt)) {
            return;
          }
          var eventData = getInternalData(evt);
          eventData.triggerSpec = triggerSpec;
          if (eventData.handledFor == null) {
            eventData.handledFor = [];
          }
          var elementData = getInternalData(elt);
          if (eventData.handledFor.indexOf(elt) < 0) {
            eventData.handledFor.push(elt);
            if (triggerSpec.consume) {
              evt.stopPropagation();
            }
            if (triggerSpec.target && evt.target) {
              if (!matches(evt.target, triggerSpec.target)) {
                return;
              }
            }
            if (triggerSpec.once) {
              if (elementData.triggeredOnce) {
                return;
              } else {
                elementData.triggeredOnce = true;
              }
            }
            if (triggerSpec.changed) {
              if (elementData.lastValue === elt.value) {
                return;
              } else {
                elementData.lastValue = elt.value;
              }
            }
            if (elementData.delayed) {
              clearTimeout(elementData.delayed);
            }
            if (elementData.throttle) {
              return;
            }
            if (triggerSpec.throttle) {
              if (!elementData.throttle) {
                issueAjaxRequest(verb, path2, elt, evt);
                elementData.throttle = setTimeout(function() {
                  elementData.throttle = null;
                }, triggerSpec.throttle);
              }
            } else if (triggerSpec.delay) {
              elementData.delayed = setTimeout(function() {
                issueAjaxRequest(verb, path2, elt, evt);
              }, triggerSpec.delay);
            } else {
              issueAjaxRequest(verb, path2, elt, evt);
            }
          }
        };
        if (nodeData.listenerInfos == null) {
          nodeData.listenerInfos = [];
        }
        nodeData.listenerInfos.push({
          trigger: triggerSpec.trigger,
          listener: eventListener,
          on: eltToListenOn
        });
        eltToListenOn.addEventListener(triggerSpec.trigger, eventListener);
      });
    }
    var windowIsScrolling = false;
    var scrollHandler = null;
    function initScrollHandler() {
      if (!scrollHandler) {
        scrollHandler = function() {
          windowIsScrolling = true;
        };
        window.addEventListener("scroll", scrollHandler);
        setInterval(function() {
          if (windowIsScrolling) {
            windowIsScrolling = false;
            forEach(getDocument().querySelectorAll("[hx-trigger='revealed'],[data-hx-trigger='revealed']"), function(elt) {
              maybeReveal(elt);
            });
          }
        }, 200);
      }
    }
    function maybeReveal(elt) {
      if (!hasAttribute(elt, "data-hx-revealed") && isScrolledIntoView(elt)) {
        elt.setAttribute("data-hx-revealed", "true");
        var nodeData = getInternalData(elt);
        if (nodeData.initialized) {
          issueAjaxRequest(nodeData.verb, nodeData.path, elt);
        } else {
          elt.addEventListener(
            "htmx:afterProcessNode",
            function() {
              issueAjaxRequest(nodeData.verb, nodeData.path, elt);
            },
            { once: true }
          );
        }
      }
    }
    function processWebSocketInfo(elt, nodeData, info) {
      var values2 = splitOnWhitespace(info);
      for (var i2 = 0; i2 < values2.length; i2++) {
        var value = values2[i2].split(/:(.+)/);
        if (value[0] === "connect") {
          ensureWebSocket(elt, value[1], 0);
        }
        if (value[0] === "send") {
          processWebSocketSend(elt);
        }
      }
    }
    function ensureWebSocket(elt, wssSource, retryCount) {
      if (!bodyContains(elt)) {
        return;
      }
      if (wssSource.indexOf("/") == 0) {
        var base_part = location.hostname + (location.port ? ":" + location.port : "");
        if (location.protocol == "https:") {
          wssSource = "wss://" + base_part + wssSource;
        } else if (location.protocol == "http:") {
          wssSource = "ws://" + base_part + wssSource;
        }
      }
      var socket = htmx.createWebSocket(wssSource);
      socket.onerror = function(e) {
        triggerErrorEvent(elt, "htmx:wsError", { error: e, socket });
        maybeCloseWebSocketSource(elt);
      };
      socket.onclose = function(e) {
        if ([1006, 1012, 1013].indexOf(e.code) >= 0) {
          var delay = getWebSocketReconnectDelay(retryCount);
          setTimeout(function() {
            ensureWebSocket(elt, wssSource, retryCount + 1);
          }, delay);
        }
      };
      socket.onopen = function(e) {
        retryCount = 0;
      };
      getInternalData(elt).webSocket = socket;
      socket.addEventListener("message", function(event) {
        if (maybeCloseWebSocketSource(elt)) {
          return;
        }
        var response = event.data;
        withExtensions(elt, function(extension) {
          response = extension.transformResponse(response, null, elt);
        });
        var settleInfo = makeSettleInfo(elt);
        var fragment = makeFragment(response);
        var children = toArray(fragment.children);
        for (var i2 = 0; i2 < children.length; i2++) {
          var child = children[i2];
          oobSwap(getAttributeValue(child, "hx-swap-oob") || "true", child, settleInfo);
        }
        settleImmediately(settleInfo.tasks);
      });
    }
    function maybeCloseWebSocketSource(elt) {
      if (!bodyContains(elt)) {
        getInternalData(elt).webSocket.close();
        return true;
      }
    }
    function processWebSocketSend(elt) {
      var webSocketSourceElt = getClosestMatch(elt, function(parent) {
        return getInternalData(parent).webSocket != null;
      });
      if (webSocketSourceElt) {
        elt.addEventListener(getTriggerSpecs(elt)[0].trigger, function(evt) {
          var webSocket = getInternalData(webSocketSourceElt).webSocket;
          var headers = getHeaders(elt, webSocketSourceElt);
          var results = getInputValues(elt, "post");
          var errors = results.errors;
          var rawParameters = results.values;
          var expressionVars = getExpressionVars(elt);
          var allParameters = mergeObjects(rawParameters, expressionVars);
          var filteredParameters = filterValues(allParameters, elt);
          filteredParameters["HEADERS"] = headers;
          if (errors && errors.length > 0) {
            triggerEvent(elt, "htmx:validation:halted", errors);
            return;
          }
          webSocket.send(JSON.stringify(filteredParameters));
          if (shouldCancel(evt, elt)) {
            evt.preventDefault();
          }
        });
      } else {
        triggerErrorEvent(elt, "htmx:noWebSocketSourceError");
      }
    }
    function getWebSocketReconnectDelay(retryCount) {
      var delay = htmx.config.wsReconnectDelay;
      if (typeof delay === "function") {
        return delay(retryCount);
      }
      if (delay === "full-jitter") {
        var exp = Math.min(retryCount, 6);
        var maxDelay = 1e3 * Math.pow(2, exp);
        return maxDelay * Math.random();
      }
      logError('htmx.config.wsReconnectDelay must either be a function or the string "full-jitter"');
    }
    function processSSEInfo(elt, nodeData, info) {
      var values2 = splitOnWhitespace(info);
      for (var i2 = 0; i2 < values2.length; i2++) {
        var value = values2[i2].split(/:(.+)/);
        if (value[0] === "connect") {
          processSSESource(elt, value[1]);
        }
        if (value[0] === "swap") {
          processSSESwap(elt, value[1]);
        }
      }
    }
    function processSSESource(elt, sseSrc) {
      var source = htmx.createEventSource(sseSrc);
      source.onerror = function(e) {
        triggerErrorEvent(elt, "htmx:sseError", { error: e, source });
        maybeCloseSSESource(elt);
      };
      getInternalData(elt).sseEventSource = source;
    }
    function processSSESwap(elt, sseEventName) {
      var sseSourceElt = getClosestMatch(elt, hasEventSource);
      if (sseSourceElt) {
        var sseEventSource = getInternalData(sseSourceElt).sseEventSource;
        var sseListener = function(event) {
          if (maybeCloseSSESource(sseSourceElt)) {
            sseEventSource.removeEventListener(sseEventName, sseListener);
            return;
          }
          var response = event.data;
          withExtensions(elt, function(extension) {
            response = extension.transformResponse(response, null, elt);
          });
          var swapSpec = getSwapSpecification(elt);
          var target = getTarget(elt);
          var settleInfo = makeSettleInfo(elt);
          selectAndSwap(swapSpec.swapStyle, elt, target, response, settleInfo);
          settleImmediately(settleInfo.tasks);
          triggerEvent(elt, "htmx:sseMessage", event);
        };
        getInternalData(elt).sseListener = sseListener;
        sseEventSource.addEventListener(sseEventName, sseListener);
      } else {
        triggerErrorEvent(elt, "htmx:noSSESourceError");
      }
    }
    function processSSETrigger(elt, verb, path2, sseEventName) {
      var sseSourceElt = getClosestMatch(elt, hasEventSource);
      if (sseSourceElt) {
        var sseEventSource = getInternalData(sseSourceElt).sseEventSource;
        var sseListener = function() {
          if (!maybeCloseSSESource(sseSourceElt)) {
            if (bodyContains(elt)) {
              issueAjaxRequest(verb, path2, elt);
            } else {
              sseEventSource.removeEventListener(sseEventName, sseListener);
            }
          }
        };
        getInternalData(elt).sseListener = sseListener;
        sseEventSource.addEventListener(sseEventName, sseListener);
      } else {
        triggerErrorEvent(elt, "htmx:noSSESourceError");
      }
    }
    function maybeCloseSSESource(elt) {
      if (!bodyContains(elt)) {
        getInternalData(elt).sseEventSource.close();
        return true;
      }
    }
    function hasEventSource(node) {
      return getInternalData(node).sseEventSource != null;
    }
    function loadImmediately(elt, verb, path2, nodeData, delay) {
      var load = function() {
        if (!nodeData.loaded) {
          nodeData.loaded = true;
          issueAjaxRequest(verb, path2, elt);
        }
      };
      if (delay) {
        setTimeout(load, delay);
      } else {
        load();
      }
    }
    function processVerbs(elt, nodeData, triggerSpecs) {
      var explicitAction = false;
      forEach(VERBS, function(verb) {
        if (hasAttribute(elt, "hx-" + verb)) {
          var path2 = getAttributeValue(elt, "hx-" + verb);
          explicitAction = true;
          nodeData.path = path2;
          nodeData.verb = verb;
          triggerSpecs.forEach(function(triggerSpec) {
            if (triggerSpec.sseEvent) {
              processSSETrigger(elt, verb, path2, triggerSpec.sseEvent);
            } else if (triggerSpec.trigger === "revealed") {
              initScrollHandler();
              maybeReveal(elt);
            } else if (triggerSpec.trigger === "intersect") {
              var observerOptions = {};
              if (triggerSpec.root) {
                observerOptions.root = querySelectorExt(elt, triggerSpec.root);
              }
              if (triggerSpec.threshold) {
                observerOptions.threshold = parseFloat(triggerSpec.threshold);
              }
              var observer = new IntersectionObserver(function(entries2) {
                for (var i2 = 0; i2 < entries2.length; i2++) {
                  var entry = entries2[i2];
                  if (entry.isIntersecting) {
                    triggerEvent(elt, "intersect");
                    break;
                  }
                }
              }, observerOptions);
              observer.observe(elt);
              addEventListener(elt, verb, path2, nodeData, triggerSpec);
            } else if (triggerSpec.trigger === "load") {
              loadImmediately(elt, verb, path2, nodeData, triggerSpec.delay);
            } else if (triggerSpec.pollInterval) {
              nodeData.polling = true;
              processPolling(elt, verb, path2, triggerSpec);
            } else {
              addEventListener(elt, verb, path2, nodeData, triggerSpec);
            }
          });
        }
      });
      return explicitAction;
    }
    function evalScript(script) {
      if (script.type === "text/javascript" || script.type === "module" || script.type === "") {
        var newScript = getDocument().createElement("script");
        forEach(script.attributes, function(attr) {
          newScript.setAttribute(attr.name, attr.value);
        });
        newScript.textContent = script.textContent;
        newScript.async = false;
        if (htmx.config.inlineScriptNonce) {
          newScript.nonce = htmx.config.inlineScriptNonce;
        }
        var parent = script.parentElement;
        try {
          parent.insertBefore(newScript, script);
        } catch (e) {
          logError(e);
        } finally {
          parent.removeChild(script);
        }
      }
    }
    function processScripts(elt) {
      if (matches(elt, "script")) {
        evalScript(elt);
      }
      forEach(findAll(elt, "script"), function(script) {
        evalScript(script);
      });
    }
    function hasChanceOfBeingBoosted() {
      return document.querySelector("[hx-boost], [data-hx-boost]");
    }
    function findElementsToProcess(elt) {
      if (elt.querySelectorAll) {
        var boostedElts = hasChanceOfBeingBoosted() ? ", a, form" : "";
        var results = elt.querySelectorAll(VERB_SELECTOR + boostedElts + ", [hx-sse], [data-hx-sse], [hx-ws], [data-hx-ws], [hx-ext], [hx-data-ext]");
        return results;
      } else {
        return [];
      }
    }
    function initButtonTracking(form) {
      var maybeSetLastButtonClicked = function(evt) {
        if (matches(evt.target, "button, input[type='submit']")) {
          var internalData = getInternalData(form);
          internalData.lastButtonClicked = evt.target;
        }
      };
      form.addEventListener("click", maybeSetLastButtonClicked);
      form.addEventListener("focusin", maybeSetLastButtonClicked);
      form.addEventListener("focusout", function(evt) {
        var internalData = getInternalData(form);
        internalData.lastButtonClicked = null;
      });
    }
    function initNode(elt) {
      if (elt.closest && elt.closest(htmx.config.disableSelector)) {
        return;
      }
      var nodeData = getInternalData(elt);
      if (!nodeData.initialized) {
        nodeData.initialized = true;
        triggerEvent(elt, "htmx:beforeProcessNode");
        if (elt.value) {
          nodeData.lastValue = elt.value;
        }
        var triggerSpecs = getTriggerSpecs(elt);
        var explicitAction = processVerbs(elt, nodeData, triggerSpecs);
        if (!explicitAction && getClosestAttributeValue(elt, "hx-boost") === "true") {
          boostElement(elt, nodeData, triggerSpecs);
        }
        if (elt.tagName === "FORM") {
          initButtonTracking(elt);
        }
        var sseInfo = getAttributeValue(elt, "hx-sse");
        if (sseInfo) {
          processSSEInfo(elt, nodeData, sseInfo);
        }
        var wsInfo = getAttributeValue(elt, "hx-ws");
        if (wsInfo) {
          processWebSocketInfo(elt, nodeData, wsInfo);
        }
        triggerEvent(elt, "htmx:afterProcessNode");
      }
    }
    function processNode(elt) {
      elt = resolveTarget(elt);
      initNode(elt);
      forEach(findElementsToProcess(elt), function(child) {
        initNode(child);
      });
    }
    function kebabEventName(str2) {
      return str2.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase();
    }
    function makeEvent(eventName, detail) {
      var evt;
      if (window.CustomEvent && typeof window.CustomEvent === "function") {
        evt = new CustomEvent(eventName, { bubbles: true, cancelable: true, detail });
      } else {
        evt = getDocument().createEvent("CustomEvent");
        evt.initCustomEvent(eventName, true, true, detail);
      }
      return evt;
    }
    function triggerErrorEvent(elt, eventName, detail) {
      triggerEvent(elt, eventName, mergeObjects({ error: eventName }, detail));
    }
    function ignoreEventForLogging(eventName) {
      return eventName === "htmx:afterProcessNode";
    }
    function withExtensions(elt, toDo) {
      forEach(getExtensions(elt), function(extension) {
        try {
          toDo(extension);
        } catch (e) {
          logError(e);
        }
      });
    }
    function logError(msg) {
      if (console.error) {
        console.error(msg);
      } else if (console.log) {
        console.log("ERROR: ", msg);
      }
    }
    function triggerEvent(elt, eventName, detail) {
      elt = resolveTarget(elt);
      if (detail == null) {
        detail = {};
      }
      detail["elt"] = elt;
      var event = makeEvent(eventName, detail);
      if (htmx.logger && !ignoreEventForLogging(eventName)) {
        htmx.logger(elt, eventName, detail);
      }
      if (detail.error) {
        logError(detail.error);
        triggerEvent(elt, "htmx:error", { errorInfo: detail });
      }
      var eventResult = elt.dispatchEvent(event);
      var kebabName = kebabEventName(eventName);
      if (eventResult && kebabName !== eventName) {
        var kebabedEvent = makeEvent(kebabName, event.detail);
        eventResult = eventResult && elt.dispatchEvent(kebabedEvent);
      }
      withExtensions(elt, function(extension) {
        eventResult = eventResult && extension.onEvent(eventName, event) !== false;
      });
      return eventResult;
    }
    var currentPathForHistory = location.pathname + location.search;
    function getHistoryElement() {
      var historyElt = getDocument().querySelector("[hx-history-elt],[data-hx-history-elt]");
      return historyElt || getDocument().body;
    }
    function saveToHistoryCache(url, content, title, scroll) {
      var historyCache = parseJSON(localStorage.getItem("htmx-history-cache")) || [];
      for (var i2 = 0; i2 < historyCache.length; i2++) {
        if (historyCache[i2].url === url) {
          historyCache.splice(i2, 1);
          break;
        }
      }
      historyCache.push({ url, content, title, scroll });
      while (historyCache.length > htmx.config.historyCacheSize) {
        historyCache.shift();
      }
      while (historyCache.length > 0) {
        try {
          localStorage.setItem("htmx-history-cache", JSON.stringify(historyCache));
          break;
        } catch (e) {
          triggerErrorEvent(getDocument().body, "htmx:historyCacheError", { cause: e, cache: historyCache });
          historyCache.shift();
        }
      }
    }
    function getCachedHistory(url) {
      var historyCache = parseJSON(localStorage.getItem("htmx-history-cache")) || [];
      for (var i2 = 0; i2 < historyCache.length; i2++) {
        if (historyCache[i2].url === url) {
          return historyCache[i2];
        }
      }
      return null;
    }
    function cleanInnerHtmlForHistory(elt) {
      var className = htmx.config.requestClass;
      var clone = elt.cloneNode(true);
      forEach(findAll(clone, "." + className), function(child) {
        removeClassFromElement(child, className);
      });
      return clone.innerHTML;
    }
    function saveCurrentPageToHistory() {
      var elt = getHistoryElement();
      var path2 = currentPathForHistory || location.pathname + location.search;
      triggerEvent(getDocument().body, "htmx:beforeHistorySave", { path: path2, historyElt: elt });
      if (htmx.config.historyEnabled)
        history.replaceState({ htmx: true }, getDocument().title, window.location.href);
      saveToHistoryCache(path2, cleanInnerHtmlForHistory(elt), getDocument().title, window.scrollY);
    }
    function pushUrlIntoHistory(path2) {
      if (htmx.config.historyEnabled)
        history.pushState({ htmx: true }, "", path2);
      currentPathForHistory = path2;
    }
    function settleImmediately(tasks) {
      forEach(tasks, function(task) {
        task.call();
      });
    }
    function loadHistoryFromServer(path2) {
      var request = new XMLHttpRequest();
      var details = { path: path2, xhr: request };
      triggerEvent(getDocument().body, "htmx:historyCacheMiss", details);
      request.open("GET", path2, true);
      request.setRequestHeader("HX-History-Restore-Request", "true");
      request.onload = function() {
        if (this.status >= 200 && this.status < 400) {
          triggerEvent(getDocument().body, "htmx:historyCacheMissLoad", details);
          var fragment = makeFragment(this.response);
          fragment = fragment.querySelector("[hx-history-elt],[data-hx-history-elt]") || fragment;
          var historyElement = getHistoryElement();
          var settleInfo = makeSettleInfo(historyElement);
          swapInnerHTML(historyElement, fragment, settleInfo);
          settleImmediately(settleInfo.tasks);
          currentPathForHistory = path2;
          triggerEvent(getDocument().body, "htmx:historyRestore", { path: path2 });
        } else {
          triggerErrorEvent(getDocument().body, "htmx:historyCacheMissLoadError", details);
        }
      };
      request.send();
    }
    function restoreHistory(path2) {
      saveCurrentPageToHistory();
      path2 = path2 || location.pathname + location.search;
      var cached = getCachedHistory(path2);
      if (cached) {
        var fragment = makeFragment(cached.content);
        var historyElement = getHistoryElement();
        var settleInfo = makeSettleInfo(historyElement);
        swapInnerHTML(historyElement, fragment, settleInfo);
        settleImmediately(settleInfo.tasks);
        document.title = cached.title;
        window.scrollTo(0, cached.scroll);
        currentPathForHistory = path2;
        triggerEvent(getDocument().body, "htmx:historyRestore", { path: path2 });
      } else {
        if (htmx.config.refreshOnHistoryMiss) {
          window.location.reload(true);
        } else {
          loadHistoryFromServer(path2);
        }
      }
    }
    function shouldPush(elt) {
      var pushUrl = getClosestAttributeValue(elt, "hx-push-url");
      return pushUrl && pushUrl !== "false" || getInternalData(elt).boosted && getInternalData(elt).pushURL;
    }
    function getPushUrl(elt) {
      var pushUrl = getClosestAttributeValue(elt, "hx-push-url");
      return pushUrl === "true" || pushUrl === "false" ? null : pushUrl;
    }
    function addRequestIndicatorClasses(elt) {
      var indicators = findAttributeTargets(elt, "hx-indicator");
      if (indicators == null) {
        indicators = [elt];
      }
      forEach(indicators, function(ic) {
        ic.classList["add"].call(ic.classList, htmx.config.requestClass);
      });
      return indicators;
    }
    function removeRequestIndicatorClasses(indicators) {
      forEach(indicators, function(ic) {
        ic.classList["remove"].call(ic.classList, htmx.config.requestClass);
      });
    }
    function haveSeenNode(processed, elt) {
      for (var i2 = 0; i2 < processed.length; i2++) {
        var node = processed[i2];
        if (node.isSameNode(elt)) {
          return true;
        }
      }
      return false;
    }
    function shouldInclude(elt) {
      if (elt.name === "" || elt.name == null || elt.disabled) {
        return false;
      }
      if (elt.type === "button" || elt.type === "submit" || elt.tagName === "image" || elt.tagName === "reset" || elt.tagName === "file") {
        return false;
      }
      if (elt.type === "checkbox" || elt.type === "radio") {
        return elt.checked;
      }
      return true;
    }
    function processInputValue(processed, values2, errors, elt, validate) {
      if (elt == null || haveSeenNode(processed, elt)) {
        return;
      } else {
        processed.push(elt);
      }
      if (shouldInclude(elt)) {
        var name = getRawAttribute(elt, "name");
        var value = elt.value;
        if (elt.multiple) {
          value = toArray(elt.querySelectorAll("option:checked")).map(function(e) {
            return e.value;
          });
        }
        if (elt.files) {
          value = toArray(elt.files);
        }
        if (name != null && value != null) {
          var current = values2[name];
          if (current) {
            if (Array.isArray(current)) {
              if (Array.isArray(value)) {
                values2[name] = current.concat(value);
              } else {
                current.push(value);
              }
            } else {
              if (Array.isArray(value)) {
                values2[name] = [current].concat(value);
              } else {
                values2[name] = [current, value];
              }
            }
          } else {
            values2[name] = value;
          }
        }
        if (validate) {
          validateElement(elt, errors);
        }
      }
      if (matches(elt, "form")) {
        var inputs = elt.elements;
        forEach(inputs, function(input) {
          processInputValue(processed, values2, errors, input, validate);
        });
      }
    }
    function validateElement(element, errors) {
      if (element.willValidate) {
        triggerEvent(element, "htmx:validation:validate");
        if (!element.checkValidity()) {
          errors.push({ elt: element, message: element.validationMessage, validity: element.validity });
          triggerEvent(element, "htmx:validation:failed", { message: element.validationMessage, validity: element.validity });
        }
      }
    }
    function getInputValues(elt, verb) {
      var processed = [];
      var values2 = {};
      var formValues = {};
      var errors = [];
      var internalData = getInternalData(elt);
      var validate = matches(elt, "form") && elt.noValidate !== true;
      if (internalData.lastButtonClicked) {
        validate = validate && internalData.lastButtonClicked.formNoValidate !== true;
      }
      if (verb !== "get") {
        processInputValue(processed, formValues, errors, closest(elt, "form"), validate);
      }
      processInputValue(processed, values2, errors, elt, validate);
      if (internalData.lastButtonClicked) {
        var name = getRawAttribute(internalData.lastButtonClicked, "name");
        if (name) {
          values2[name] = internalData.lastButtonClicked.value;
        }
      }
      var includes = findAttributeTargets(elt, "hx-include");
      forEach(includes, function(node) {
        processInputValue(processed, values2, errors, node, validate);
        if (!matches(node, "form")) {
          forEach(node.querySelectorAll(INPUT_SELECTOR), function(descendant) {
            processInputValue(processed, values2, errors, descendant, validate);
          });
        }
      });
      values2 = mergeObjects(values2, formValues);
      return { errors, values: values2 };
    }
    function appendParam(returnStr, name, realValue) {
      if (returnStr !== "") {
        returnStr += "&";
      }
      if (String(realValue) === "[object Object]") {
        realValue = JSON.stringify(realValue);
      }
      var s2 = encodeURIComponent(realValue);
      returnStr += encodeURIComponent(name) + "=" + s2;
      return returnStr;
    }
    function urlEncode(values2) {
      var returnStr = "";
      for (var name in values2) {
        if (values2.hasOwnProperty(name)) {
          var value = values2[name];
          if (Array.isArray(value)) {
            forEach(value, function(v) {
              returnStr = appendParam(returnStr, name, v);
            });
          } else {
            returnStr = appendParam(returnStr, name, value);
          }
        }
      }
      return returnStr;
    }
    function makeFormData(values2) {
      var formData = new FormData();
      for (var name in values2) {
        if (values2.hasOwnProperty(name)) {
          var value = values2[name];
          if (Array.isArray(value)) {
            forEach(value, function(v) {
              formData.append(name, v);
            });
          } else {
            formData.append(name, value);
          }
        }
      }
      return formData;
    }
    function getHeaders(elt, target, prompt2) {
      var headers = {
        "HX-Request": "true",
        "HX-Trigger": getRawAttribute(elt, "id"),
        "HX-Trigger-Name": getRawAttribute(elt, "name"),
        "HX-Target": getAttributeValue(target, "id"),
        "HX-Current-URL": getDocument().location.href
      };
      getValuesForElement(elt, "hx-headers", false, headers);
      if (prompt2 !== void 0) {
        headers["HX-Prompt"] = prompt2;
      }
      if (getInternalData(elt).boosted) {
        headers["HX-Boosted"] = "true";
      }
      return headers;
    }
    function filterValues(inputValues, elt) {
      var paramsValue = getClosestAttributeValue(elt, "hx-params");
      if (paramsValue) {
        if (paramsValue === "none") {
          return {};
        } else if (paramsValue === "*") {
          return inputValues;
        } else if (paramsValue.indexOf("not ") === 0) {
          forEach(paramsValue.substr(4).split(","), function(name) {
            name = name.trim();
            delete inputValues[name];
          });
          return inputValues;
        } else {
          var newValues = {};
          forEach(paramsValue.split(","), function(name) {
            name = name.trim();
            newValues[name] = inputValues[name];
          });
          return newValues;
        }
      } else {
        return inputValues;
      }
    }
    function isAnchorLink(elt) {
      return getRawAttribute(elt, "href") && getRawAttribute(elt, "href").indexOf("#") >= 0;
    }
    function getSwapSpecification(elt, swapInfoOverride) {
      var swapInfo = swapInfoOverride ? swapInfoOverride : getClosestAttributeValue(elt, "hx-swap");
      var swapSpec = {
        "swapStyle": getInternalData(elt).boosted ? "innerHTML" : htmx.config.defaultSwapStyle,
        "swapDelay": htmx.config.defaultSwapDelay,
        "settleDelay": htmx.config.defaultSettleDelay
      };
      if (getInternalData(elt).boosted && !isAnchorLink(elt)) {
        swapSpec["show"] = "top";
      }
      if (swapInfo) {
        var split2 = splitOnWhitespace(swapInfo);
        if (split2.length > 0) {
          swapSpec["swapStyle"] = split2[0];
          for (var i2 = 1; i2 < split2.length; i2++) {
            var modifier = split2[i2];
            if (modifier.indexOf("swap:") === 0) {
              swapSpec["swapDelay"] = parseInterval(modifier.substr(5));
            }
            if (modifier.indexOf("settle:") === 0) {
              swapSpec["settleDelay"] = parseInterval(modifier.substr(7));
            }
            if (modifier.indexOf("scroll:") === 0) {
              var scrollSpec = modifier.substr(7);
              var splitSpec = scrollSpec.split(":");
              var scrollVal = splitSpec.pop();
              var selectorVal = splitSpec.length > 0 ? splitSpec.join(":") : null;
              swapSpec["scroll"] = scrollVal;
              swapSpec["scrollTarget"] = selectorVal;
            }
            if (modifier.indexOf("show:") === 0) {
              var showSpec = modifier.substr(5);
              var splitSpec = showSpec.split(":");
              var showVal = splitSpec.pop();
              var selectorVal = splitSpec.length > 0 ? splitSpec.join(":") : null;
              swapSpec["show"] = showVal;
              swapSpec["showTarget"] = selectorVal;
            }
            if (modifier.indexOf("focus-scroll:") === 0) {
              var focusScrollVal = modifier.substr("focus-scroll:".length);
              swapSpec["focusScroll"] = focusScrollVal == "true";
            }
          }
        }
      }
      return swapSpec;
    }
    function encodeParamsForBody(xhr3, elt, filteredParameters) {
      var encodedParameters = null;
      withExtensions(elt, function(extension) {
        if (encodedParameters == null) {
          encodedParameters = extension.encodeParameters(xhr3, filteredParameters, elt);
        }
      });
      if (encodedParameters != null) {
        return encodedParameters;
      } else {
        if (getClosestAttributeValue(elt, "hx-encoding") === "multipart/form-data" || matches(elt, "form") && getRawAttribute(elt, "enctype") === "multipart/form-data") {
          return makeFormData(filteredParameters);
        } else {
          return urlEncode(filteredParameters);
        }
      }
    }
    function makeSettleInfo(target) {
      return { tasks: [], elts: [target] };
    }
    function updateScrollState(content, swapSpec) {
      var first = content[0];
      var last = content[content.length - 1];
      if (swapSpec.scroll) {
        var target = null;
        if (swapSpec.scrollTarget) {
          target = querySelectorExt(first, swapSpec.scrollTarget);
        }
        if (swapSpec.scroll === "top" && (first || target)) {
          target = target || first;
          target.scrollTop = 0;
        }
        if (swapSpec.scroll === "bottom" && (last || target)) {
          target = target || last;
          target.scrollTop = target.scrollHeight;
        }
      }
      if (swapSpec.show) {
        var target = null;
        if (swapSpec.showTarget) {
          var targetStr = swapSpec.showTarget;
          if (swapSpec.showTarget === "window") {
            targetStr = "body";
          }
          target = querySelectorExt(first, targetStr);
        }
        if (swapSpec.show === "top" && (first || target)) {
          target = target || first;
          target.scrollIntoView({ block: "start", behavior: htmx.config.scrollBehavior });
        }
        if (swapSpec.show === "bottom" && (last || target)) {
          target = target || last;
          target.scrollIntoView({ block: "end", behavior: htmx.config.scrollBehavior });
        }
      }
    }
    function getValuesForElement(elt, attr, evalAsDefault, values2) {
      if (values2 == null) {
        values2 = {};
      }
      if (elt == null) {
        return values2;
      }
      var attributeValue = getAttributeValue(elt, attr);
      if (attributeValue) {
        var str2 = attributeValue.trim();
        var evaluateValue = evalAsDefault;
        if (str2.indexOf("javascript:") === 0) {
          str2 = str2.substr(11);
          evaluateValue = true;
        } else if (str2.indexOf("js:") === 0) {
          str2 = str2.substr(3);
          evaluateValue = true;
        }
        if (str2.indexOf("{") !== 0) {
          str2 = "{" + str2 + "}";
        }
        var varsValues;
        if (evaluateValue) {
          varsValues = maybeEval(elt, function() {
            return Function("return (" + str2 + ")")();
          }, {});
        } else {
          varsValues = parseJSON(str2);
        }
        for (var key in varsValues) {
          if (varsValues.hasOwnProperty(key)) {
            if (values2[key] == null) {
              values2[key] = varsValues[key];
            }
          }
        }
      }
      return getValuesForElement(parentElt(elt), attr, evalAsDefault, values2);
    }
    function maybeEval(elt, toEval, defaultVal) {
      if (htmx.config.allowEval) {
        return toEval();
      } else {
        triggerErrorEvent(elt, "htmx:evalDisallowedError");
        return defaultVal;
      }
    }
    function getHXVarsForElement(elt, expressionVars) {
      return getValuesForElement(elt, "hx-vars", true, expressionVars);
    }
    function getHXValsForElement(elt, expressionVars) {
      return getValuesForElement(elt, "hx-vals", false, expressionVars);
    }
    function getExpressionVars(elt) {
      return mergeObjects(getHXVarsForElement(elt), getHXValsForElement(elt));
    }
    function safelySetHeaderValue(xhr3, header, headerValue) {
      if (headerValue !== null) {
        try {
          xhr3.setRequestHeader(header, headerValue);
        } catch (e) {
          xhr3.setRequestHeader(header, encodeURIComponent(headerValue));
          xhr3.setRequestHeader(header + "-URI-AutoEncoded", "true");
        }
      }
    }
    function getResponseURL(xhr3) {
      if (xhr3.responseURL && typeof URL !== "undefined") {
        try {
          var url = new URL(xhr3.responseURL);
          return url.pathname + url.search;
        } catch (e) {
          triggerErrorEvent(getDocument().body, "htmx:badResponseUrl", { url: xhr3.responseURL });
        }
      }
    }
    function hasHeader(xhr3, regexp) {
      return xhr3.getAllResponseHeaders().match(regexp);
    }
    function ajaxHelper(verb, path2, context) {
      verb = verb.toLowerCase();
      if (context) {
        if (context instanceof Element || isType(context, "String")) {
          return issueAjaxRequest(verb, path2, null, null, {
            targetOverride: resolveTarget(context),
            returnPromise: true
          });
        } else {
          return issueAjaxRequest(
            verb,
            path2,
            resolveTarget(context.source),
            context.event,
            {
              handler: context.handler,
              headers: context.headers,
              values: context.values,
              targetOverride: resolveTarget(context.target),
              swapOverride: context.swap,
              returnPromise: true
            }
          );
        }
      } else {
        return issueAjaxRequest(verb, path2, null, null, {
          returnPromise: true
        });
      }
    }
    function hierarchyForElt(elt) {
      var arr = [];
      while (elt) {
        arr.push(elt);
        elt = elt.parentElement;
      }
      return arr;
    }
    function issueAjaxRequest(verb, path2, elt, event, etc) {
      var resolve = null;
      var reject = null;
      etc = etc != null ? etc : {};
      if (etc.returnPromise && typeof Promise !== "undefined") {
        var promise = new Promise(function(_resolve, _reject) {
          resolve = _resolve;
          reject = _reject;
        });
      }
      if (elt == null) {
        elt = getDocument().body;
      }
      var responseHandler = etc.handler || handleAjaxResponse;
      if (!bodyContains(elt)) {
        return;
      }
      var target = etc.targetOverride || getTarget(elt);
      if (target == null || target == DUMMY_ELT) {
        triggerErrorEvent(elt, "htmx:targetError", { target: getAttributeValue(elt, "hx-target") });
        return;
      }
      var syncElt = elt;
      var eltData = getInternalData(elt);
      var syncStrategy = getClosestAttributeValue(elt, "hx-sync");
      var queueStrategy = null;
      var abortable = false;
      if (syncStrategy) {
        var syncStrings = syncStrategy.split(":");
        var selector = syncStrings[0].trim();
        if (selector === "this") {
          syncElt = findThisElement(elt, "hx-sync");
        } else {
          syncElt = querySelectorExt(elt, selector);
        }
        syncStrategy = (syncStrings[1] || "drop").trim();
        eltData = getInternalData(syncElt);
        if (syncStrategy === "drop" && eltData.xhr && eltData.abortable !== true) {
          return;
        } else if (syncStrategy === "abort") {
          if (eltData.xhr) {
            return;
          } else {
            abortable = true;
          }
        } else if (syncStrategy === "replace") {
          triggerEvent(syncElt, "htmx:abort");
        } else if (syncStrategy.indexOf("queue") === 0) {
          var queueStrArray = syncStrategy.split(" ");
          queueStrategy = (queueStrArray[1] || "last").trim();
        }
      }
      if (eltData.xhr) {
        if (eltData.abortable) {
          triggerEvent(syncElt, "htmx:abort");
        } else {
          if (queueStrategy == null) {
            if (event) {
              var eventData = getInternalData(event);
              if (eventData && eventData.triggerSpec && eventData.triggerSpec.queue) {
                queueStrategy = eventData.triggerSpec.queue;
              }
            }
            if (queueStrategy == null) {
              queueStrategy = "last";
            }
          }
          if (eltData.queuedRequests == null) {
            eltData.queuedRequests = [];
          }
          if (queueStrategy === "first" && eltData.queuedRequests.length === 0) {
            eltData.queuedRequests.push(function() {
              issueAjaxRequest(verb, path2, elt, event, etc);
            });
          } else if (queueStrategy === "all") {
            eltData.queuedRequests.push(function() {
              issueAjaxRequest(verb, path2, elt, event, etc);
            });
          } else if (queueStrategy === "last") {
            eltData.queuedRequests = [];
            eltData.queuedRequests.push(function() {
              issueAjaxRequest(verb, path2, elt, event, etc);
            });
          }
          return;
        }
      }
      var xhr3 = new XMLHttpRequest();
      eltData.xhr = xhr3;
      eltData.abortable = abortable;
      var endRequestLock = function() {
        eltData.xhr = null;
        eltData.abortable = false;
        if (eltData.queuedRequests != null && eltData.queuedRequests.length > 0) {
          var queuedRequest = eltData.queuedRequests.shift();
          queuedRequest();
        }
      };
      var promptQuestion = getClosestAttributeValue(elt, "hx-prompt");
      if (promptQuestion) {
        var promptResponse = prompt(promptQuestion);
        if (promptResponse === null || !triggerEvent(elt, "htmx:prompt", { prompt: promptResponse, target })) {
          maybeCall(resolve);
          endRequestLock();
          return promise;
        }
      }
      var confirmQuestion = getClosestAttributeValue(elt, "hx-confirm");
      if (confirmQuestion) {
        if (!confirm(confirmQuestion)) {
          maybeCall(resolve);
          endRequestLock();
          return promise;
        }
      }
      var headers = getHeaders(elt, target, promptResponse);
      if (etc.headers) {
        headers = mergeObjects(headers, etc.headers);
      }
      var results = getInputValues(elt, verb);
      var errors = results.errors;
      var rawParameters = results.values;
      if (etc.values) {
        rawParameters = mergeObjects(rawParameters, etc.values);
      }
      var expressionVars = getExpressionVars(elt);
      var allParameters = mergeObjects(rawParameters, expressionVars);
      var filteredParameters = filterValues(allParameters, elt);
      if (verb !== "get" && getClosestAttributeValue(elt, "hx-encoding") == null) {
        headers["Content-Type"] = "application/x-www-form-urlencoded";
      }
      if (path2 == null || path2 === "") {
        path2 = getDocument().location.href;
      }
      var requestAttrValues = getValuesForElement(elt, "hx-request");
      var requestConfig = {
        parameters: filteredParameters,
        unfilteredParameters: allParameters,
        headers,
        target,
        verb,
        errors,
        withCredentials: etc.credentials || requestAttrValues.credentials || htmx.config.withCredentials,
        timeout: etc.timeout || requestAttrValues.timeout || htmx.config.timeout,
        path: path2,
        triggeringEvent: event
      };
      if (!triggerEvent(elt, "htmx:configRequest", requestConfig)) {
        maybeCall(resolve);
        endRequestLock();
        return promise;
      }
      path2 = requestConfig.path;
      verb = requestConfig.verb;
      headers = requestConfig.headers;
      filteredParameters = requestConfig.parameters;
      errors = requestConfig.errors;
      if (errors && errors.length > 0) {
        triggerEvent(elt, "htmx:validation:halted", requestConfig);
        maybeCall(resolve);
        endRequestLock();
        return promise;
      }
      var splitPath = path2.split("#");
      var pathNoAnchor = splitPath[0];
      var anchor = splitPath[1];
      if (verb === "get") {
        var finalPathForGet = pathNoAnchor;
        var values2 = Object.keys(filteredParameters).length !== 0;
        if (values2) {
          if (finalPathForGet.indexOf("?") < 0) {
            finalPathForGet += "?";
          } else {
            finalPathForGet += "&";
          }
          finalPathForGet += urlEncode(filteredParameters);
          if (anchor) {
            finalPathForGet += "#" + anchor;
          }
        }
        xhr3.open("GET", finalPathForGet, true);
      } else {
        xhr3.open(verb.toUpperCase(), path2, true);
      }
      xhr3.overrideMimeType("text/html");
      xhr3.withCredentials = requestConfig.withCredentials;
      xhr3.timeout = requestConfig.timeout;
      if (requestAttrValues.noHeaders)
        ;
      else {
        for (var header in headers) {
          if (headers.hasOwnProperty(header)) {
            var headerValue = headers[header];
            safelySetHeaderValue(xhr3, header, headerValue);
          }
        }
      }
      var responseInfo = {
        xhr: xhr3,
        target,
        requestConfig,
        etc,
        pathInfo: {
          path: path2,
          finalPath: finalPathForGet,
          anchor
        }
      };
      xhr3.onload = function() {
        try {
          var hierarchy = hierarchyForElt(elt);
          responseHandler(elt, responseInfo);
          removeRequestIndicatorClasses(indicators);
          triggerEvent(elt, "htmx:afterRequest", responseInfo);
          triggerEvent(elt, "htmx:afterOnLoad", responseInfo);
          if (!bodyContains(elt)) {
            var secondaryTriggerElt = null;
            while (hierarchy.length > 0 && secondaryTriggerElt == null) {
              var parentEltInHierarchy = hierarchy.shift();
              if (bodyContains(parentEltInHierarchy)) {
                secondaryTriggerElt = parentEltInHierarchy;
              }
            }
            if (secondaryTriggerElt) {
              triggerEvent(secondaryTriggerElt, "htmx:afterRequest", responseInfo);
              triggerEvent(secondaryTriggerElt, "htmx:afterOnLoad", responseInfo);
            }
          }
          maybeCall(resolve);
          endRequestLock();
        } catch (e) {
          triggerErrorEvent(elt, "htmx:onLoadError", mergeObjects({ error: e }, responseInfo));
          throw e;
        }
      };
      xhr3.onerror = function() {
        removeRequestIndicatorClasses(indicators);
        triggerErrorEvent(elt, "htmx:afterRequest", responseInfo);
        triggerErrorEvent(elt, "htmx:sendError", responseInfo);
        maybeCall(reject);
        endRequestLock();
      };
      xhr3.onabort = function() {
        removeRequestIndicatorClasses(indicators);
        triggerErrorEvent(elt, "htmx:afterRequest", responseInfo);
        triggerErrorEvent(elt, "htmx:sendAbort", responseInfo);
        maybeCall(reject);
        endRequestLock();
      };
      xhr3.ontimeout = function() {
        removeRequestIndicatorClasses(indicators);
        triggerErrorEvent(elt, "htmx:afterRequest", responseInfo);
        triggerErrorEvent(elt, "htmx:timeout", responseInfo);
        maybeCall(reject);
        endRequestLock();
      };
      if (!triggerEvent(elt, "htmx:beforeRequest", responseInfo)) {
        maybeCall(resolve);
        endRequestLock();
        return promise;
      }
      var indicators = addRequestIndicatorClasses(elt);
      forEach(["loadstart", "loadend", "progress", "abort"], function(eventName) {
        forEach([xhr3, xhr3.upload], function(target2) {
          target2.addEventListener(eventName, function(event2) {
            triggerEvent(elt, "htmx:xhr:" + eventName, {
              lengthComputable: event2.lengthComputable,
              loaded: event2.loaded,
              total: event2.total
            });
          });
        });
      });
      triggerEvent(elt, "htmx:beforeSend", responseInfo);
      xhr3.send(verb === "get" ? null : encodeParamsForBody(xhr3, elt, filteredParameters));
      return promise;
    }
    function handleAjaxResponse(elt, responseInfo) {
      var xhr3 = responseInfo.xhr;
      var target = responseInfo.target;
      var etc = responseInfo.etc;
      if (!triggerEvent(elt, "htmx:beforeOnLoad", responseInfo))
        return;
      if (hasHeader(xhr3, /HX-Trigger:/i)) {
        handleTrigger(xhr3, "HX-Trigger", elt);
      }
      if (hasHeader(xhr3, /HX-Push:/i)) {
        var pushedUrl = xhr3.getResponseHeader("HX-Push");
      }
      if (hasHeader(xhr3, /HX-Redirect:/i)) {
        window.location.href = xhr3.getResponseHeader("HX-Redirect");
        return;
      }
      if (hasHeader(xhr3, /HX-Refresh:/i)) {
        if ("true" === xhr3.getResponseHeader("HX-Refresh")) {
          location.reload();
          return;
        }
      }
      if (hasHeader(xhr3, /HX-Retarget:/i)) {
        responseInfo.target = getDocument().querySelector(xhr3.getResponseHeader("HX-Retarget"));
      }
      var shouldSaveHistory;
      if (pushedUrl == "false") {
        shouldSaveHistory = false;
      } else {
        shouldSaveHistory = shouldPush(elt) || pushedUrl;
      }
      var shouldSwap = xhr3.status >= 200 && xhr3.status < 400 && xhr3.status !== 204;
      var serverResponse = xhr3.response;
      var isError = xhr3.status >= 400;
      var beforeSwapDetails = mergeObjects({ shouldSwap, serverResponse, isError }, responseInfo);
      if (!triggerEvent(target, "htmx:beforeSwap", beforeSwapDetails))
        return;
      target = beforeSwapDetails.target;
      serverResponse = beforeSwapDetails.serverResponse;
      isError = beforeSwapDetails.isError;
      responseInfo.failed = isError;
      responseInfo.successful = !isError;
      if (beforeSwapDetails.shouldSwap) {
        if (xhr3.status === 286) {
          cancelPolling(elt);
        }
        withExtensions(elt, function(extension) {
          serverResponse = extension.transformResponse(serverResponse, xhr3, elt);
        });
        if (shouldSaveHistory) {
          saveCurrentPageToHistory();
        }
        var swapOverride = etc.swapOverride;
        var swapSpec = getSwapSpecification(elt, swapOverride);
        target.classList.add(htmx.config.swappingClass);
        var doSwap = function() {
          try {
            var activeElt = document.activeElement;
            var selectionInfo = {};
            try {
              selectionInfo = {
                elt: activeElt,
                start: activeElt ? activeElt.selectionStart : null,
                end: activeElt ? activeElt.selectionEnd : null
              };
            } catch (e) {
            }
            var settleInfo = makeSettleInfo(target);
            selectAndSwap(swapSpec.swapStyle, target, elt, serverResponse, settleInfo);
            if (selectionInfo.elt && !bodyContains(selectionInfo.elt) && selectionInfo.elt.id) {
              var newActiveElt = document.getElementById(selectionInfo.elt.id);
              var focusOptions = { preventScroll: swapSpec.focusScroll !== void 0 ? !swapSpec.focusScroll : !htmx.config.defaultFocusScroll };
              if (newActiveElt) {
                if (selectionInfo.start && newActiveElt.setSelectionRange) {
                  newActiveElt.setSelectionRange(selectionInfo.start, selectionInfo.end);
                }
                newActiveElt.focus(focusOptions);
              }
            }
            target.classList.remove(htmx.config.swappingClass);
            forEach(settleInfo.elts, function(elt2) {
              if (elt2.classList) {
                elt2.classList.add(htmx.config.settlingClass);
              }
              triggerEvent(elt2, "htmx:afterSwap", responseInfo);
            });
            if (responseInfo.pathInfo.anchor) {
              location.hash = responseInfo.pathInfo.anchor;
            }
            if (hasHeader(xhr3, /HX-Trigger-After-Swap:/i)) {
              var finalElt = elt;
              if (!bodyContains(elt)) {
                finalElt = getDocument().body;
              }
              handleTrigger(xhr3, "HX-Trigger-After-Swap", finalElt);
            }
            var doSettle = function() {
              forEach(settleInfo.tasks, function(task) {
                task.call();
              });
              forEach(settleInfo.elts, function(elt2) {
                if (elt2.classList) {
                  elt2.classList.remove(htmx.config.settlingClass);
                }
                triggerEvent(elt2, "htmx:afterSettle", responseInfo);
              });
              if (shouldSaveHistory) {
                var pathToPush = pushedUrl || getPushUrl(elt) || getResponseURL(xhr3) || responseInfo.pathInfo.finalPath || responseInfo.pathInfo.path;
                pushUrlIntoHistory(pathToPush);
                triggerEvent(getDocument().body, "htmx:pushedIntoHistory", { path: pathToPush });
              }
              if (settleInfo.title) {
                var titleElt = find("title");
                if (titleElt) {
                  titleElt.innerHTML = settleInfo.title;
                } else {
                  window.document.title = settleInfo.title;
                }
              }
              updateScrollState(settleInfo.elts, swapSpec);
              if (hasHeader(xhr3, /HX-Trigger-After-Settle:/i)) {
                var finalElt2 = elt;
                if (!bodyContains(elt)) {
                  finalElt2 = getDocument().body;
                }
                handleTrigger(xhr3, "HX-Trigger-After-Settle", finalElt2);
              }
            };
            if (swapSpec.settleDelay > 0) {
              setTimeout(doSettle, swapSpec.settleDelay);
            } else {
              doSettle();
            }
          } catch (e) {
            triggerErrorEvent(elt, "htmx:swapError", responseInfo);
            throw e;
          }
        };
        if (swapSpec.swapDelay > 0) {
          setTimeout(doSwap, swapSpec.swapDelay);
        } else {
          doSwap();
        }
      }
      if (isError) {
        triggerErrorEvent(elt, "htmx:responseError", mergeObjects({ error: "Response Status Error Code " + xhr3.status + " from " + responseInfo.pathInfo.path }, responseInfo));
      }
    }
    var extensions = {};
    function extensionBase() {
      return {
        init: function(api) {
          return null;
        },
        onEvent: function(name, evt) {
          return true;
        },
        transformResponse: function(text, xhr3, elt) {
          return text;
        },
        isInlineSwap: function(swapStyle) {
          return false;
        },
        handleSwap: function(swapStyle, target, fragment, settleInfo) {
          return false;
        },
        encodeParameters: function(xhr3, parameters, elt) {
          return null;
        }
      };
    }
    function defineExtension(name, extension) {
      if (extension.init) {
        extension.init(internalAPI);
      }
      extensions[name] = mergeObjects(extensionBase(), extension);
    }
    function removeExtension(name) {
      delete extensions[name];
    }
    function getExtensions(elt, extensionsToReturn, extensionsToIgnore) {
      if (elt == void 0) {
        return extensionsToReturn;
      }
      if (extensionsToReturn == void 0) {
        extensionsToReturn = [];
      }
      if (extensionsToIgnore == void 0) {
        extensionsToIgnore = [];
      }
      var extensionsForElement = getAttributeValue(elt, "hx-ext");
      if (extensionsForElement) {
        forEach(extensionsForElement.split(","), function(extensionName) {
          extensionName = extensionName.replace(/ /g, "");
          if (extensionName.slice(0, 7) == "ignore:") {
            extensionsToIgnore.push(extensionName.slice(7));
            return;
          }
          if (extensionsToIgnore.indexOf(extensionName) < 0) {
            var extension = extensions[extensionName];
            if (extension && extensionsToReturn.indexOf(extension) < 0) {
              extensionsToReturn.push(extension);
            }
          }
        });
      }
      return getExtensions(parentElt(elt), extensionsToReturn, extensionsToIgnore);
    }
    function ready(fn) {
      if (getDocument().readyState !== "loading") {
        fn();
      } else {
        getDocument().addEventListener("DOMContentLoaded", fn);
      }
    }
    function insertIndicatorStyles() {
      if (htmx.config.includeIndicatorStyles !== false) {
        getDocument().head.insertAdjacentHTML(
          "beforeend",
          "<style>                      ." + htmx.config.indicatorClass + "{opacity:0;transition: opacity 200ms ease-in;}                      ." + htmx.config.requestClass + " ." + htmx.config.indicatorClass + "{opacity:1}                      ." + htmx.config.requestClass + "." + htmx.config.indicatorClass + "{opacity:1}                    </style>"
        );
      }
    }
    function getMetaConfig() {
      var element = getDocument().querySelector('meta[name="htmx-config"]');
      if (element) {
        return parseJSON(element.content);
      } else {
        return null;
      }
    }
    function mergeMetaConfig() {
      var metaConfig = getMetaConfig();
      if (metaConfig) {
        htmx.config = mergeObjects(htmx.config, metaConfig);
      }
    }
    ready(function() {
      mergeMetaConfig();
      insertIndicatorStyles();
      var body = getDocument().body;
      processNode(body);
      var restoredElts = getDocument().querySelectorAll(
        "[hx-trigger='restored'],[data-hx-trigger='restored']"
      );
      body.addEventListener("htmx:abort", function(evt) {
        var target = evt.target;
        var internalData = getInternalData(target);
        if (internalData && internalData.xhr) {
          internalData.xhr.abort();
        }
      });
      window.onpopstate = function(event) {
        if (event.state && event.state.htmx) {
          restoreHistory();
          forEach(restoredElts, function(elt) {
            triggerEvent(elt, "htmx:restored", {
              "document": getDocument(),
              "triggerEvent": triggerEvent
            });
          });
        }
      };
      setTimeout(function() {
        triggerEvent(body, "htmx:load", {});
      }, 0);
    });
    return htmx;
  }();
});
window.errorHandler = window.errorHandler || {};
export { DPClipboard, setupPostHog };
